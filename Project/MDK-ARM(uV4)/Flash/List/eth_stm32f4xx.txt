; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\eth_stm32f4xx.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\eth_stm32f4xx.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\..\RL-ARM\Config -I..\..\RL-ARM\Driver -I..\..\RL-ARM\RL-RTX\inc -IC:\Keil4.74\ARM\RV31\INC -IC:\Keil4.74\ARM\CMSIS\Include -IC:\Keil4.74\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -D__RTX --omf_browse=.\flash\obj\eth_stm32f4xx.crf ..\..\RL-ARM\Driver\ETH_STM32F4xx.c]
                          THUMB

                          AREA ||i.ETH_IRQHandler||, CODE, READONLY, ALIGN=2

                  ETH_IRQHandler PROC
;;;456    */
;;;457    void ETH_IRQHandler (void) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;458    {
;;;459    	OS_FRAME *frame;
;;;460    	U32 i, RxLen;
;;;461    	U32 *sp,*dp;
;;;462    
;;;463    	i = RxBufIndex;
000004  482f              LDR      r0,|L1.196|
000006  7804              LDRB     r4,[r0,#0]  ; RxBufIndex
;;;464    	
;;;465    	/* 循环所有接受描述符列表，遇到未接收到数据的退出循环 */
;;;466    	do 
000008  bf00              NOP      
                  |L1.10|
;;;467    	{
;;;468    		/*
;;;469    			#define DMA_RX_ERROR_MASK   (DMA_RX_ES | DMA_RX_LE | DMA_RX_RWT | \
;;;470    								         DMA_RX_RE | DMA_RX_CE)
;;;471    			
;;;472    			有错误，放弃此帧数据，错误类型包含如下：
;;;473    			位15 DMA_RX_ES：错误汇总(Error summary)，即CRC错误，接收错误，看门狗超时，延迟冲突等。
;;;474    		    位12 DMA_RX_LE：长度错误(Length error)
;;;475    		                    该位置1时，指示接收帧的实际长度与长度/类型字段的值不符。该字段仅在帧类
;;;476    		                    型位(RDES0[5])复位后有效。
;;;477    			位4 DMA_RX_RWT：接收看门狗超时 (Receive watchdog timeout)
;;;478    		                    该位置1时，表示接收看门狗计时器在接收当前帧时超时，且当前帧在看门狗超
;;;479    		                    时后被截断了
;;;480    			位3 DMA_RX_RE： 接收错误 (Receive error)
;;;481                                该位置1时，表示在帧接收期间，当发出RX_DV信号时，会发出RX_ERR信号。
;;;482    			位1 DMA_RX_CE： CRC 错误(CRC error)
;;;483                                该位置1时，表示接收的帧发生循环冗余校验(CRC)错误。只有最后一个描述符
;;;484    		                    (RDES0[8])置1时，该字段才有效
;;;485    		*/
;;;486    		if (Rx_Desc[i].Stat & DMA_RX_ERROR_MASK)
00000a  482f              LDR      r0,|L1.200|
00000c  eb001004          ADD      r0,r0,r4,LSL #4
000010  6800              LDR      r0,[r0,#0]
000012  f249011a          MOV      r1,#0x901a
000016  4208              TST      r0,r1
000018  d000              BEQ      |L1.28|
;;;487    		{
;;;488    			goto rel;
00001a  e030              B        |L1.126|
                  |L1.28|
;;;489    		}
;;;490    		
;;;491    		/*
;;;492    			#define DMA_RX_SEG_MASK   (DMA_RX_FS | DMA_RX_LS)
;;;493    		    位9 FS：第一个描述符 (First descriptor)
;;;494                        该位置1时，指示此描述符包含帧的第一个缓冲区。如果第一个缓冲区的大小为0，则第二
;;;495                        个缓冲区将包含帧的帧头。如果第二个缓冲区的大小为0，则下一个描述符将包含帧的帧头。
;;;496    		
;;;497    		    位8 LS：最后一个描述符 (Last descriptor)
;;;498                        该位置1时，指示此描述符指向的缓冲区为帧的最后一个缓冲区。
;;;499    		
;;;500    		    下面的函数用于判断此帧数据是否只有一个缓冲，初始化接收描述符列表的时候，每个描述符仅设置了
;;;501    		    一个缓冲。
;;;502    		*/
;;;503    		if ((Rx_Desc[i].Stat & DMA_RX_SEG_MASK) != DMA_RX_SEG_MASK) 
00001c  482a              LDR      r0,|L1.200|
00001e  eb001004          ADD      r0,r0,r4,LSL #4
000022  6800              LDR      r0,[r0,#0]
000024  f4007040          AND      r0,r0,#0x300
000028  f5b07f40          CMP      r0,#0x300
00002c  d000              BEQ      |L1.48|
;;;504    		{
;;;505    			goto rel;
00002e  e026              B        |L1.126|
                  |L1.48|
;;;506    		}
;;;507    		
;;;508    		RxLen = ((Rx_Desc[i].Stat >> 16) & 0x3FFF) - 4;
000030  4825              LDR      r0,|L1.200|
000032  eb001004          ADD      r0,r0,r4,LSL #4
000036  6800              LDR      r0,[r0,#0]
000038  f3c0400d          UBFX     r0,r0,#16,#14
00003c  1f05              SUBS     r5,r0,#4
;;;509    		if (RxLen > ETH_MTU) 
00003e  f24050ea          MOV      r0,#0x5ea
000042  4285              CMP      r5,r0
000044  d900              BLS      |L1.72|
;;;510    		{
;;;511    			/* 数据包太大，直接放弃 */
;;;512    			goto rel;
000046  e01a              B        |L1.126|
                  |L1.72|
;;;513    		}
;;;514    		
;;;515    		/* 申请动态内存，RxLen或上0x80000000表示动态内存不足了不会调用函数sys_error() */
;;;516    		frame = alloc_mem (RxLen | 0x80000000);
000048  f0454000          ORR      r0,r5,#0x80000000
00004c  f7fffffe          BL       alloc_mem
000050  4606              MOV      r6,r0
;;;517    		
;;;518    		/* 如果动态内存申请失败了，放弃此帧数据；成功了，通过函数put_in_queue存入队列中 */
;;;519    		if (frame != NULL) 
000052  b19e              CBZ      r6,|L1.124|
;;;520    		{
;;;521    			sp = (U32 *)(Rx_Desc[i].Addr & ~3);
000054  481c              LDR      r0,|L1.200|
000056  eb001004          ADD      r0,r0,r4,LSL #4
00005a  6880              LDR      r0,[r0,#8]
00005c  f0200703          BIC      r7,r0,#3
;;;522    			dp = (U32 *)&frame->data[0];
000060  f1060804          ADD      r8,r6,#4
;;;523    			for (RxLen = (RxLen + 3) >> 2; RxLen; RxLen--) 
000064  1ce8              ADDS     r0,r5,#3
000066  0885              LSRS     r5,r0,#2
000068  e003              B        |L1.114|
                  |L1.106|
;;;524    			{
;;;525    				*dp++ = *sp++;
00006a  cf01              LDM      r7!,{r0}
00006c  f8480b04          STR      r0,[r8],#4
000070  1e6d              SUBS     r5,r5,#1              ;523
                  |L1.114|
000072  2d00              CMP      r5,#0                 ;523
000074  d1f9              BNE      |L1.106|
;;;526    			}
;;;527    			put_in_queue (frame);
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       put_in_queue
                  |L1.124|
;;;528    		}
;;;529    		
;;;530    		/* 设置此接收描述符继续接收新的数据 */
;;;531    		rel: Rx_Desc[i].Stat = DMA_RX_OWN;
00007c  bf00              NOP      
                  |L1.126|
00007e  f04f4000          MOV      r0,#0x80000000
000082  4911              LDR      r1,|L1.200|
000084  eb011104          ADD      r1,r1,r4,LSL #4
000088  6008              STR      r0,[r1,#0]
;;;532    
;;;533    		if (++i == NUM_RX_BUF) i = 0;
00008a  1c60              ADDS     r0,r4,#1
00008c  4604              MOV      r4,r0
00008e  2804              CMP      r0,#4
000090  d100              BNE      |L1.148|
000092  2400              MOVS     r4,#0
                  |L1.148|
;;;534    	}
;;;535    	while (!(Rx_Desc[i].Stat & DMA_RX_OWN));
000094  480c              LDR      r0,|L1.200|
000096  eb001004          ADD      r0,r0,r4,LSL #4
00009a  6800              LDR      r0,[r0,#0]
00009c  f0104f00          TST      r0,#0x80000000
0000a0  d0b3              BEQ      |L1.10|
;;;536    	
;;;537    	RxBufIndex = i;
0000a2  4908              LDR      r1,|L1.196|
0000a4  700c              STRB     r4,[r1,#0]
;;;538    
;;;539    	/*
;;;540    	   DMASR DMA的状态寄存器（DMA status register）
;;;541    	   位7 RBUS：接收缓冲区不可用状态 (Receive buffer unavailable status)
;;;542                     此位指示接收列表中的下一个描述符由CPU所拥有，DMA无法获取。接收过程进入挂起状态。
;;;543    	             要恢复处理接收描述符，CPU应更改描述符的拥有关系，然后发出接收轮询请求命令。如果
;;;544    	             未发出接收轮询请求命令，则当接收到下一个识别的传入帧时，接收过程会恢复。仅当上一
;;;545    	             接收描述符由DMA所拥有时，才能将ETH_DMASR[7]置1。
;;;546    	
;;;547    	   DMAIER的接收缓冲区不可用中断RBUIE是bit7，对于的接收缓冲区不可用状态在DMA状态寄存器中也是bit7。
;;;548    	*/
;;;549    	if (ETH->DMASR & INT_RBUIE) 
0000a6  4809              LDR      r0,|L1.204|
0000a8  6940              LDR      r0,[r0,#0x14]
0000aa  f0100f80          TST      r0,#0x80
0000ae  d004              BEQ      |L1.186|
;;;550    	{
;;;551    		/* 接收缓冲区不可用，重新恢复DMA传输 */
;;;552    		ETH->DMASR = ETH_DMASR_RBUS;
0000b0  2080              MOVS     r0,#0x80
0000b2  4906              LDR      r1,|L1.204|
0000b4  6148              STR      r0,[r1,#0x14]
;;;553    		ETH->DMARPDR = 0;
0000b6  2000              MOVS     r0,#0
0000b8  6088              STR      r0,[r1,#8]
                  |L1.186|
;;;554    	}
;;;555    	
;;;556    	/* 
;;;557    	   DMASR DMA的状态寄存器（DMA status register）
;;;558    	   这里实现清除中断挂起标志 
;;;559    	   位16 ETH_DMASR_NIS：所有正常中断 (Normal interrupt summary)
;;;560    	   位15 ETH_DMASR_AIS：所有异常中断 (Abnormal interrupt summary)
;;;561    	   位6  ETH_DMASR_RS ：接收状态 (Receive status)
;;;562    	                       此位指示帧接收已完成，具体的帧状态信息已经包含在描述符中，接收仍保持运行状态。
;;;563    	*/
;;;564    	ETH->DMASR = ETH_DMASR_NIS | ETH_DMASR_AIS | ETH_DMASR_RS;
0000ba  4805              LDR      r0,|L1.208|
0000bc  4903              LDR      r1,|L1.204|
0000be  6148              STR      r0,[r1,#0x14]
;;;565    }
0000c0  e8bd81f0          POP      {r4-r8,pc}
;;;566    
                          ENDP

                  |L1.196|
                          DCD      RxBufIndex
                  |L1.200|
                          DCD      Rx_Desc
                  |L1.204|
                          DCD      0x40029000
                  |L1.208|
                          DCD      0x00018040

                          AREA ||i.EXTI9_5_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI9_5_IRQHandler PROC
;;;812    #define ETH_DISCONNECT "ETH_LINK Disconnect\r\n"
;;;813    void EXTI9_5_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;814    {
;;;815    	U32 regv, tout;
;;;816    	
;;;817    	if (EXTI_GetITStatus(EXTI_Line6) != RESET)
000002  2040              MOVS     r0,#0x40
000004  f7fffffe          BL       EXTI_GetITStatus
000008  2800              CMP      r0,#0
00000a  d042              BEQ      |L2.146|
;;;818    	{
;;;819    		/* 可以考虑在此处加入延迟，有时连接状态变了，但是寄存器没有及时更新*/
;;;820    		regv = read_PHY(PHY_REG_INTERRUPT);
00000c  2015              MOVS     r0,#0x15
00000e  f7fffffe          BL       read_PHY
000012  4604              MOV      r4,r0
;;;821    		if(regv & (1 << 2))
000014  f0140f04          TST      r4,#4
000018  d038              BEQ      |L2.140|
;;;822    		{
;;;823    			/* 重新插入后要多读几次，保证寄存器BMSR被更新 */
;;;824    			for(tout = 0; tout < 10; tout++) 
00001a  2500              MOVS     r5,#0
00001c  e008              B        |L2.48|
                  |L2.30|
;;;825    			{
;;;826    				regv = read_PHY (PHY_REG_BMSR);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       read_PHY
000024  4604              MOV      r4,r0
;;;827    				if (regv & (1 << 2)) 
000026  f0140f04          TST      r4,#4
00002a  d000              BEQ      |L2.46|
;;;828    				{
;;;829    					break;
00002c  e002              B        |L2.52|
                  |L2.46|
00002e  1c6d              ADDS     r5,r5,#1              ;824
                  |L2.48|
000030  2d0a              CMP      r5,#0xa               ;824
000032  d3f4              BCC      |L2.30|
                  |L2.52|
000034  bf00              NOP      
;;;830    				}
;;;831    			}
;;;832    
;;;833    			/* 连接上网线 */
;;;834    			if(regv & (1 << 2)) 
000036  f0140f04          TST      r4,#4
00003a  d013              BEQ      |L2.100|
;;;835    			{
;;;836    				#ifdef ETH_CONSTATUS
;;;837    					const char *pError = ETH_CONNECT;
00003c  a115              ADR      r1,|L2.148|
;;;838    					uint8_t i;
;;;839    				#endif
;;;840    				
;;;841    				g_ucEthLinkStatus = 1;
00003e  2201              MOVS     r2,#1
000040  4b19              LDR      r3,|L2.168|
000042  701a              STRB     r2,[r3,#0]
;;;842    				
;;;843    				#ifdef ETH_CONSTATUS
;;;844    					for (i = 0; i < sizeof(ETH_CONNECT); i++)
000044  2000              MOVS     r0,#0
000046  e00a              B        |L2.94|
                  |L2.72|
;;;845    					{
;;;846    						USART1->DR = pError[i];
000048  5c0a              LDRB     r2,[r1,r0]
00004a  4b18              LDR      r3,|L2.172|
00004c  809a              STRH     r2,[r3,#4]
;;;847    						/* 等待发送结束 */
;;;848    						while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET);
00004e  bf00              NOP      
                  |L2.80|
000050  4a16              LDR      r2,|L2.172|
000052  8812              LDRH     r2,[r2,#0]
000054  f0120f40          TST      r2,#0x40
000058  d0fa              BEQ      |L2.80|
00005a  1c42              ADDS     r2,r0,#1              ;844
00005c  b2d0              UXTB     r0,r2                 ;844
                  |L2.94|
00005e  2813              CMP      r0,#0x13              ;844
000060  d3f2              BCC      |L2.72|
;;;849    					}
;;;850    				#endif 
;;;851    			}
000062  e013              B        |L2.140|
                  |L2.100|
;;;852    			/* 网线断开 */
;;;853    			else
;;;854    			{
;;;855    				#ifdef ETH_CONSTATUS
;;;856    					const char *pError = ETH_DISCONNECT;
000064  a112              ADR      r1,|L2.176|
;;;857    					uint8_t i;
;;;858    				#endif
;;;859    				
;;;860    				g_ucEthLinkStatus = 0;
000066  2200              MOVS     r2,#0
000068  4b0f              LDR      r3,|L2.168|
00006a  701a              STRB     r2,[r3,#0]
;;;861    				
;;;862    				#ifdef ETH_CONSTATUS
;;;863    					for (i = 0; i < sizeof(ETH_DISCONNECT); i++)
00006c  2000              MOVS     r0,#0
00006e  e00a              B        |L2.134|
                  |L2.112|
;;;864    					{
;;;865    						USART1->DR = pError[i];
000070  5c0a              LDRB     r2,[r1,r0]
000072  4b0e              LDR      r3,|L2.172|
000074  809a              STRH     r2,[r3,#4]
;;;866    						/* 等待发送结束 */
;;;867    						while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET);
000076  bf00              NOP      
                  |L2.120|
000078  4a0c              LDR      r2,|L2.172|
00007a  8812              LDRH     r2,[r2,#0]
00007c  f0120f40          TST      r2,#0x40
000080  d0fa              BEQ      |L2.120|
000082  1c42              ADDS     r2,r0,#1              ;863
000084  b2d0              UXTB     r0,r2                 ;863
                  |L2.134|
000086  2816              CMP      r0,#0x16              ;863
000088  d3f2              BCC      |L2.112|
;;;868    					}
;;;869    				#endif
;;;870    				
;;;871    			}
00008a  bf00              NOP      
                  |L2.140|
;;;872    			
;;;873    		}
;;;874    		/* 清中断挂起位 */
;;;875    		EXTI_ClearITPendingBit(EXTI_Line6);
00008c  2040              MOVS     r0,#0x40
00008e  f7fffffe          BL       EXTI_ClearITPendingBit
                  |L2.146|
;;;876    	}
;;;877    }
000092  bd70              POP      {r4-r6,pc}
;;;878    
                          ENDP

                  |L2.148|
000094  4554485f          DCB      "ETH_LINK Connect\r\n",0
000098  4c494e4b
00009c  20436f6e
0000a0  6e656374
0000a4  0d0a00  
0000a7  00                DCB      0
                  |L2.168|
                          DCD      g_ucEthLinkStatus
                  |L2.172|
                          DCD      0x40011000
                  |L2.176|
0000b0  4554485f          DCB      "ETH_LINK Disconnect\r\n",0
0000b4  4c494e4b
0000b8  20446973
0000bc  636f6e6e
0000c0  6563740d
0000c4  0a00    
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||i.Eth_Link_EXTIConfig||, CODE, READONLY, ALIGN=2

                  Eth_Link_EXTIConfig PROC
;;;766    */
;;;767    static void Eth_Link_EXTIConfig(void)
000000  b500              PUSH     {lr}
;;;768    {
000002  b085              SUB      sp,sp,#0x14
;;;769    	GPIO_InitTypeDef GPIO_InitStructure;
;;;770    	EXTI_InitTypeDef EXTI_InitStructure;
;;;771    	NVIC_InitTypeDef NVIC_InitStructure;
;;;772    
;;;773    	/* 安富莱STM32-V6开发板使用PH6作为中断输入口, 下降沿表示中断信号 */
;;;774    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOH, ENABLE);
000004  2101              MOVS     r1,#1
000006  2080              MOVS     r0,#0x80
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;775    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;776    
;;;777    	/* 配置中断引脚是输入 */
;;;778    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
000014  2000              MOVS     r0,#0
000016  f88d0010          STRB     r0,[sp,#0x10]
;;;779    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00001a  f88d0012          STRB     r0,[sp,#0x12]
;;;780    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;781    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000022  2040              MOVS     r0,#0x40
000024  9003              STR      r0,[sp,#0xc]
;;;782    	GPIO_Init(GPIOH, &GPIO_InitStructure);
000026  a903              ADD      r1,sp,#0xc
000028  4812              LDR      r0,|L3.116|
00002a  f7fffffe          BL       GPIO_Init
;;;783    
;;;784    	/* 配置外部中断线连接到相应引脚 */
;;;785    	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOH, EXTI_PinSource6);
00002e  2106              MOVS     r1,#6
000030  2007              MOVS     r0,#7
000032  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;786    
;;;787    	/* 配置外部中断线 */
;;;788    	EXTI_InitStructure.EXTI_Line = EXTI_Line6;
000036  2040              MOVS     r0,#0x40
000038  9001              STR      r0,[sp,#4]
;;;789    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00003a  2000              MOVS     r0,#0
00003c  f88d0008          STRB     r0,[sp,#8]
;;;790    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000040  200c              MOVS     r0,#0xc
000042  f88d0009          STRB     r0,[sp,#9]
;;;791    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000046  2001              MOVS     r0,#1
000048  f88d000a          STRB     r0,[sp,#0xa]
;;;792    	EXTI_Init(&EXTI_InitStructure);
00004c  a801              ADD      r0,sp,#4
00004e  f7fffffe          BL       EXTI_Init
;;;793    
;;;794    	/* 使能中断通道 */
;;;795    	NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
000052  2017              MOVS     r0,#0x17
000054  f88d0000          STRB     r0,[sp,#0]
;;;796    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000058  2001              MOVS     r0,#1
00005a  f88d0001          STRB     r0,[sp,#1]
;;;797    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00005e  2000              MOVS     r0,#0
000060  f88d0002          STRB     r0,[sp,#2]
;;;798    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000064  2001              MOVS     r0,#1
000066  f88d0003          STRB     r0,[sp,#3]
;;;799    	NVIC_Init(&NVIC_InitStructure);
00006a  4668              MOV      r0,sp
00006c  f7fffffe          BL       NVIC_Init
;;;800    }
000070  b005              ADD      sp,sp,#0x14
000072  bd00              POP      {pc}
;;;801    
                          ENDP

                  |L3.116|
                          DCD      0x40021c00

                          AREA ||i.init_ethernet||, CODE, READONLY, ALIGN=2

                  init_ethernet PROC
;;;123    */
;;;124    void init_ethernet (void) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;125    {
;;;126    	U32 regv,tout,conn; 
;;;127    
;;;128    	/* 关闭PHY中断触发引脚 */
;;;129    	NVIC_DisableIRQ(EXTI9_5_IRQn);
000004  2017              MOVS     r0,#0x17
000006  2101              MOVS     r1,#1
000008  4081              LSLS     r1,r1,r0
00000a  4ac8              LDR      r2,|L4.812|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
;;;130    
;;;131    	/* 使能系统配置控制器时钟 */
;;;132    	RCC->APB2ENR |= (1 << 14);
000014  48c6              LDR      r0,|L4.816|
000016  6800              LDR      r0,[r0,#0]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  49c4              LDR      r1,|L4.816|
00001e  6008              STR      r0,[r1,#0]
;;;133    
;;;134    	/* 复位以太网MAC */
;;;135    	RCC->AHB1RSTR |=  0x02000000;
000020  48c3              LDR      r0,|L4.816|
000022  3834              SUBS     r0,r0,#0x34
000024  6800              LDR      r0,[r0,#0]
000026  f0407000          ORR      r0,r0,#0x2000000
00002a  49c1              LDR      r1,|L4.816|
00002c  3934              SUBS     r1,r1,#0x34
00002e  6008              STR      r0,[r1,#0]
;;;136    
;;;137    	/* 选择RMII接口，必须在 MAC 处于复位状态且在使能 MAC 时钟之前完成此配置 */
;;;138    	SYSCFG->PMC |=  (1 << 23);
000030  48c0              LDR      r0,|L4.820|
000032  6800              LDR      r0,[r0,#0]
000034  f4400000          ORR      r0,r0,#0x800000
000038  49be              LDR      r1,|L4.820|
00003a  6008              STR      r0,[r1,#0]
;;;139    
;;;140    	/* 停止复位以太网MAC */
;;;141    	RCC->AHB1RSTR &= ~0x02000000;
00003c  48bc              LDR      r0,|L4.816|
00003e  3834              SUBS     r0,r0,#0x34
000040  6800              LDR      r0,[r0,#0]
000042  f0207000          BIC      r0,r0,#0x2000000
000046  49ba              LDR      r1,|L4.816|
000048  3934              SUBS     r1,r1,#0x34
00004a  6008              STR      r0,[r1,#0]
;;;142    
;;;143    	/* 使能以太网时钟，GPIOA，GPIOB，GPIOC，GPIOG时钟 */
;;;144    	RCC->AHB1ENR |= 0x1E000047;
00004c  48b8              LDR      r0,|L4.816|
00004e  3814              SUBS     r0,r0,#0x14
000050  6800              LDR      r0,[r0,#0]
000052  49b9              LDR      r1,|L4.824|
000054  4308              ORRS     r0,r0,r1
000056  49b6              LDR      r1,|L4.816|
000058  3914              SUBS     r1,r1,#0x14
00005a  6008              STR      r0,[r1,#0]
;;;145    
;;;146    	/* 原始驱动还配置了PA8，用于给PHY芯片提供时钟，V6开发板外置有源晶振，无需配置PA8 */
;;;147    	/* 配置PA1，PA2和PA7，复用功能，推挽模式，100MHz，无上拉下拉，复用到AF11 (Ethernet) */
;;;148    	GPIOA->MODER   &= ~0x0000C03C;
00005c  48b7              LDR      r0,|L4.828|
00005e  6800              LDR      r0,[r0,#0]
000060  f24c013c          MOV      r1,#0xc03c
000064  4388              BICS     r0,r0,r1
000066  49b5              LDR      r1,|L4.828|
000068  6008              STR      r0,[r1,#0]
;;;149    	GPIOA->MODER   |=  0x00008028;              
00006a  4608              MOV      r0,r1
00006c  6800              LDR      r0,[r0,#0]
00006e  f2480128          MOV      r1,#0x8028
000072  4308              ORRS     r0,r0,r1
000074  49b1              LDR      r1,|L4.828|
000076  6008              STR      r0,[r1,#0]
;;;150    	GPIOA->OTYPER  &= ~0x00000086;              
000078  4608              MOV      r0,r1
00007a  6840              LDR      r0,[r0,#4]
00007c  f0200086          BIC      r0,r0,#0x86
000080  6048              STR      r0,[r1,#4]
;;;151    	GPIOA->OSPEEDR |=  0x0003C03C;              
000082  4608              MOV      r0,r1
000084  6880              LDR      r0,[r0,#8]
000086  49ae              LDR      r1,|L4.832|
000088  4308              ORRS     r0,r0,r1
00008a  49ac              LDR      r1,|L4.828|
00008c  6088              STR      r0,[r1,#8]
;;;152    	GPIOA->PUPDR   &= ~0x0003C03C;             
00008e  4608              MOV      r0,r1
000090  68c0              LDR      r0,[r0,#0xc]
000092  49ab              LDR      r1,|L4.832|
000094  43c9              MVNS     r1,r1
000096  4008              ANDS     r0,r0,r1
000098  49a8              LDR      r1,|L4.828|
00009a  60c8              STR      r0,[r1,#0xc]
;;;153    	GPIOA->AFR[0]  &= ~0xF0000FF0;
00009c  4608              MOV      r0,r1
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  49a8              LDR      r1,|L4.836|
0000a2  4008              ANDS     r0,r0,r1
0000a4  49a5              LDR      r1,|L4.828|
0000a6  6208              STR      r0,[r1,#0x20]
;;;154    	GPIOA->AFR[0]  |=  0xB0000BB0;              
0000a8  4608              MOV      r0,r1
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  49a6              LDR      r1,|L4.840|
0000ae  4308              ORRS     r0,r0,r1
0000b0  49a2              LDR      r1,|L4.828|
0000b2  6208              STR      r0,[r1,#0x20]
;;;155    
;;;156    	/* 配置PC1，PC4和PC5，复用功能，推挽模式，100MHz，无上拉下拉，复用到AF11 (Ethernet) */
;;;157    	GPIOC->MODER   &= ~0x00000F0C;
0000b4  48a5              LDR      r0,|L4.844|
0000b6  6800              LDR      r0,[r0,#0]
0000b8  f640710c          MOV      r1,#0xf0c
0000bc  4388              BICS     r0,r0,r1
0000be  49a3              LDR      r1,|L4.844|
0000c0  6008              STR      r0,[r1,#0]
;;;158    	GPIOC->MODER   |=  0x00000A08;             
0000c2  4608              MOV      r0,r1
0000c4  6800              LDR      r0,[r0,#0]
0000c6  f6402108          MOV      r1,#0xa08
0000ca  4308              ORRS     r0,r0,r1
0000cc  499f              LDR      r1,|L4.844|
0000ce  6008              STR      r0,[r1,#0]
;;;159    	GPIOC->OTYPER  &= ~0x00000032;              
0000d0  1d08              ADDS     r0,r1,#4
0000d2  6800              LDR      r0,[r0,#0]
0000d4  f0200032          BIC      r0,r0,#0x32
0000d8  1d09              ADDS     r1,r1,#4
0000da  6008              STR      r0,[r1,#0]
;;;160    	GPIOC->OSPEEDR |=  0x00000F0C;              
0000dc  1d08              ADDS     r0,r1,#4
0000de  6800              LDR      r0,[r0,#0]
0000e0  f640710c          MOV      r1,#0xf0c
0000e4  4308              ORRS     r0,r0,r1
0000e6  4999              LDR      r1,|L4.844|
0000e8  3108              ADDS     r1,r1,#8
0000ea  6008              STR      r0,[r1,#0]
;;;161    	GPIOC->PUPDR   &= ~0x00000F0C;            
0000ec  1d08              ADDS     r0,r1,#4
0000ee  6800              LDR      r0,[r0,#0]
0000f0  f640710c          MOV      r1,#0xf0c
0000f4  4388              BICS     r0,r0,r1
0000f6  4995              LDR      r1,|L4.844|
0000f8  310c              ADDS     r1,r1,#0xc
0000fa  6008              STR      r0,[r1,#0]
;;;162    	GPIOC->AFR[0]  &= ~0x00FF00F0;
0000fc  4893              LDR      r0,|L4.844|
0000fe  3020              ADDS     r0,r0,#0x20
000100  6800              LDR      r0,[r0,#0]
000102  4993              LDR      r1,|L4.848|
000104  4008              ANDS     r0,r0,r1
000106  4991              LDR      r1,|L4.844|
000108  3120              ADDS     r1,r1,#0x20
00010a  6008              STR      r0,[r1,#0]
;;;163    	GPIOC->AFR[0]  |=  0x00BB00B0;              
00010c  4608              MOV      r0,r1
00010e  6800              LDR      r0,[r0,#0]
000110  4990              LDR      r1,|L4.852|
000112  4308              ORRS     r0,r0,r1
000114  498d              LDR      r1,|L4.844|
000116  3120              ADDS     r1,r1,#0x20
000118  6008              STR      r0,[r1,#0]
;;;164    
;;;165    	/* 配置PG11，PG13和PG14，复用功能，推挽模式，100MHz，无上拉下拉，复用到AF11 (Ethernet) */
;;;166    	GPIOG->MODER   &= ~0x3CC00000;
00011a  488f              LDR      r0,|L4.856|
00011c  6800              LDR      r0,[r0,#0]
00011e  f0205073          BIC      r0,r0,#0x3cc00000
000122  498d              LDR      r1,|L4.856|
000124  6008              STR      r0,[r1,#0]
;;;167    	GPIOG->MODER   |=  0x28800000;             
000126  4608              MOV      r0,r1
000128  6800              LDR      r0,[r0,#0]
00012a  f0405022          ORR      r0,r0,#0x28800000
00012e  6008              STR      r0,[r1,#0]
;;;168    	GPIOG->OTYPER  &= ~0x00006800;             
000130  1d08              ADDS     r0,r1,#4
000132  6800              LDR      r0,[r0,#0]
000134  f42040d0          BIC      r0,r0,#0x6800
000138  1d09              ADDS     r1,r1,#4
00013a  6008              STR      r0,[r1,#0]
;;;169    	GPIOG->OSPEEDR |=  0x3CC00000;           
00013c  1d08              ADDS     r0,r1,#4
00013e  6800              LDR      r0,[r0,#0]
000140  f0405073          ORR      r0,r0,#0x3cc00000
000144  1d09              ADDS     r1,r1,#4
000146  6008              STR      r0,[r1,#0]
;;;170    	GPIOG->PUPDR   &= ~0x3CC00000;            
000148  1d08              ADDS     r0,r1,#4
00014a  6800              LDR      r0,[r0,#0]
00014c  f0205073          BIC      r0,r0,#0x3cc00000
000150  1d09              ADDS     r1,r1,#4
000152  6008              STR      r0,[r1,#0]
;;;171    	GPIOG->AFR[1]  &= ~0x0FF0F000;
000154  4880              LDR      r0,|L4.856|
000156  6a40              LDR      r0,[r0,#0x24]
000158  4980              LDR      r1,|L4.860|
00015a  4008              ANDS     r0,r0,r1
00015c  497e              LDR      r1,|L4.856|
00015e  6248              STR      r0,[r1,#0x24]
;;;172    	GPIOG->AFR[1]  |=  0x0BB0B000;             
000160  4608              MOV      r0,r1
000162  6a40              LDR      r0,[r0,#0x24]
000164  497e              LDR      r1,|L4.864|
000166  4308              ORRS     r0,r0,r1
000168  497b              LDR      r1,|L4.856|
00016a  6248              STR      r0,[r1,#0x24]
;;;173    
;;;174    	/* 
;;;175    	  寄存器ETH->DMABMR的SR位置1后，MAC DMA控制器会复位所有MAC子系统的内部寄存器和逻辑。在所有内
;;;176    	  核时钟域完成复位操作后，该位自动清零。重新编程任何内核寄存器之前，在该位中读取0 值。
;;;177    	*/
;;;178    	ETH->DMABMR  |= DBMR_SR;
00016c  487d              LDR      r0,|L4.868|
00016e  6800              LDR      r0,[r0,#0]
000170  f0400001          ORR      r0,r0,#1
000174  497b              LDR      r1,|L4.868|
000176  6008              STR      r0,[r1,#0]
;;;179    	while (ETH->DMABMR & DBMR_SR);
000178  bf00              NOP      
                  |L4.378|
00017a  487a              LDR      r0,|L4.868|
00017c  6800              LDR      r0,[r0,#0]
00017e  f0100f01          TST      r0,#1
000182  d1fa              BNE      |L4.378|
;;;180    	conn = 0;
000184  2600              MOVS     r6,#0
;;;181    
;;;182    	/* 
;;;183    	   HCLK的时钟是168MHz，这里选项CR位为100，CR占用寄存器ETH->MACMIIAR的bit4，bit3和bit2。
;;;184    	   CR 时钟范围选项可确定 HCLK 频率并用于决定 MDC 时钟频率：
;;;185    	    选项     HCLK        MDC 时钟
;;;186    	    000    60-100MHz     HCLK/42
;;;187    		001    100-150MHz    HCLK/62
;;;188    		010    20-35MHz      HCLK/16
;;;189    		011    35-60MHz      HCLK/26
;;;190    		100    150-168MHz    HCLK/102
;;;191    		101、110、111 保留
;;;192        */
;;;193    	ETH->MACMIIAR = 0x00000010;
000186  2010              MOVS     r0,#0x10
000188  4977              LDR      r1,|L4.872|
00018a  6108              STR      r0,[r1,#0x10]
;;;194    
;;;195    	/*
;;;196    	  注意事项：DM9161可以上电后就读取其ID寄存器，但是DM9162不行，需要延迟一段时间这里为了方便起见，
;;;197    	  直接将其复位，发送复位指令可以立即执行。
;;;198    	*/
;;;199    	/* 第1步：复位DM9161/9162 ***********************************************************/
;;;200    	printf_eth("===============================================================\r\n");
00018c  4877              LDR      r0,|L4.876|
00018e  f7fffffe          BL       __2printf
;;;201    	printf_eth("下面是DM9161/9162的硬件初始化：\r\n");
000192  a077              ADR      r0,|L4.880|
000194  f7fffffe          BL       __2printf
;;;202    	printf_eth("1. Start PHY_ID_DM9161/9162 Init\r\n");
000198  a07e              ADR      r0,|L4.916|
00019a  f7fffffe          BL       __2printf
;;;203    	
;;;204    	/* 发送复位命令 */
;;;205    	write_PHY (PHY_REG_BMCR, 0x8000);
00019e  f44f4100          MOV      r1,#0x8000
0001a2  2000              MOVS     r0,#0
0001a4  f7fffffe          BL       write_PHY
;;;206    
;;;207    	/* 等待复位完成 */
;;;208    	for (tout = 0; tout < 0x10000; tout++) 
0001a8  2500              MOVS     r5,#0
0001aa  e00b              B        |L4.452|
                  |L4.428|
;;;209    	{
;;;210    		regv = read_PHY (PHY_REG_BMCR);
0001ac  2000              MOVS     r0,#0
0001ae  f7fffffe          BL       read_PHY
0001b2  4604              MOV      r4,r0
;;;211    		if (!(regv & 0x8800)) 
0001b4  f4144f08          TST      r4,#0x8800
0001b8  d103              BNE      |L4.450|
;;;212    		{
;;;213    			/* 复位完成 */
;;;214    			printf_eth("2. Reset Complete\r\n");
0001ba  a07f              ADR      r0,|L4.952|
0001bc  f7fffffe          BL       __2printf
;;;215    			break;
0001c0  e003              B        |L4.458|
                  |L4.450|
0001c2  1c6d              ADDS     r5,r5,#1              ;208
                  |L4.452|
0001c4  f5b53f80          CMP      r5,#0x10000           ;208
0001c8  d3f0              BCC      |L4.428|
                  |L4.458|
0001ca  bf00              NOP      
;;;216    		}
;;;217    	}
;;;218    
;;;219    	/* 第2步：配置DM9161/9162 ***********************************************************/
;;;220    #if defined (_10MBIT_)
;;;221    	write_PHY (PHY_REG_BMCR, PHY_FULLD_10M);  /* 连接到10Mbps的网络 */
;;;222    #elif defined (_100MBIT_)
;;;223    	write_PHY (PHY_REG_BMCR, PHY_FULLD_100M); /* 连接到100Mbps的网络 */
;;;224    #else
;;;225    	/* 通过Auto-Negotiation实现自适应10Mbps网络或者100Mbps网络 */
;;;226    	write_PHY (PHY_REG_BMCR, PHY_AUTO_NEG);
0001cc  f44f5180          MOV      r1,#0x1000
0001d0  2000              MOVS     r0,#0
0001d2  f7fffffe          BL       write_PHY
;;;227    	
;;;228    	/* 等待完成Auto-Negotiation */
;;;229    	for (tout = 0; tout < 0x100000; tout++) 
0001d6  2500              MOVS     r5,#0
0001d8  e00b              B        |L4.498|
                  |L4.474|
;;;230    	{
;;;231    		regv = read_PHY (PHY_REG_BMSR);
0001da  2001              MOVS     r0,#1
0001dc  f7fffffe          BL       read_PHY
0001e0  4604              MOV      r4,r0
;;;232    		if (regv & 0x0020) 
0001e2  f0140f20          TST      r4,#0x20
0001e6  d003              BEQ      |L4.496|
;;;233    		{
;;;234    			/* 完成Auto-Negotiation */
;;;235    			printf_eth("3. Auto-Negotiation Complete\r\n");
0001e8  a078              ADR      r0,|L4.972|
0001ea  f7fffffe          BL       __2printf
;;;236    			break;
0001ee  e003              B        |L4.504|
                  |L4.496|
0001f0  1c6d              ADDS     r5,r5,#1              ;229
                  |L4.498|
0001f2  f5b51f80          CMP      r5,#0x100000          ;229
0001f6  d3f0              BCC      |L4.474|
                  |L4.504|
0001f8  bf00              NOP      
;;;237    		}
;;;238    	}
;;;239    #endif
;;;240    	
;;;241    	/* 第3步：检测连接状态 ***********************************************************/
;;;242    	for (tout = 0; tout < 0x10000; tout++) 
0001fa  2500              MOVS     r5,#0
0001fc  e02e              B        |L4.604|
                  |L4.510|
;;;243    	{
;;;244    		regv = read_PHY (PHY_REG_BMSR);
0001fe  2001              MOVS     r0,#1
000200  f7fffffe          BL       read_PHY
000204  4604              MOV      r4,r0
;;;245    		if (regv & (1 << 2)) 
000206  f0140f04          TST      r4,#4
00020a  d020              BEQ      |L4.590|
;;;246    		{
;;;247    			printf_eth("4. Connection Succeeded\r\n");
00020c  a077              ADR      r0,|L4.1004|
00020e  f7fffffe          BL       __2printf
;;;248    			
;;;249    			/* PHY已经连接上网络 */ 
;;;250    			g_ucEthLinkStatus = 1;
000212  2001              MOVS     r0,#1
000214  497c              LDR      r1,|L4.1032|
000216  7008              STRB     r0,[r1,#0]
;;;251    			
;;;252    			/* 获取连接信息 */
;;;253    			regv = read_PHY (PHY_REG_DSCSR);
000218  2011              MOVS     r0,#0x11
00021a  f7fffffe          BL       read_PHY
00021e  4604              MOV      r4,r0
;;;254    			
;;;255    			if ((regv & (1 << 15))|(regv & (1 << 13))) 
000220  f4044000          AND      r0,r4,#0x8000
000224  f4045100          AND      r1,r4,#0x2000
000228  4308              ORRS     r0,r0,r1
00022a  d004              BEQ      |L4.566|
;;;256    			{
;;;257    				/* 全双工 */
;;;258    				printf_eth("5. Full-duplex connection\r\n");
00022c  a077              ADR      r0,|L4.1036|
00022e  f7fffffe          BL       __2printf
;;;259    				conn |= PHY_CON_SET_FULLD;
000232  f0460602          ORR      r6,r6,#2
                  |L4.566|
;;;260    			}
;;;261    			
;;;262    			if ((regv & (1 << 15))|(regv & (1 << 14))) 
000236  f4044000          AND      r0,r4,#0x8000
00023a  f4044180          AND      r1,r4,#0x4000
00023e  4308              ORRS     r0,r0,r1
000240  d004              BEQ      |L4.588|
;;;263    			{
;;;264    				/* 速度100Mbps的网络 */
;;;265    				printf_eth("6. 100Mbps Mode\r\n");
000242  a079              ADR      r0,|L4.1064|
000244  f7fffffe          BL       __2printf
;;;266    				conn |= PHY_CON_SET_100M;
000248  f0460601          ORR      r6,r6,#1
                  |L4.588|
;;;267    			}
;;;268    			break;
00024c  e009              B        |L4.610|
                  |L4.590|
;;;269    		}
;;;270    		else
;;;271    		{
;;;272    			printf_eth("4. Connection failed\r\n");
00024e  a07b              ADR      r0,|L4.1084|
000250  f7fffffe          BL       __2printf
;;;273    			
;;;274    			/* 未连接上 */ 
;;;275    			g_ucEthLinkStatus = 0;
000254  2000              MOVS     r0,#0
000256  496c              LDR      r1,|L4.1032|
000258  7008              STRB     r0,[r1,#0]
00025a  1c6d              ADDS     r5,r5,#1              ;242
                  |L4.604|
00025c  f5b53f80          CMP      r5,#0x10000           ;242
000260  d3cd              BCC      |L4.510|
                  |L4.610|
000262  bf00              NOP                            ;268
;;;276    		}
;;;277    	}
;;;278    
;;;279    	/* 第4步：使能DM9161/9162中断 ***********************************************************/
;;;280    	/* 使能DM9161/9162的连接中断 */
;;;281    	write_PHY (PHY_REG_INTERRUPT, 1<<12);
000264  f44f5180          MOV      r1,#0x1000
000268  2015              MOVS     r0,#0x15
00026a  f7fffffe          BL       write_PHY
;;;282    
;;;283    	/* 配置引脚PH6来接收中断信号 */
;;;284    	Eth_Link_EXTIConfig();
00026e  f7fffffe          BL       Eth_Link_EXTIConfig
;;;285    
;;;286    	/* 第5步：使能DM9161/9162中断 ***********************************************************/	
;;;287    	/* 
;;;288    	   初始化MAC配置寄存器
;;;289    	   （1）当该位MCR_ROD置1时，MAC禁止在半双工模式下接收帧。
;;;290    	   （2）当该位MCR_ROD清0时，MAC接收PHY发送的所有数据包。
;;;291    	   （3）如果MAC在全双工模式下工作，该位不适用。
;;;292    	*/
;;;293    	ETH->MACCR  = MCR_ROD;
000272  f44f5000          MOV      r0,#0x2000
000276  493c              LDR      r1,|L4.872|
000278  6008              STR      r0,[r1,#0]
;;;294    
;;;295    	/* 设置MAC工作在全双工模式 */
;;;296    	if (conn & PHY_CON_SET_FULLD) 
00027a  f0160f02          TST      r6,#2
00027e  d004              BEQ      |L4.650|
;;;297    	{
;;;298    		/* 使能全双工 */
;;;299    		ETH->MACCR |= MCR_DM;
000280  4608              MOV      r0,r1
000282  6800              LDR      r0,[r0,#0]
000284  f4406000          ORR      r0,r0,#0x800
000288  6008              STR      r0,[r1,#0]
                  |L4.650|
;;;300    	}
;;;301    
;;;302    	/* 
;;;303    		通过位MCR_FES配置MAC通信速度
;;;304    		（1）0表示10Mbps
;;;305    		（2）1表示100Mbps
;;;306    	*/
;;;307    	if (conn & PHY_CON_SET_100M) 
00028a  f0160f01          TST      r6,#1
00028e  d005              BEQ      |L4.668|
;;;308    	{
;;;309    		/* 配置为100Mbps */
;;;310    		ETH->MACCR |= MCR_FES;
000290  4835              LDR      r0,|L4.872|
000292  6800              LDR      r0,[r0,#0]
000294  f4404080          ORR      r0,r0,#0x4000
000298  4933              LDR      r1,|L4.872|
00029a  6008              STR      r0,[r1,#0]
                  |L4.668|
;;;311    	}
;;;312    
;;;313    	/* MACFFR 以太网帧过滤寄存器，配置可接收所有MAC组播包，即MAC地址第一个字节的bit0 = 1 */
;;;314    	ETH->MACFFR = MFFR_HPF | MFFR_PAM;
00029c  f44f6082          MOV      r0,#0x410
0002a0  4931              LDR      r1,|L4.872|
0002a2  6048              STR      r0,[r1,#4]
;;;315    	
;;;316    	/* MACFCR 以太网流控制寄存器，ZQPD零时间片暂停禁止 */
;;;317    	ETH->MACFCR = MFCR_ZQPD;
0002a4  2080              MOVS     r0,#0x80
0002a6  6188              STR      r0,[r1,#0x18]
;;;318    
;;;319    	/* 设置以太网MAC地址寄存器 */
;;;320    	ETH->MACA0HR = ((U32)own_hw_adr[5] <<  8) | (U32)own_hw_adr[4];
0002a8  486a              LDR      r0,|L4.1108|
0002aa  7900              LDRB     r0,[r0,#4]  ; own_hw_adr
0002ac  4969              LDR      r1,|L4.1108|
0002ae  7949              LDRB     r1,[r1,#5]  ; own_hw_adr
0002b0  ea402001          ORR      r0,r0,r1,LSL #8
0002b4  492c              LDR      r1,|L4.872|
0002b6  6408              STR      r0,[r1,#0x40]
;;;321    	ETH->MACA0LR = ((U32)own_hw_adr[3] << 24) | (U32)own_hw_adr[2] << 16 |
0002b8  4866              LDR      r0,|L4.1108|
0002ba  78c0              LDRB     r0,[r0,#3]  ; own_hw_adr
0002bc  0600              LSLS     r0,r0,#24
0002be  4965              LDR      r1,|L4.1108|
0002c0  7889              LDRB     r1,[r1,#2]  ; own_hw_adr
0002c2  ea404001          ORR      r0,r0,r1,LSL #16
0002c6  4963              LDR      r1,|L4.1108|
0002c8  7849              LDRB     r1,[r1,#1]  ; own_hw_adr
0002ca  ea402001          ORR      r0,r0,r1,LSL #8
0002ce  4961              LDR      r1,|L4.1108|
0002d0  7809              LDRB     r1,[r1,#0]  ; own_hw_adr
0002d2  4308              ORRS     r0,r0,r1
0002d4  4924              LDR      r1,|L4.872|
0002d6  6448              STR      r0,[r1,#0x44]
;;;322    				   ((U32)own_hw_adr[1] <<  8) | (U32)own_hw_adr[0];
;;;323    
;;;324    	/* 初始化DMA发送和接收描述符 */
;;;325    	rx_descr_init ();
0002d8  f7fffffe          BL       rx_descr_init
;;;326    	tx_descr_init ();
0002dc  f7fffffe          BL       tx_descr_init
;;;327    
;;;328    	/* 
;;;329    	    刷新FIFO，启动DMA发送和接收功能
;;;330    		DMAOMR 工作模式寄存器
;;;331    		位20 DOMR_FTF：刷新发送 FIFO (Flush transmit FIFO)：
;;;332    		               该位置1时，发送FIFO控制器逻辑会复位为默认值，因此，TX FIFO中的所有数据均会
;;;333    			           丢失/刷新。刷新操作结束时该位在内部清零。此位清零之前不得对工作模式寄存器执
;;;334    			           行写操作。
;;;335    		位13 DOMR_ST：启动/停止发送 (Start/stop transmission)
;;;336    		              该位置1时，启动发送，DMA会检查当前位置的发送列表来查找待发送的帧。
;;;337    		位1  DOMR_SR：启动/停止接收 (Start/stop receive)
;;;338    		              该位置1时，启动接收，DMA尝试从接收列表中获取描述符并处理传入帧。
;;;339    	*/
;;;340    	ETH->DMAOMR = DOMR_FTF | DOMR_ST | DOMR_SR;
0002e0  485d              LDR      r0,|L4.1112|
0002e2  4920              LDR      r1,|L4.868|
0002e4  6188              STR      r0,[r1,#0x18]
;;;341    
;;;342    	/* 使能发送和接收 */
;;;343    	ETH->MACCR |= MCR_TE | MCR_RE;
0002e6  4820              LDR      r0,|L4.872|
0002e8  6800              LDR      r0,[r0,#0]
0002ea  f040000c          ORR      r0,r0,#0xc
0002ee  491e              LDR      r1,|L4.872|
0002f0  6008              STR      r0,[r1,#0]
;;;344    
;;;345    	/* 复位所有MAC中断 */
;;;346    	ETH->DMASR  = 0xFFFFFFFF;
0002f2  f04f30ff          MOV      r0,#0xffffffff
0002f6  491b              LDR      r1,|L4.868|
0002f8  6148              STR      r0,[r1,#0x14]
;;;347    
;;;348    	/*  
;;;349    	    使能发送和接收中断
;;;350    		DMAIER 中断使能寄存器
;;;351    		位16 NISE：使能所有正常中断(Normal interrupt summary enable)
;;;352    		位15 AISE：使能所有异常中断(Abnormal interrupt summary enable)
;;;353    		位7 RBUIE：接收缓冲区不可用中断使能(Receive buffer unavailable interrupt enable)
;;;354    		           当该位和AISE位都置1后，可使能接收缓冲区不可用中断。该位清零时，会禁止接
;;;355    				   收缓冲区不可用中断。
;;;356    		位6   RIE：接收中断使能 (Receive interrupt enable)
;;;357    		           当该位和AISE都置1后，可使能接收中断。该位清零时，会禁止接收中断。
;;;358    	*/
;;;359    	ETH->DMAIER = ETH_DMAIER_NISE | ETH_DMAIER_AISE | ETH_DMAIER_RBUIE | ETH_DMAIER_RIE;
0002fa  4858              LDR      r0,|L4.1116|
0002fc  61c8              STR      r0,[r1,#0x1c]
;;;360    
;;;361    	/* 设置为最高优先级，仅调用NVIC->ISER设置的默认优先级也是最高优先级0 */
;;;362    	NVIC_SetPriority(ETH_IRQn, 0);
0002fe  203d              MOVS     r0,#0x3d
000300  2100              MOVS     r1,#0
000302  2800              CMP      r0,#0
000304  da07              BGE      |L4.790|
000306  070a              LSLS     r2,r1,#28
000308  0e17              LSRS     r7,r2,#24
00030a  4a55              LDR      r2,|L4.1120|
00030c  f000030f          AND      r3,r0,#0xf
000310  1f1b              SUBS     r3,r3,#4
000312  54d7              STRB     r7,[r2,r3]
000314  e003              B        |L4.798|
                  |L4.790|
000316  070a              LSLS     r2,r1,#28
000318  0e13              LSRS     r3,r2,#24
00031a  4a52              LDR      r2,|L4.1124|
00031c  5413              STRB     r3,[r2,r0]
                  |L4.798|
00031e  bf00              NOP      
;;;363    	
;;;364    	printf_eth("===============================================================\r\n");
000320  4812              LDR      r0,|L4.876|
000322  f7fffffe          BL       __2printf
;;;365    }
000326  e8bd81f0          POP      {r4-r8,pc}
;;;366    
                          ENDP

00032a  0000              DCW      0x0000
                  |L4.812|
                          DCD      0xe000e180
                  |L4.816|
                          DCD      0x40023844
                  |L4.820|
                          DCD      0x40013804
                  |L4.824|
                          DCD      0x1e000047
                  |L4.828|
                          DCD      0x40020000
                  |L4.832|
                          DCD      0x0003c03c
                  |L4.836|
                          DCD      0x0ffff00f
                  |L4.840|
                          DCD      0xb0000bb0
                  |L4.844|
                          DCD      0x40020800
                  |L4.848|
                          DCD      0xff00ff0f
                  |L4.852|
                          DCD      0x00bb00b0
                  |L4.856|
                          DCD      0x40021800
                  |L4.860|
                          DCD      0xf00f0fff
                  |L4.864|
                          DCD      0x0bb0b000
                  |L4.868|
                          DCD      0x40029000
                  |L4.872|
                          DCD      0x40028000
                  |L4.876|
                          DCD      ||.constdata||
                  |L4.880|
000370  cfc2c3e6          DCB      207,194,195,230,202,199,"DM9161/9162",181,196,211,178,188
000374  cac7444d
000378  39313631
00037c  2f393136
000380  32b5c4d3
000384  b2bc    
000386  feb3f5ca          DCB      254,179,245,202,188,187,175,163,186,"\r\n",0
00038a  bcbbafa3
00038e  ba0d0a00
000392  00                DCB      0
000393  00                DCB      0
                  |L4.916|
000394  312e2053          DCB      "1. Start PHY_ID_DM9161/9162 Init\r\n",0
000398  74617274
00039c  20504859
0003a0  5f49445f
0003a4  444d3931
0003a8  36312f39
0003ac  31363220
0003b0  496e6974
0003b4  0d0a00  
0003b7  00                DCB      0
                  |L4.952|
0003b8  322e2052          DCB      "2. Reset Complete\r\n",0
0003bc  65736574
0003c0  20436f6d
0003c4  706c6574
0003c8  650d0a00
                  |L4.972|
0003cc  332e2041          DCB      "3. Auto-Negotiation Complete\r\n",0
0003d0  75746f2d
0003d4  4e65676f
0003d8  74696174
0003dc  696f6e20
0003e0  436f6d70
0003e4  6c657465
0003e8  0d0a00  
0003eb  00                DCB      0
                  |L4.1004|
0003ec  342e2043          DCB      "4. Connection Succeeded\r\n",0
0003f0  6f6e6e65
0003f4  6374696f
0003f8  6e205375
0003fc  63636565
000400  6465640d
000404  0a00    
000406  00                DCB      0
000407  00                DCB      0
                  |L4.1032|
                          DCD      g_ucEthLinkStatus
                  |L4.1036|
00040c  352e2046          DCB      "5. Full-duplex connection\r\n",0
000410  756c6c2d
000414  6475706c
000418  65782063
00041c  6f6e6e65
000420  6374696f
000424  6e0d0a00
                  |L4.1064|
000428  362e2031          DCB      "6. 100Mbps Mode\r\n",0
00042c  30304d62
000430  7073204d
000434  6f64650d
000438  0a00    
00043a  00                DCB      0
00043b  00                DCB      0
                  |L4.1084|
00043c  342e2043          DCB      "4. Connection failed\r\n",0
000440  6f6e6e65
000444  6374696f
000448  6e206661
00044c  696c6564
000450  0d0a00  
000453  00                DCB      0
                  |L4.1108|
                          DCD      own_hw_adr
                  |L4.1112|
                          DCD      0x00102002
                  |L4.1116|
                          DCD      0x000180c0
                  |L4.1120|
                          DCD      0xe000ed18
                  |L4.1124|
                          DCD      0xe000e400

                          AREA ||i.int_disable_eth||, CODE, READONLY, ALIGN=2

                  int_disable_eth PROC
;;;387    */
;;;388    void int_disable_eth (void) 
000000  f04f5100          MOV      r1,#0x20000000
;;;389    {
;;;390    	NVIC->ICER[1] = 1 << 29;
000004  4801              LDR      r0,|L5.12|
000006  6001              STR      r1,[r0,#0]
;;;391    }
000008  4770              BX       lr
;;;392    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0xe000e184

                          AREA ||i.int_enable_eth||, CODE, READONLY, ALIGN=2

                  int_enable_eth PROC
;;;374    */
;;;375    void int_enable_eth (void) 
000000  f04f5000          MOV      r0,#0x20000000
;;;376    {
;;;377    	NVIC->ISER[1] = 1 << 29;
000004  4901              LDR      r1,|L6.12|
000006  6008              STR      r0,[r1,#0]
;;;378    }
000008  4770              BX       lr
;;;379    
                          ENDP

00000a  0000              DCW      0x0000
                  |L6.12|
                          DCD      0xe000e104

                          AREA ||i.read_PHY||, CODE, READONLY, ALIGN=2

                  read_PHY PROC
;;;721    */
;;;722    static U16 read_PHY (U32 PhyReg) 
000000  4601              MOV      r1,r0
;;;723    {
;;;724    	U32 tout;
;;;725    
;;;726    	/*
;;;727    	   MACMIIAR 以太网MAC MII 地址寄存器
;;;728           位 15:11 PA：PHY 地址 (PHY address)，对应这里的PHY_DEF_ADDR
;;;729    					该字段指示正在访问32个可能的PHY器件中的哪一个。	
;;;730    	   
;;;731    	   位 10:6  MR：MII寄存器 (MII register)，对应这里的PhyReg
;;;732    					这些位在所选的PHY器件中选择要访问的MII寄存器。
;;;733    	   位 1     MW：MII写(MII write)，对应这里的MMAR_MW
;;;734    	                此位置1是在告知PHY，将要启动一个使用MII数据寄存器的写操作。
;;;735    	                如果此位未置，则表示会启动一个读操作，将数据放入MII数据寄存器。
;;;736    	   位 0     MB：MII忙碌 (MII busy)，对应这里的MMAR_MB
;;;737    	                向ETH_MACMIIAR和ETH_MACMIIDR写入前，此位应读取逻辑0。向ETH_MACMIIAR写入过程中，此
;;;738    	                位也必须复位为0。在PHY寄存器访问过程中，此位由应用程序置1，指示读或写访问正在进行中。
;;;739    	                在对PHY进行写操作过程中，ETH_MACMIIDR（MII数据）应始终保持有效，直到MAC将此位清零。
;;;740    	                在对PHY进行读操作过程中，ETH_MACMIIDR始终无效，直到MAC将此位清零。在此位清零后，才
;;;741    					可以向ETH_MACMIIAR（MII地址）写入。
;;;742    	*/
;;;743    	ETH->MACMIIAR = PHY_DEF_ADDR << 11 | PhyReg << 6 | MMAR_MB;
000002  f44f6000          MOV      r0,#0x800
000006  ea401081          ORR      r0,r0,r1,LSL #6
00000a  1c40              ADDS     r0,r0,#1
00000c  4b09              LDR      r3,|L7.52|
00000e  6118              STR      r0,[r3,#0x10]
;;;744    
;;;745    	/* 等待操作完成，即等待MMAR_MB位被清零 */
;;;746    	tout = 0;
000010  2200              MOVS     r2,#0
;;;747    	for (tout = 0; tout < MII_RD_TOUT; tout++) 
000012  bf00              NOP      
000014  e006              B        |L7.36|
                  |L7.22|
;;;748    	{
;;;749    		if ((ETH->MACMIIAR & MMAR_MB) == 0) 
000016  4807              LDR      r0,|L7.52|
000018  6900              LDR      r0,[r0,#0x10]
00001a  f0100f01          TST      r0,#1
00001e  d100              BNE      |L7.34|
;;;750    		{
;;;751    			break;
000020  e003              B        |L7.42|
                  |L7.34|
000022  1c52              ADDS     r2,r2,#1              ;747
                  |L7.36|
000024  f5b22fa0          CMP      r2,#0x50000           ;747
000028  d3f5              BCC      |L7.22|
                  |L7.42|
00002a  bf00              NOP      
;;;752    		}
;;;753    	}
;;;754    	
;;;755    	/* 从 PHY 中读取16bit的数据值 */
;;;756    	return (ETH->MACMIIDR & MMDR_MD);
00002c  4801              LDR      r0,|L7.52|
00002e  6940              LDR      r0,[r0,#0x14]
000030  b280              UXTH     r0,r0
;;;757    }
000032  4770              BX       lr
;;;758    
                          ENDP

                  |L7.52|
                          DCD      0x40028000

                          AREA ||i.rx_descr_init||, CODE, READONLY, ALIGN=2

                  rx_descr_init PROC
;;;574    */
;;;575    static void rx_descr_init (void) 
000000  2200              MOVS     r2,#0
;;;576    {
;;;577    	U32 i,next;
;;;578    
;;;579    	/*
;;;580    	   1. RDES0：接收描述符字0，对应Rx_Desc[i].Stat
;;;581    	      位31 OWN：所有关系位 (Own bit)
;;;582    					该位置1时，指示描述符由MAC子系统的DMA所拥有。
;;;583    	                该位清零时，指示描述符由主机所拥有，即CPU。
;;;584    	                DMA在帧接收完成或此描述符的关联缓冲区已满时将该位清零。
;;;585    	
;;;586    	   2. RDES1：接收描述符字1，对应Rx_Desc[i].Ctrl
;;;587    	      位14   RCH： 链接的第二个地址 (Second address chained)
;;;588    					   该位置1时，表示描述符中的第二个地址是下一个描述符地址，而非第二个缓冲区地址。该
;;;589                           位置1时，RBS2(RDES1[28:16])为无关值。RDES1[15]比RDES1[14]优先处理。
;;;590    	      位12:0 RBS1：接收缓冲区1大小 (Receive buffer 1 size)
;;;591                           第一个数据缓冲区的大小以字节为单位。即使RDES2（缓冲区1地址指针）的值未对齐，缓
;;;592    	                   冲区大小也必须为4、8或16的倍数，具体取决于总线宽度32、64或128。如果缓冲区大小不
;;;593    	                   是4、8或16的倍数，这种情况的结果是未定义。如果该字段为0，则DMA会忽略该缓冲区并
;;;594    	                   使用缓冲区2或下一个描述符，具体取决于RCH（位14）的值。
;;;595    	
;;;596    	   3. RDES2：接收描述符字2，对应Rx_Desc[i].Addr
;;;597    	      位31:0 RBAP1/RTSL：接收缓冲区1地址指针/接收帧时间戳低位
;;;598    		                     Receive buffer 1 address pointer
;;;599                                 Receive frame time stamp low
;;;600    	
;;;601    	   4. RDES3：接收描述符字3，对应Rx_Desc[i].Next
;;;602    	      位31:0 RBAP2/RTSH：接收缓冲区2地址指针（下一个描述符地址）/ 接收帧时间戳高位
;;;603    		                     Receive buffer 2 address pointer (next descriptor address) 
;;;604    		                     Receive frame time stamp high
;;;605    	*/
;;;606    	RxBufIndex = 0;
000002  4b16              LDR      r3,|L8.92|
000004  701a              STRB     r2,[r3,#0]
;;;607    	
;;;608    	for (i = 0, next = 0; i < NUM_RX_BUF; i++) 
000006  2000              MOVS     r0,#0
000008  2100              MOVS     r1,#0
00000a  e021              B        |L8.80|
                  |L8.12|
;;;609    	{
;;;610    		if (++next == NUM_RX_BUF) next = 0;
00000c  1c4a              ADDS     r2,r1,#1
00000e  4611              MOV      r1,r2
000010  2a04              CMP      r2,#4
000012  d100              BNE      |L8.22|
000014  2100              MOVS     r1,#0
                  |L8.22|
;;;611    		Rx_Desc[i].Stat = DMA_RX_OWN;
000016  f04f4200          MOV      r2,#0x80000000
00001a  4b11              LDR      r3,|L8.96|
00001c  eb031300          ADD      r3,r3,r0,LSL #4
000020  601a              STR      r2,[r3,#0]
;;;612    		Rx_Desc[i].Ctrl = DMA_RX_RCH | ETH_BUF_SIZE;
000022  f44f428c          MOV      r2,#0x4600
000026  4b0e              LDR      r3,|L8.96|
000028  eb031300          ADD      r3,r3,r0,LSL #4
00002c  605a              STR      r2,[r3,#4]
;;;613    		Rx_Desc[i].Addr = (U32)&rx_buf[i];
00002e  eb000240          ADD      r2,r0,r0,LSL #1
000032  4b0c              LDR      r3,|L8.100|
000034  eb032242          ADD      r2,r3,r2,LSL #9
000038  4b09              LDR      r3,|L8.96|
00003a  eb031300          ADD      r3,r3,r0,LSL #4
00003e  609a              STR      r2,[r3,#8]
;;;614    		Rx_Desc[i].Next = (U32)&Rx_Desc[next];
000040  4a07              LDR      r2,|L8.96|
000042  eb021201          ADD      r2,r2,r1,LSL #4
000046  4b06              LDR      r3,|L8.96|
000048  eb031300          ADD      r3,r3,r0,LSL #4
00004c  60da              STR      r2,[r3,#0xc]
00004e  1c40              ADDS     r0,r0,#1              ;608
                  |L8.80|
000050  2804              CMP      r0,#4                 ;608
000052  d3db              BCC      |L8.12|
;;;615    	}
;;;616    	
;;;617    	/* 接收描述符列表地址寄存器指向接收描述符列表的起始处 */
;;;618    	ETH->DMARDLAR = (U32)&Rx_Desc[0];
000054  4a02              LDR      r2,|L8.96|
000056  4b04              LDR      r3,|L8.104|
000058  60da              STR      r2,[r3,#0xc]
;;;619    }
00005a  4770              BX       lr
;;;620    
                          ENDP

                  |L8.92|
                          DCD      RxBufIndex
                  |L8.96|
                          DCD      Rx_Desc
                  |L8.100|
                          DCD      rx_buf
                  |L8.104|
                          DCD      0x40029000

                          AREA ||i.send_frame||, CODE, READONLY, ALIGN=2

                  send_frame PROC
;;;400    */
;;;401    void send_frame (OS_FRAME *frame) 
000000  b570              PUSH     {r4-r6,lr}
;;;402    {
000002  4601              MOV      r1,r0
;;;403    	U32 *sp,*dp;
;;;404    	U32 i,j;
;;;405    
;;;406    	j = TxBufIndex;
000004  4d1a              LDR      r5,|L9.112|
000006  7828              LDRB     r0,[r5,#0]  ; TxBufIndex
;;;407    	
;;;408    	/* 等待上一帧数据发送完成 */
;;;409    	while (Tx_Desc[j].CtrlStat & DMA_TX_OWN);
000008  bf00              NOP      
                  |L9.10|
00000a  4d1a              LDR      r5,|L9.116|
00000c  eb051500          ADD      r5,r5,r0,LSL #4
000010  682d              LDR      r5,[r5,#0]
000012  f0154f00          TST      r5,#0x80000000
000016  d1f8              BNE      |L9.10|
;;;410    
;;;411    	sp = (U32 *)&frame->data[0];
000018  1d0a              ADDS     r2,r1,#4
;;;412    	dp = (U32 *)(Tx_Desc[j].Addr & ~3);
00001a  4d16              LDR      r5,|L9.116|
00001c  eb051500          ADD      r5,r5,r0,LSL #4
000020  68ad              LDR      r5,[r5,#8]
000022  f0250303          BIC      r3,r5,#3
;;;413    
;;;414    	/* 复制要发送的数据到DMA发送描述符中 */
;;;415    	for (i = (frame->length + 3) >> 2; i; i--) 
000026  880d              LDRH     r5,[r1,#0]
000028  1ced              ADDS     r5,r5,#3
00002a  10ac              ASRS     r4,r5,#2
00002c  e002              B        |L9.52|
                  |L9.46|
;;;416    	{
;;;417    		*dp++ = *sp++;
00002e  ca20              LDM      r2!,{r5}
000030  c320              STM      r3!,{r5}
000032  1e64              SUBS     r4,r4,#1              ;415
                  |L9.52|
000034  2c00              CMP      r4,#0                 ;415
000036  d1fa              BNE      |L9.46|
;;;418    	}
;;;419    	
;;;420    	/* 设置数据帧大小 */
;;;421    	Tx_Desc[j].Size      = frame->length;
000038  880d              LDRH     r5,[r1,#0]
00003a  4e0e              LDR      r6,|L9.116|
00003c  eb061600          ADD      r6,r6,r0,LSL #4
000040  6075              STR      r5,[r6,#4]
;;;422    	
;;;423    	/* 发送描述符由DMA控制发送 */
;;;424    	Tx_Desc[j].CtrlStat |= DMA_TX_OWN;
000042  4d0c              LDR      r5,|L9.116|
000044  eb051500          ADD      r5,r5,r0,LSL #4
000048  682d              LDR      r5,[r5,#0]
00004a  f0454500          ORR      r5,r5,#0x80000000
00004e  4e09              LDR      r6,|L9.116|
000050  eb061600          ADD      r6,r6,r0,LSL #4
000054  6035              STR      r5,[r6,#0]
;;;425    	
;;;426    	if (++j == NUM_TX_BUF) j = 0;
000056  1c45              ADDS     r5,r0,#1
000058  4628              MOV      r0,r5
00005a  2d02              CMP      r5,#2
00005c  d100              BNE      |L9.96|
00005e  2000              MOVS     r0,#0
                  |L9.96|
;;;427    	TxBufIndex = j;
000060  4e03              LDR      r6,|L9.112|
000062  7030              STRB     r0,[r6,#0]
;;;428    	
;;;429    	/* 开始帧传输 */
;;;430    	/* 
;;;431    	   DMASR 以太网 DMA 状态寄存器
;;;432    	   向ETH_DMASR寄存器[16:0]中的（未保留）位写入1会将其清零，写入 0 则不起作用。
;;;433    	   位1 TPSS：发送过程停止状态 (Transmit process stopped status)
;;;434                     当发送停止时，此位置 1。
;;;435    	*/
;;;436    	ETH->DMASR   = DSR_TPSS;
000064  2502              MOVS     r5,#2
000066  4e04              LDR      r6,|L9.120|
000068  6175              STR      r5,[r6,#0x14]
;;;437    	
;;;438    	/*
;;;439    	   DMATPDR 以太网DMA发送轮询请求寄存器
;;;440           应用程序使用此寄存器来指示DMA轮询发送描述符列表。
;;;441           位 31:0 TPD：发送轮询请求(Transmit poll demand)
;;;442                        向这些位写入任何值时，DMA都会读取ETH_DMACHTDR寄存器指向的当前描述符。如果
;;;443                        该描述符不可用（由CPU所有），则发送会返回到挂起状态，并将ETH_DMASR寄存器位2
;;;444                        进行置位。如果该描述符可用，则发送会继续进行。	   
;;;445    	*/
;;;446    	ETH->DMATPDR = 0;
00006a  2500              MOVS     r5,#0
00006c  6075              STR      r5,[r6,#4]
;;;447    }
00006e  bd70              POP      {r4-r6,pc}
;;;448    
                          ENDP

                  |L9.112|
                          DCD      TxBufIndex
                  |L9.116|
                          DCD      Tx_Desc
                  |L9.120|
                          DCD      0x40029000

                          AREA ||i.tx_descr_init||, CODE, READONLY, ALIGN=2

                  tx_descr_init PROC
;;;628    */
;;;629    static void tx_descr_init (void) 
000000  2200              MOVS     r2,#0
;;;630    {
;;;631    	U32 i,next;
;;;632    
;;;633    	/*
;;;634    	   1. TDES0：发送描述符字0，对应Tx_Desc[i].CtrlStat
;;;635    	      位29 LS ：末段 (Last segment)
;;;636                        该位置1时，指示缓冲区中包含帧的末段。
;;;637    	      位28 FS ：首段 (First segment)
;;;638                        该位置1时，指示缓冲区中包含帧的首段
;;;639              位20 TCH：链接的第二个地址 (Second address chained)
;;;640                        该位置1时，表示描述符中的第二个地址是下一个描述符地址，而非第二个缓冲区地址。
;;;641                        TDES0[20]置1时，TBS2(TDES1[28:16])为无关值。TDES0[21]比TDES0[20]优先处理。
;;;642    	
;;;643    	   2. TDES1：发送描述符字1，对应Tx_Desc[i].Size
;;;644    	
;;;645    	   3. TDES2：发送描述符字2，对应Tx_Desc[i].Addr
;;;646    	      位31:0 TBAP1：发送缓冲区1地址指针/发送帧时间戳低位 
;;;647    	                    Transmit buffer 1 address pointer / Transmitframe time stamp low
;;;648    	
;;;649    	   4. TDES3：发送描述符字3，对应Tx_Desc[i].Next
;;;650    	      位 1:0 TBAP2：发送缓冲区2地址指针（下一个描述符地址）/ 发送帧时间戳高位
;;;651         		            Transmit buffer 2 address pointer (Next descriptor address) 
;;;652    						Transmit frame time stamp high
;;;653    	*/
;;;654    	TxBufIndex = 0;
000002  4b13              LDR      r3,|L10.80|
000004  701a              STRB     r2,[r3,#0]
;;;655    	for (i = 0, next = 0; i < NUM_TX_BUF; i++) 
000006  2000              MOVS     r0,#0
000008  2100              MOVS     r1,#0
00000a  e01a              B        |L10.66|
                  |L10.12|
;;;656    	{
;;;657    		if (++next == NUM_TX_BUF) next = 0;
00000c  1c4a              ADDS     r2,r1,#1
00000e  4611              MOV      r1,r2
000010  2a02              CMP      r2,#2
000012  d100              BNE      |L10.22|
000014  2100              MOVS     r1,#0
                  |L10.22|
;;;658    		Tx_Desc[i].CtrlStat = DMA_TX_TCH | DMA_TX_LS | DMA_TX_FS;
000016  4a0f              LDR      r2,|L10.84|
000018  4b0f              LDR      r3,|L10.88|
00001a  eb031300          ADD      r3,r3,r0,LSL #4
00001e  601a              STR      r2,[r3,#0]
;;;659    		Tx_Desc[i].Addr     = (U32)&tx_buf[i];
000020  eb000240          ADD      r2,r0,r0,LSL #1
000024  4b0d              LDR      r3,|L10.92|
000026  eb032242          ADD      r2,r3,r2,LSL #9
00002a  4b0b              LDR      r3,|L10.88|
00002c  eb031300          ADD      r3,r3,r0,LSL #4
000030  609a              STR      r2,[r3,#8]
;;;660    		Tx_Desc[i].Next     = (U32)&Tx_Desc[next];
000032  4a09              LDR      r2,|L10.88|
000034  eb021201          ADD      r2,r2,r1,LSL #4
000038  4b07              LDR      r3,|L10.88|
00003a  eb031300          ADD      r3,r3,r0,LSL #4
00003e  60da              STR      r2,[r3,#0xc]
000040  1c40              ADDS     r0,r0,#1              ;655
                  |L10.66|
000042  2802              CMP      r0,#2                 ;655
000044  d3e2              BCC      |L10.12|
;;;661    	}
;;;662    	
;;;663    	/* 发送描述符列表地址寄存器指向发送描述符列表的起始处 */
;;;664    	ETH->DMATDLAR = (U32)&Tx_Desc[0];
000046  4a04              LDR      r2,|L10.88|
000048  4b05              LDR      r3,|L10.96|
00004a  611a              STR      r2,[r3,#0x10]
;;;665    }
00004c  4770              BX       lr
;;;666    
                          ENDP

00004e  0000              DCW      0x0000
                  |L10.80|
                          DCD      TxBufIndex
                  |L10.84|
                          DCD      0x30100000
                  |L10.88|
                          DCD      Tx_Desc
                  |L10.92|
                          DCD      tx_buf
                  |L10.96|
                          DCD      0x40029000

                          AREA ||i.write_PHY||, CODE, READONLY, ALIGN=2

                  write_PHY PROC
;;;676    */
;;;677    static void write_PHY (U32 PhyReg, U16 Value)
000000  b510              PUSH     {r4,lr}
;;;678    {
;;;679    	U32 tout;
;;;680    
;;;681    	/* 数据寄存器，存入要写入PHY的16位数据 */
;;;682    	ETH->MACMIIDR = Value;
000002  4b0b              LDR      r3,|L11.48|
000004  6159              STR      r1,[r3,#0x14]
;;;683    
;;;684    	/*
;;;685    	   MACMIIAR 以太网MAC MII 地址寄存器
;;;686           位 15:11 PA：PHY 地址 (PHY address)，对应这里的PHY_DEF_ADDR
;;;687    					该字段指示正在访问32个可能的PHY器件中的哪一个。	
;;;688    	   
;;;689    	   位 10:6  MR：MII寄存器 (MII register)，对应这里的PhyReg
;;;690    					这些位在所选的PHY器件中选择要访问的MII寄存器。
;;;691    	   位 1     MW：MII写(MII write)，对应这里的MMAR_MW
;;;692    	                此位置1是在告知PHY，将要启动一个使用MII数据寄存器的写操作。
;;;693    	                如果此位未置，则表示会启动一个读操作，将数据放入MII数据寄存器。
;;;694    	   位 0     MB：MII忙碌 (MII busy)，对应这里的MMAR_MB
;;;695    	                向ETH_MACMIIAR和ETH_MACMIIDR写入前，此位应读取逻辑0。向ETH_MACMIIAR写入过程中，此
;;;696    	                位也必须复位为0。在PHY寄存器访问过程中，此位由应用程序置1，指示读或写访问正在进行中。
;;;697    	                在对PHY进行写操作过程中，ETH_MACMIIDR（MII数据）应始终保持有效，直到MAC将此位清零。
;;;698    	                在对PHY进行读操作过程中，ETH_MACMIIDR始终无效，直到MAC将此位清零。在此位清零后，才
;;;699    					可以向ETH_MACMIIAR（MII地址）写入。
;;;700    	*/
;;;701    	ETH->MACMIIAR = PHY_DEF_ADDR << 11 | PhyReg << 6 | MMAR_MW | MMAR_MB;
000006  14db              ASRS     r3,r3,#19
000008  ea431380          ORR      r3,r3,r0,LSL #6
00000c  1cdb              ADDS     r3,r3,#3
00000e  4c08              LDR      r4,|L11.48|
000010  6123              STR      r3,[r4,#0x10]
;;;702    
;;;703    	/* 等待操作完成，即等待MMAR_MB位被清零 */
;;;704    	tout = 0;
000012  2200              MOVS     r2,#0
;;;705    	for (tout = 0; tout < MII_WR_TOUT; tout++) 
000014  bf00              NOP      
000016  e006              B        |L11.38|
                  |L11.24|
;;;706    	{
;;;707    		if ((ETH->MACMIIAR & MMAR_MB) == 0) 
000018  4b05              LDR      r3,|L11.48|
00001a  691b              LDR      r3,[r3,#0x10]
00001c  f0130f01          TST      r3,#1
000020  d100              BNE      |L11.36|
;;;708    		{
;;;709    			break;
000022  e003              B        |L11.44|
                  |L11.36|
000024  1c52              ADDS     r2,r2,#1              ;705
                  |L11.38|
000026  f5b22fa0          CMP      r2,#0x50000           ;705
00002a  d3f5              BCC      |L11.24|
                  |L11.44|
00002c  bf00              NOP      
;;;710    		}
;;;711    	}
;;;712    }
00002e  bd10              POP      {r4,pc}
;;;713    
                          ENDP

                  |L11.48|
                          DCD      0x40028000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Rx_Desc
                          %        64
                  Tx_Desc
                          %        32
                  rx_buf
                          %        6144
                  tx_buf
                          %        3072

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000004  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000008  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00000c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000010  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000014  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000018  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00001c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000020  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000024  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000028  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00002c  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000030  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000034  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
000038  3d3d3d3d          DCB      0x3d,0x3d,0x3d,0x3d
00003c  3d3d3d0d          DCB      0x3d,0x3d,0x3d,0x0d
000040  0a000000          DCB      0x0a,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=0

                  g_ucEthLinkStatus
000000  00                DCB      0x00
                  TxBufIndex
000001  00                DCB      0x00
                  RxBufIndex
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\RL-ARM\\Driver\\ETH_STM32F4xx.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_ETH_STM32F4xx_c_814deff3____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_ETH_STM32F4xx_c_814deff3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_ETH_STM32F4xx_c_814deff3____REVSH|
#line 144
|__asm___15_ETH_STM32F4xx_c_814deff3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_ETH_STM32F4xx_c_814deff3____RRX|
#line 300
|__asm___15_ETH_STM32F4xx_c_814deff3____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
