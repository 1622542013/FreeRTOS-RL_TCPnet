L 1 "..\..\RL-ARM\Config\Net_Config.c"
N/*----------------------------------------------------------------------------
N *      RL-ARM - TCPnet
N *----------------------------------------------------------------------------
N *      Name:    NET_CONFIG.C
N *      Purpose: Configuration of RL TCPnet by user
N *      Rev.:    V4.72
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#include <Net_Config.h>
L 1 "..\..\RL-ARM\Config\Net_Config.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - TCPnet
N *----------------------------------------------------------------------------
N *      Name:    NET_CONFIG.H
N *      Purpose: Common TCPnet Definitions
N *      Rev.:    V4.73
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __NET_CONFIG_H__
N#define __NET_CONFIG_H__
N
N#include <RTL.h>
L 1 "..\..\RL-ARM\RL-RTX\inc\RTL.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - A P I 
N *----------------------------------------------------------------------------
N *      Name:    RTL.H 
N *      Purpose: Application Programming Interface 
N *      Rev.:    V4.73
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __RTL_H__
N#define __RTL_H__
N
N/* RL-ARM version number. */
N#define __RL_ARM_VER    473
N 
N#define __task          __declspec(noreturn)
N#define __used          __attribute__((used))
N
N#ifndef NULL
N #ifdef __cplusplus
S  #define NULL          0
N #else
N  #define NULL          ((void *) 0)
N #endif
N#endif
N
N#ifndef EOF
N #define EOF            (-1)
N#endif
N
N#ifndef __size_t
N #define __size_t       1
N typedef unsigned int   size_t;
N#endif
N
Ntypedef signed char     S8;
Ntypedef unsigned char   U8;
Ntypedef short           S16;
Ntypedef unsigned short  U16;
Ntypedef int             S32;
Ntypedef unsigned int    U32;
Ntypedef long long       S64;
Ntypedef unsigned long long U64;
Ntypedef unsigned char   BIT;
Ntypedef unsigned int    BOOL;
N
N#ifndef __TRUE
N #define __TRUE         1
N#endif
N#ifndef __FALSE
N #define __FALSE        0
N#endif
N
N#ifdef __BIG_ENDIAN
S #define U32_LE(v)      (U32)(__rev(v))
S #define U16_LE(v)      (U16)(__rev(v) >> 16)
S #define U32_BE(v)      (U32)(v)
S #define U16_BE(v)      (U16)(v)
N#else
N #define U32_BE(v)      (U32)(__rev(v))
N #define U16_BE(v)      (U16)(__rev(v) >> 16)
N #define U32_LE(v)      (U32)(v)
N #define U16_LE(v)      (U16)(v)
N#endif
N#define ntohs(v)        U16_BE(v)
N#define ntohl(v)        U32_BE(v)
N#define htons(v)        ntohs(v)
N#define htonl(v)        ntohl(v)
N
N/*----------------------------------------------------------------------------
N *                             RTX Kernel API
N *---------------------------------------------------------------------------*/
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N/*----------------------------------------------------------------------------
N *                        Flash File System API
N *---------------------------------------------------------------------------*/
N
N/* File System Type */
Ntypedef enum _FS_TYPE {
N  FS_TYPE_NONE = 0,                     /* No file system (volume unformatted)*/
N  FS_TYPE_UNKNOWN,                      /* File system type is unknown       */
N  FS_TYPE_FAT12,                        /* File system type is FAT12         */
N  FS_TYPE_FAT16,                        /* File system type is FAT16         */
N  FS_TYPE_FAT32,                        /* File system type is FAT32         */
N  FS_TYPE_EFS                           /* File system type is EFS           */
N} FS_TYPE;
N
Ntypedef struct {                        /* RL Time format (FFS, TCPnet)      */
N  U8  hr;                               /* Hours    [0..23]                  */
N  U8  min;                              /* Minutes  [0..59]                  */
N  U8  sec;                              /* Seconds  [0..59]                  */
N  U8  day;                              /* Day      [1..31]                  */
N  U8  mon;                              /* Month    [1..12]                  */
N  U16 year;                             /* Year     [1980..2107]             */
N} RL_TIME;
N
Ntypedef struct {                        /* Search info record                */
N  S8  name[256];                        /* Name                              */
N  U32 size;                             /* File size in bytes                */
N  U16 fileID;                           /* System Identification             */
N  U8  attrib;                           /* Attributes                        */
N  RL_TIME time;                         /* Create/Modify Time                */
N} FINFO;
N
N/* Drive information */
Ntypedef struct {
N  FS_TYPE fs_type;                      /* Drives file system type           */
N  U64     capacity;                     /* Drives capacity in bytes          */
N} Drive_INFO;
N
Nextern int finit (const char *drive);
Nextern int funinit (const char *drive);
Nextern int fdelete (const char *filename);
Nextern int frename (const char *oldname, const char *newname);
Nextern int ffind (const char *pattern, FINFO *info);
Nextern U64 ffree (const char *drive);
Nextern int fformat (const char *drive);
Nextern int fanalyse (const char *drive);
Nextern int fcheck (const char *drive);
Nextern int fdefrag (const char *drive);
Nextern int fattrib (const char *par, const char *path);
Nextern int fvol    (const char *drive, char *buf);
Nextern int finfo   (const char *drive, Drive_INFO *info);
N
N/* The following macros provide for common functions */
N#define unlink(fn)      fdelete(fn);
N
N/*----------------------------------------------------------------------------
N *                             TCPnet API
N *---------------------------------------------------------------------------*/
N
N/* UDP Options */
N#define UDP_OPT_SEND_CS    0x01   /* Calculate Checksum for UDP send frames  */
N#define UDP_OPT_CHK_CS     0x02   /* Verify Checksum for received UDP frames */
N
N/* TCP Socket Types */
N#define TCP_TYPE_SERVER    0x01   /* Socket Type Server (open for listening) */
N#define TCP_TYPE_CLIENT    0x02   /* Socket Type Client (initiate connect)   */
N#define TCP_TYPE_DELAY_ACK 0x04   /* Socket Type Delayed Acknowledge         */
N#define TCP_TYPE_FLOW_CTRL 0x08   /* Socket Type Flow Control                */
N#define TCP_TYPE_KEEP_ALIVE 0x10  /* Socket Type Keep Alive                  */
N#define TCP_TYPE_CLIENT_SERVER (TCP_TYPE_SERVER | TCP_TYPE_CLIENT)
N
N/* TCP Callback Events */
N#define TCP_EVT_CONREQ     0      /* Connect request received event          */
N#define TCP_EVT_CONNECT    1      /* Connection established event            */
N#define TCP_EVT_CLOSE      2      /* Connection was properly closed          */
N#define TCP_EVT_ABORT      3      /* Connection is for some reason aborted   */
N#define TCP_EVT_ACK        4      /* Previously send data acknowledged       */
N#define TCP_EVT_DATA       5      /* Data received event                     */
N
N/* TCP States */
N#define TCP_STATE_FREE     0      /* Entry is free and unused                */
N#define TCP_STATE_CLOSED   1      /* Entry allocated, socket still closed    */
N#define TCP_STATE_LISTEN   2      /* Socket waiting for incoming connection  */
N#define TCP_STATE_SYN_REC  3      /* SYN frame received                      */
N#define TCP_STATE_SYN_SENT 4      /* SYN packet sent to establish a connect. */
N#define TCP_STATE_FINW1    5      /* Tcp_close started FIN packet was sent   */
N#define TCP_STATE_FINW2    6      /* Our FIN ack-ed, waiting for remote FIN  */
N#define TCP_STATE_CLOSING  7      /* Received FIN independently of our FIN   */
N#define TCP_STATE_LAST_ACK 8      /* Waiting for last ACK for our FIN        */
N#define TCP_STATE_TWAIT    9      /* Timed waiting for 2MSL                  */
N#define TCP_STATE_CONNECT  10     /* TCP Connection established              */
N
N/* BSD Socket Address Family */
N#define AF_UNSPEC          0      /* Unspecified                             */
N#define AF_INET            1      /* Internet Address Family (UDP, TCP)      */
N#define AF_NETBIOS         2      /* NetBios-style addresses                 */
N
N/* BSD Protocol families, same as address families */
N#define PF_UNSPEC          AF_UNSPEC
N#define PF_INET            AF_INET
N#define PF_NETBIOS         AF_NETBIOS
N
N/* BSD Socket Type */
N#define SOCK_STREAM        1      /* Stream Socket (Connection oriented)     */
N#define SOCK_DGRAM         2      /* Datagram Socket (Connectionless)        */
N
N/* BSD Socket Protocol */
N#define IPPROTO_TCP        1      /* TCP Protocol                            */
N#define IPPROTO_UDP        2      /* UDP Protocol                            */
N
N/* BSD Internet Addresses */
N#define INADDR_ANY     0x00000000 /* All IP addresses accepted               */
N#define INADDR_NONE    0xffffffff /* No IP address accepted                  */
N
N/* BSD Socket Return values */
N#define SCK_SUCCESS         0     /* Success                                 */
N#define SCK_ERROR         (-1)    /* General Error                           */
N#define SCK_EINVALID      (-2)    /* Invalid socket descriptor               */
N#define SCK_EINVALIDPARA  (-3)    /* Invalid parameter                       */
N#define SCK_EWOULDBLOCK   (-4)    /* It would have blocked.                  */
N#define SCK_EMEMNOTAVAIL  (-5)    /* Not enough memory in memory pool        */
N#define SCK_ECLOSED       (-6)    /* Connection is closed or aborted         */
N#define SCK_ELOCKED       (-7)    /* Socket is locked in RTX environment     */
N#define SCK_ETIMEOUT      (-8)    /* Socket, Host Resolver timeout           */
N#define SCK_EINPROGRESS   (-9)    /* Host Name resolving in progress         */
N#define SCK_ENONAME       (-10)   /* Host Name not existing                  */
N
N/* BSD Socket flags parameter */
N#define MSG_DONTWAIT       0x01   /* Enables non-blocking operation          */
N#define MSG_PEEK           0x02   /* Peeks at the incoming data              */
N
N/* BSD Socket ioctl commands */
N#define FIONBIO            1      /* Set mode (blocking/non-blocking)        */
N#define FIO_DELAY_ACK      2      /* Set DELAY_ACK mode for stream socket    */
N#define FIO_KEEP_ALIVE     3      /* Set KEEP_ALIVE mode for stream socket   */
N#define FIO_FLOW_CTRL      4      /* Set FLOW_CTRL mode for stream socket    */
N
N/* ICMP (ping) Callback Events */
N#define ICMP_EVT_SUCCESS   0      /* Pinged Host responded                   */
N#define ICMP_EVT_TIMEOUT   1      /* Timeout, no ping response received      */
N
N/* DNS Client Callback Events */
N#define DNS_EVT_SUCCESS    0      /* Host name successfully resolved         */
N#define DNS_EVT_NONAME     1      /* DNS Error, no such name                 */
N#define DNS_EVT_TIMEOUT    2      /* Timeout resolving host                  */
N#define DNS_EVT_ERROR      3      /* Erroneous response packet               */
N
N/* DNS 'get_host_by_name()' result codes */
N#define DNS_RES_OK         0      /* Resolver successfully started           */
N#define DNS_ERROR_BUSY     1      /* Resolver busy, can't process request    */
N#define DNS_ERROR_LABEL    2      /* Label in Hostname not valid             */
N#define DNS_ERROR_NAME     3      /* Entire Hostname not valid               */
N#define DNS_ERROR_NOSRV    4      /* Prim. DNS server not specified (0.0.0.0)*/
N#define DNS_ERROR_PARAM    5      /* Invalid parameter                       */
N
N/* SMTP Client Callback Events */
N#define SMTP_EVT_SUCCESS   0      /* Email successfully sent                 */
N#define SMTP_EVT_TIMEOUT   1      /* Timeout sending email                   */
N#define SMTP_EVT_ERROR     2      /* Error when sending email                */
N
N/* FTP Client Commands */
N#define FTPC_CMD_PUT       0      /* Puts a file on FTP server               */
N#define FTPC_CMD_GET       1      /* Retrieves a file from FTP server        */
N#define FTPC_CMD_APPEND    2      /* Append file on FTP server (with create) */
N#define FTPC_CMD_DELETE    3      /* Deletes a file on FTP server            */
N#define FTPC_CMD_LIST      4      /* Lists files stored on FTP server        */
N#define FTPC_CMD_RENAME    5      /* Renames a file on FTP server            */
N#define FTPC_CMD_MKDIR     6      /* Makes a directory on FTP server         */
N#define FTPC_CMD_RMDIR     7      /* Removes an empty directory on FTP server*/
N#define FTPC_CMD_NLIST     8      /* Lists file names only (short format)    */
N
N/* FTP Client Callback Events */
N#define FTPC_EVT_SUCCESS   0      /* File operation successful               */
N#define FTPC_EVT_TIMEOUT   1      /* Timeout on file operation               */
N#define FTPC_EVT_LOGINFAIL 2      /* Login error, username/passw invalid     */
N#define FTPC_EVT_NOACCESS  3      /* File access not allowed                 */
N#define FTPC_EVT_NOTFOUND  4      /* File not found                          */
N#define FTPC_EVT_NOPATH    5      /* Working directory path not found        */
N#define FTPC_EVT_ERRLOCAL  6      /* Local file open error                   */
N#define FTPC_EVT_ERROR     7      /* Generic FTP client error                */
N
N/* TFTP Client Callback Events */
N#define TFTPC_EVT_SUCCESS  0      /* File operation successful               */
N#define TFTPC_EVT_TIMEOUT  1      /* Timeout on file operation               */
N#define TFTPC_EVT_NOACCESS 2      /* File access not allowed                 */
N#define TFTPC_EVT_NOTFOUND 3      /* File not found                          */
N#define TFTPC_EVT_DISKFULL 4      /* Disk full (local or remote)             */
N#define TFTPC_EVT_ERROR    5      /* Generic TFTP client error               */
N
N/* FTP Server Notification events */
N#define FTP_EVT_LOGIN      0      /* User logged in, session is busy         */
N#define FTP_EVT_LOGOUT     1      /* User logged out, session is idle        */
N#define FTP_EVT_LOGFAIL    2      /* User login failed (invalid credentials) */
N#define FTP_EVT_DOWNLOAD   3      /* File download ended                     */
N#define FTP_EVT_UPLOAD     4      /* File upload ended                       */
N#define FTP_EVT_DELETE     5      /* File deleted                            */
N#define FTP_EVT_RENAME     6      /* File or directory renamed               */
N#define FTP_EVT_MKDIR      7      /* Directory created                       */
N#define FTP_EVT_RMDIR      8      /* Directory removed                       */
N#define FTP_EVT_ERRLOCAL   9      /* Local file operation error              */
N#define FTP_EVT_DENIED     10     /* Requested file operation denied         */
N#define FTP_EVT_ERROR      11     /* Generic file operation error            */
N
N/* ARP Cache Entry types */
N#define ARP_FIXED_IP       0      /* Fixed IP adrs is refreshed after tout   */
N#define ARP_TEMP_IP        1      /* Temp adrs is removed after timeout      */
N
N/* BSD Socket typedef's */
Ntypedef struct sockaddr {         /* << Generic Socket Address structure >>  */
N  U16  sa_family;                 /* Address family                          */
N  char sa_data[14];               /* Direct address (up to 14 bytes)         */
N} SOCKADDR;
N
N#pragma push
N#pragma anon_unions
N
Ntypedef struct in_addr {          /* << Generic IPv4 Address structure >>    */
N  union {
N    struct {
N      U8 s_b1,s_b2,s_b3,s_b4;     /* IP address, byte access                 */
N    };
N    struct {
N      U16 s_w1,s_w2;              /* IP address, short int access            */
N    };
N    U32 s_addr;                   /* IP address in network byte order        */
N  };
N} IN_ADDR;
N#pragma pop
N
Ntypedef struct sockaddr_in {      /* << IPv4 Socket Address structure >>     */
N  S16 sin_family;                 /* Socket domain                           */
N  U16 sin_port;                   /* Port                                    */
N  IN_ADDR sin_addr;               /* IP address                              */
N  S8  sin_zero[8];                /* reserved                                */
N} SOCKADDR_IN;
N
Ntypedef struct hostent {          /* << BSD Host Entry structure >>          */
N  char *h_name;                   /* Official name of host                   */
N  char **h_aliases;               /* Pointer to an array of alias names      */
N  S16  h_addrtype;                /* Address Type: AF_INET, AF_NETBIOS       */
N  S16  h_length;                  /* Length of address in bytes              */
N  char **h_addr_list;             /* Pointer to an array of IPv4 addresses   */
N} HOSTENT;
N
Nextern void init_TcpNet (void);
Nextern BOOL main_TcpNet (void);
Nextern void timer_tick (void);
Nextern U8   udp_get_socket (U8 tos, U8 opt, 
N                            U16 (*listener)(U8 socket, U8 *remip, U16 port, U8 *buf, U16 len));
Nextern BOOL udp_release_socket (U8 socket);
Nextern BOOL udp_open (U8 socket, U16 locport);
Nextern BOOL udp_close (U8 socket);
Nextern BOOL udp_mcast_ttl (U8 socket, U8 ttl);
Nextern U8  *udp_get_buf (U16 size);
Nextern BOOL udp_send (U8 socket, U8 *remip, U16 remport, U8 *buf, U16 dlen);
Nextern U8   tcp_get_socket (U8 type, U8 tos, U16 tout,
N                            U16 (*listener)(U8 socket, U8 event, U8 *buf, U16 len));
Nextern BOOL tcp_release_socket (U8 socket);
Nextern BOOL tcp_listen (U8 socket, U16 locport);
Nextern BOOL tcp_connect (U8 socket, U8 *remip, U16 remport, U16 locport);
Nextern U8  *tcp_get_buf (U16 size);
Nextern U16  tcp_max_dsize (U8 socket);
Nextern BOOL tcp_check_send (U8 socket);
Nextern U8   tcp_get_state (U8 socket);
Nextern BOOL tcp_send (U8 socket, U8 *buf, U16 dlen);
Nextern BOOL tcp_close (U8 socket);
Nextern BOOL tcp_abort (U8 socket);
Nextern void tcp_reset_window (U8 socket);
Nextern BOOL arp_cache_ip (U8 *ipadr, U8 type);
Nextern BOOL arp_cache_mac (U8 *hwadr);
Nextern void ppp_listen (const char *user, const char *passw);
Nextern void ppp_connect (const char *dialnum, const char *user, const char *passw);
Nextern void ppp_close (void);
Nextern BOOL ppp_is_up (void);
Nextern void slip_listen (void);
Nextern void slip_connect (const char *dialnum);
Nextern void slip_close (void);
Nextern BOOL slip_is_up (void);
Nextern U8   get_host_by_name (U8 *hostn, void (*cbfunc)(U8 event, U8 *host_ip));
Nextern BOOL smtp_connect (U8 *ipadr, U16 port, void (*cbfunc)(U8 event));
Nextern void dhcp_disable (void);
Nextern BOOL igmp_join (U8 *group_ip);
Nextern BOOL igmp_leave (U8 *group_ip);
Nextern BOOL snmp_trap (U8 *manager_ip, U8 gen_trap, U8 spec_trap, U16 *obj_list);
Nextern BOOL snmp_set_community (const char *community);
Nextern BOOL icmp_ping (U8 *remip, void (*cbfunc)(U8 event));
Nextern BOOL ftpc_connect (U8 *ipadr, U16 port, U8 command, void (*cbfunc)(U8 event));
Nextern BOOL tftpc_put (U8 *ipadr, U16 port,
N                       const char *src, const char *dst, void (*cbfunc)(U8 event));
Nextern BOOL tftpc_get (U8 *ipadr, U16 port, 
N                       const char *src, const char *dst, void (*cbfunc)(U8 event));
Nextern BOOL sntp_get_time (U8 *ipadr, void (*cbfunc)(U32 utc_time));
Nextern void ftp_evt_notify (U8 evt);
N
N/* BSD Socket API */
Nextern int  socket (int family, int type, int protocol);
Nextern int  bind (int sock, const SOCKADDR *addr, int addrlen);
Nextern int  listen (int sock, int backlog);
Nextern int  accept (int sock, SOCKADDR *addr, int *addrlen);
Nextern int  connect (int sock, SOCKADDR *addr, int addrlen);
Nextern int  send (int sock, const char *buf, int len, int flags);
Nextern int  sendto (int sock, const char *buf, int len, int flags, SOCKADDR *to, int tolen);
Nextern int  recv (int sock, char *buf, int len, int flags);
Nextern int  recvfrom (int sock, char *buf, int len, int flags, SOCKADDR *from, int *fromlen);
Nextern int  closesocket (int sock);
Nextern int  getpeername (int sock, SOCKADDR *name, int *namelen);
Nextern int  getsockname (int sock, SOCKADDR *name, int *namelen);
Nextern int  ioctlsocket (int sock, long cmd, unsigned long *argp);
Nextern HOSTENT *gethostbyname (const char *name, int *err);
N
N#ifdef __cplusplus
S}
N#endif
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N
N#endif
N 
L 16 "..\..\RL-ARM\Config\Net_Config.h" 2
N
N/* Definitions */
N#define ETH_ADRLEN      6         /* Ethernet Address Length in bytes        */
N#define IP_ADRLEN       4         /* IP Address Length in bytes              */
N#define OS_HEADER_LEN   4         /* TCPnet 'os_frame' header size           */
N                                  /* Frame Header length common for all      */
N#define PHY_HEADER_LEN  (2*ETH_ADRLEN + 2) /* network interfaces.            */
N#define ETH_MTU         1514      /* Ethernet Frame Max Transfer Unit        */
N#define PPP_PROT_IP     0x0021    /* PPP Protocol type: IP                   */
N#define TCP_DEF_WINSIZE 4380      /* TCP default window size                 */
N#define PASSW_SZ        20        /* Authentication Password Buffer size     */
N
N/* Network Interfaces */
N#define NETIF_ETH       0         /* Network interface: Ethernet             */
N#define NETIF_PPP       1         /* Network interface: PPP                  */
N#define NETIF_SLIP      2         /* Network interface: Slip                 */
N#define NETIF_LOCAL     3         /* Network interface: Localhost (loopback) */
N#define NETIF_NULL      4         /* Network interface: Null (none)          */
N
N/* Telnet Definitions */
N#define TNET_LBUFSZ     96        /* Command Line buffer size (bytes)        */
N#define TNET_HISTSZ     128       /* Command History buffer size (bytes)     */
N#define TNET_FIFOSZ     128       /* Input character Fifo buffer (bytes)     */
N
N/* SNMP-MIB Definitions */
N#define MIB_INTEGER     0x02      /* MIB entry type INTEGER                  */
N#define MIB_OCTET_STR   0x04      /* MIB entry type OCTET_STRING             */
N#define MIB_OBJECT_ID   0x06      /* MIB entry type OBJECT_IDENTIFIER        */
N#define MIB_IP_ADDR     0x40      /* MIB entry type IP ADDRESS (U8[4])       */
N#define MIB_COUNTER     0x41      /* MIB entry type COUNTER (U32)            */
N#define MIB_GAUGE       0x42      /* MIB entry type GAUGE (U32)              */
N#define MIB_TIME_TICKS  0x43      /* MIB entry type TIME_TICKS               */
N#define MIB_ATR_RO      0x80      /* MIB entry attribute READ_ONLY           */
N#define MIB_OIDSZ       17        /* Max.size of Object ID value             */
N#define MIB_STRSZ       110       /* Max.size of Octet String variable       */
N#define MIB_READ        0         /* MIB entry Read access                   */
N#define MIB_WRITE       1         /* MIB entry Write access                  */
N
N/* SNMP-MIB Macros */
N#define MIB_STR(s)      sizeof(s)-1, s
N#define MIB_INT(o)      sizeof(o), (void *)&o
N#define MIB_IP(ip)      4, (void *)&ip 
N#define OID0(f,s)       (f*40 + s) 
N
N/* Debug Module Definitions */
N#define MODULE_MEM      0         /* Dynamic Memory Module ID                */
N#define MODULE_ETH      1         /* Ethernet Module ID                      */
N#define MODULE_PPP      2         /* PPP Module ID                           */
N#define MODULE_SLIP     3         /* SLIP Module ID                          */
N#define MODULE_ARP      4         /* ARP Module ID                           */
N#define MODULE_IP       5         /* IP Module ID                            */
N#define MODULE_ICMP     6         /* ICMP Module ID                          */
N#define MODULE_IGMP     7         /* IGMP Module ID                          */
N#define MODULE_UDP      8         /* UDP Module ID                           */
N#define MODULE_TCP      9         /* TCP Module ID                           */
N#define MODULE_NBNS     10        /* NBNS Module ID                          */
N#define MODULE_DHCP     11        /* DHCP Module ID                          */
N#define MODULE_DNS      12        /* DNS Module ID                           */
N#define MODULE_SNMP     13        /* SNMP Module ID                          */
N#define MODULE_BSD      14        /* BSD Socket Module ID                    */
N#define MODULE_HTTP     15        /* HTTP Server Module ID                   */
N#define MODULE_FTP      16        /* FTP Server Module ID                    */
N#define MODULE_FTPC     17        /* FTP Client Module ID                    */
N#define MODULE_TNET     18        /* Telnet Server Module ID                 */
N#define MODULE_TFTP     19        /* TFTP Server Module ID                   */
N#define MODULE_TFTPC    20        /* TFTP Client Module ID                   */
N#define MODULE_SMTP     21        /* SMTP Client Module ID                   */
N#define MODULE_SNTP     22        /* SNTP Client Module ID                   */
N
N/*---------------------------------------------------------------------------*/
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
Ntypedef struct os_frame {         /* << System frame buffer structure >>     */
N  U16 length;                     /* Total Length of data in frame           */
N  U16 index;                      /* Buffer Position Index                   */
N  U8  data[1];                    /* Buffer data (protocol headers + data)   */
N} OS_FRAME;
N
Ntypedef struct arp_info {         /* << ARP Cache Entry info >>              */
N  U8  State;                      /* ARP Cache entry current state           */
N  U8  Type;                       /* Cache Entry type                        */
N  U8  Retries;                    /* Number of Retries left                  */
N  U8  Tout;                       /* Cache Entry Timeout                     */
N  U8  HwAdr[ETH_ADRLEN];          /* Ethernet Hardware Address               */
X  U8  HwAdr[6];           
N  U8  IpAdr[IP_ADRLEN];           /* Ethernet IP Address                     */
X  U8  IpAdr[4];            
N} ARP_INFO;
N
Ntypedef struct igmp_info {        /* << IGMP Group info >>                   */
N  U8  State;                      /* Group membership current state          */
N  U8  Tout;                       /* Timeout Timer for sending reports       */
N  U8  Flags;                      /* State machine flags                     */
N  U8  GrpIpAdr[IP_ADRLEN];        /* Group IP address                        */
X  U8  GrpIpAdr[4];         
N} IGMP_INFO;
N
Ntypedef struct udp_info {         /* << UDP Socket info >>                   */
N  U8  State;                      /* UDP Socket entry current state          */
N  U8  Opt;                        /* UDP Socket Options                      */
N  U8  Flags;                      /* State machine flags                     */
N  U8  Tos;                        /* UDP Type of Service                     */
N  U16 LocPort;                    /* Local UDP port of Socket                */
N  U8  McastTtl;                   /* MultiCast Time To Live                  */
N                                  /* Application Event CallBack function     */
N  U16 (*cb_func)(U8 socket, U8 *rem_ip, U16 port, U8 *buf, U16 len);
N} UDP_INFO;
N
Ntypedef struct tcp_info {         /* << TCP Socket info >>                   */
N  U8  State;                      /* Socket entry current state              */
N  U8  Type;                       /* Socket type                             */
N  U8  Flags;                      /* State machine flags                     */
N  U8  Tos;                        /* Type of service allocated               */
N  U8  RemIpAdr[IP_ADRLEN];        /* Remote IP address                       */
X  U8  RemIpAdr[4];         
N  U16 RemPort;                    /* Remote TCP port                         */
N  U16 LocPort;                    /* Local TCP port                          */
N  U16 MaxSegSize;                 /* Transmit Max. Segment Size              */
N  U16 Tout;                       /* Socket idle timeout (in seconds)        */
N  U16 AliveTimer;                 /* Keep Alive timer                        */
N  U16 RetryTimer;                 /* Retransmission timer                    */
N  U8  AckTimer;                   /* Receive Delay-ack timer                 */
N  U8  Id;                         /* Socket identification number            */
N  U8  Retries;                    /* Number of retries left before aborting  */
N  U8  DupAcks;                    /* Number of duplicate acks (fast recovery)*/
N  U32 SendUna;                    /* Send Sequence Number unacknowledged     */
N  U32 SendNext;                   /* Next Send Sequence Number               */
N  U32 SendChk;                    /* Check Sequence Number for dupacks       */
N  U32 SendWl1;                    /* Sequence Number of last Window update   */
N  U32 SendWl2;                    /* Acknowledge Number of last Window update*/
N  U16 SendWin;                    /* Current Send Window                     */
N  S16 RttSa;                      /* Scaled Average for RTT estimator        */
N  S16 RttSv;                      /* Scaled deViation for RTT estimator      */
N  U16 CWnd;                       /* Congestion Window                       */
N  U16 SsThresh;                   /* Slow Start Treshold                     */
N  U16 RecWin;                     /* Current Receive Window                  */
N  U32 RecNext;                    /* Next Receive Sequence Number            */
N  OS_FRAME *unack_list;           /* Unacked queue list                      */
N                                  /* Application Event-CallBack function     */
N  U16 (*cb_func)(U8 socket, U8 event, U8 *p1, U16 p2);
N} TCP_INFO;
N
Ntypedef struct bsd_info {         /* << BSD Socket info >>                   */
N  U8  State;                      /* BSD Socket current state                */
N  U8  Socket;                     /* Binded TCP/UDP Socket                   */
N  U8  Flags;                      /* Flags for Socket Option                 */
N  U8  Type;                       /* Type of Socket (SOCK_DGRAM/SOCK_STREAM) */
N  U16 LocPort;                    /* Bind local Port                         */
N  U16 RemPort;                    /* Remote TCP/UDP Port                     */
N  U32 LocIP;                      /* Bind local IP address (net byte order)  */
N  U32 RemIP;                      /* Remote IP address     (net byte order)  */
N  U8  AcceptSock;                 /* Accept Socket list                      */
N  U8  ParentSock;                 /* Parent (server) socket                  */
N  U8  Event;                      /* Wait Event flags in RTX environment     */
N  U8  Task;                       /* Socket Owner Task                       */
N  U16 Tout;                       /* Receive timer value                     */
N  void *buf_list;                 /* Rx Data buffer chain                    */
N} BSD_INFO;
N
Ntypedef struct http_info {        /* << HTTP Session info >>                 */
N  U8  State;                      /* HTTP Session current state              */
N  U8  Socket;                     /* binded TCP Socket                       */
N  U16 Flags;                      /* State machine Flags                     */
N  U8  FType;                      /* File Type: html, jpeg, gif,...          */
N  U8  PostSt;                     /* POST method Processing Status           */
N  U16 DelimSz;                    /* Boundary delimiter size                 */
N  U8  UserId;                     /* User Id (authentication enabled)        */
N  U32 CGIvar;                     /* CGI session private variable (cgi_func) */
N  U32 DLen;                       /* Data length (number of bytes to send)   */
N  U32 Count;                      /* Total number of bytes sent              */
N  U16 BCnt;                       /* Number of bytes sent in last packet     */
N  U8  Lang[6];                    /* Selected Web Language: en-us, de, fr .. */
N  U32 LMDate;                     /* Last Modified Date (UTC format)         */
N  U8 *Script;                     /* Script Buffer pointer                   */
N  U8 *pDelim;                     /* Multipart Boundary delimiter value      */
N  void *sFile;                    /* Script Interpreter File pointer         */
N  void *dFile;                    /* Data File pointer                       */
N} HTTP_INFO;
N
Ntypedef struct http_file {        /* << HTTP Internal File info >>           */
N  U32       Id;                   /* File Name Id (CRC32 value of file name) */
N  const U8 *Start;                /* File Start Address in ROM               */
N} const HTTP_FILE;
N
Ntypedef struct tnet_info {        /* << Telnet Session info >>               */
N  U8  State;                      /* Telnet Session current state            */
N  U8  Socket;                     /* binded TCP Socket                       */
N  U8  Flags;                      /* State machine Flags                     */
N  U8  BCnt;                       /* Received Data byte count                */
N  U16 Tout;                       /* Timeout delay counter                   */
N  U8  UserId;                     /* User Id (authentication enabled)        */
N  U8  Widx;                       /* Fifo buffer Write index                 */
N  U8  Ridx;                       /* Fifo buffer Read index                  */
N  U8  hNext;                      /* History command next position           */
N  U8  hCurr;                      /* History command current position        */
N  U32 SVar;                       /* Session private var. (tnet_process_cmd) */
N  U8  LBuf[TNET_LBUFSZ];          /* Data Line Buffer                        */
X  U8  LBuf[96];           
N  U8  Fifo[TNET_FIFOSZ];          /* Fifo Buffer for received line/keycodes  */
X  U8  Fifo[128];           
N  U8  Hist[TNET_HISTSZ];          /* Command History buffer                  */
X  U8  Hist[128];           
N} TNET_INFO;
N
Ntypedef struct tftp_info {        /* << TFTP Session info >>                 */
N  U8  State;                      /* TFTP Session current state              */
N  U8  Socket;                     /* binded UDP Data Socket                  */
N  U8  Flags;                      /* State machine Flags                     */
N  U8  Retries;                    /* Retry counter                           */
N  U8  RemIpAdr[IP_ADRLEN];        /* Remote IP address                       */
X  U8  RemIpAdr[4];         
N  U16 RemPort;                    /* Remote UDP port (TID)                   */
N  U16 BlockSz;                    /* Transfer Block size                     */
N  U16 BlockNr;                    /* Block Number                            */
N  U8  Timer;                      /* Timeout Timer value                     */
N  U16 BufLen;                     /* Length of retransmit buffer             */
N  U8  *Buf;                       /* Transmit/Retransmit buffer              */
N  void *File;                     /* File Handle pointer                     */
N} TFTP_INFO;
N
Ntypedef struct ftp_info {         /* << FTP Session info >>                  */
N  U8  State;                      /* FTP Session current state               */
N  U8  Socket;                     /* binded TCP Control Socket               */
N  U16 Flags;                      /* State machine Flags                     */
N  U8  RemIpAdr[IP_ADRLEN];        /* Client IP address                       */
X  U8  RemIpAdr[4];         
N  U16 DPort;                      /* TCP Data port (Server or Client)        */
N  U8  DSocket;                    /* TCP Data Socket                         */
N  U8  UserId;                     /* User Id (authentication enabled)        */
N  U8  Resp;                       /* FTP Server Response Code                */
N  U8  PathLen;                    /* Size of the Path string                 */
N  U8 *Path;                       /* Current Working Directory               */
N  U8 *Name;                       /* Absolute File/Folder Path Name          */
N  void *File;                     /* File Handle pointer                     */
N} FTP_INFO;
N
Ntypedef struct dns_cache {        /* << DNS Cache Entry info >>              */
N  U32 HostId;                     /* Host Id (CRC32 value of host name)      */
N  U32 Ttl;                        /* Cache Entry Time To Live                */
N  U8  IpAdr[IP_ADRLEN];           /* Ethernet IP Address                     */
X  U8  IpAdr[4];            
N} DNS_CACHE;
N
Ntypedef struct localm {           /* << Local Machine info >>                */
N  U8  IpAdr[IP_ADRLEN];           /* Local IP Address                        */
X  U8  IpAdr[4];            
N  U8  DefGW[IP_ADRLEN];           /* Default GateWay                         */
X  U8  DefGW[4];            
N  U8  NetMask[IP_ADRLEN];         /* Net Mask                                */
X  U8  NetMask[4];          
N  U8  PriDNS[IP_ADRLEN];          /* Primary DNS Server                      */
X  U8  PriDNS[4];           
N  U8  SecDNS[IP_ADRLEN];          /* Secondary DNS Server                    */
X  U8  SecDNS[4];           
N} LOCALM;
N
Ntypedef struct remotem {          /* << Remote Machine Info >>               */
N  U8  IpAdr[IP_ADRLEN];           /* Remote IP address                       */
X  U8  IpAdr[4];            
N  U8  HwAdr[ETH_ADRLEN];          /* Remote Hardware Address                 */
X  U8  HwAdr[6];           
N} REMOTEM;
N
Ntypedef struct mib_entry {        /* << SNMP-MIB Entry Info >>               */
N  U8  Type;                       /* Object Type                             */
N  U8  OidLen;                     /* Object ID length                        */
N  U8  Oid[MIB_OIDSZ];             /* Object ID value                         */
X  U8  Oid[17];              
N  U8  ValSz;                      /* Size of a Variable                      */
N  void *Val;                      /* Pointer to a variable                   */
N  void (*cb_func)(int mode);      /* Write/Read event callback function      */
N} MIB_ENTRY;
N
Ntypedef struct sys_cfg {          /* << SYS Configuration info >>            */
N  U32 *MemPool;                   /* Dynamic Memory Pool buffer              */
N  U32 MemSize;                    /* Memory Pool size in bytes               */
N  U8  TickRate;                   /* Tick Rate in ticks per second           */
N  U8  TickItv;                    /* Tick Interval in ms                     */
N  U8  T200ms;                     /* Delay 200 ms in ticks                   */
N  U8  NetCfg;                     /* Network Interface Configuration flags   */
N  U8 *HostName;                   /* Local Host Name                         */
N} const SYS_CFG;
N
Ntypedef struct arp_cfg {          /* << ARP Configuration info >>            */
N  ARP_INFO *Table;                /* Cache Table array                       */
N  U8  TabSize;                    /* Cache Table size                        */
N  U8  TimeOut;                    /* Table Entry expiration time in seconds  */
N  U8  MaxRetry;                   /* Number of Retries to resolve MAC addr.  */
N  U8  Resend;                     /* Resend Timeout in seconds               */
N  U8  Notify;                     /* Notify on IP address changes             */
N} const ARP_CFG;
N
Ntypedef struct igmp_cfg {         /* << IGMP Configuration info >>           */
N  IGMP_INFO *Table;               /* Group Table array                       */
N  U16 TabSize;                    /* Group Table size                        */
N} const IGMP_CFG;
N
Ntypedef struct dhcp_cfg {         /* << DHCP Configuration info >>           */
N  U8 *Vcid;                       /* Vendor Class Identifier                 */
N  U8  Opt;                        /* Extra DHCP option flags                 */
N} const DHCP_CFG;
N
Ntypedef struct ppp_cfg {          /* << PPP Configuration info >>            */
N  U32 ACCmap;                     /* Async Control Character map             */
N  U16 SerTout;                    /* Serial Frame Receive Timeout            */
N  U16 RetryTout;                  /* Retry Timeout in ticks                  */
N  U16 EchoTout;                   /* LCP Echo Timeout in seconds             */
N  U8  MaxRetry;                   /* Number of Retries                       */
N  U8  EnAuth;                     /* Enabled Authentication protocols        */
N} const PPP_CFG;
N
Ntypedef struct udp_cfg {          /* << UDP Configuration info >>            */
N  UDP_INFO *Scb;                  /* Socket Control Block array              */
N  U8  NumSocks;                   /* Number of UDP Sockets                   */
N} const UDP_CFG;
N
Ntypedef struct tcp_cfg {          /* << TCP Configuration info >>            */
N  TCP_INFO *Scb;                  /* Socket Control Block array              */
N  U8  NumSocks;                   /* Number of TCP Sockets                   */
N  U8  MaxRetry;                   /* Number of Retries                       */
N  U16 RetryTout;                  /* Retry Timeout in ticks                  */
N  U16 T2MSLTout;                  /* Maximum Segment Life Time               */
N  U16 SynRetryTout;               /* SYN Retry Timeout in ticks              */
N  U16 InitRetryTout;              /* Initial Retransmit timeout in ticks     */
N  U16 DefTout;                    /* Default Connect Timeout in seconds      */
N  U16 MaxSegSize;                 /* Maximum Segment Size value              */
N  U16 RecWinSize;                 /* Receiving Window Size in bytes          */
N  U8  ConRetry;                   /* Number of Retries to Connect            */
N} const TCP_CFG;
N
Ntypedef struct http_cfg {         /* << HTTP Configuration info >>           */
N  HTTP_INFO *Scb;                 /* Session Control Block array             */
N  U8  NumSess;                    /* Max. Number of Active Sessions          */
N  U8  EnAuth;                     /* Enable User Authentication              */
N  U16 PortNum;                    /* Listening Port number                   */
N  U8 const *SrvId;                /* Server-Id http header                   */
N  U8 const *Realm;                /* Authentication Realm                    */
N  U8 const *User;                 /* Authentication User name                */
N  U8 *Passw;                      /* Authentication Password                 */
N} const HTTP_CFG;
N
Ntypedef struct tnet_cfg {         /* << TNET Configuration info >>           */
N  TNET_INFO *Scb;                 /* Session Control Block array             */
N  U8  NumSess;                    /* Max. Number of Active Sessions          */
N  U8  EnAuth;                     /* Enable User Authentication              */
N  U8  NoEcho;                     /* Disable Server Echo mode                */
N  U16 PortNum;                    /* Listening Port number                   */
N  U16 IdleTout;                   /* Idle Connection timeout in ticks        */
N  U8 const *User;                 /* Authentication User Name                */
N  U8 *Passw;                      /* Authentication Password                 */
N} const TNET_CFG;
N
Ntypedef struct tftp_cfg {         /* << TFTP Configuration info >>           */
N  TFTP_INFO *Scb;                 /* Session Control Block array             */
N  U8  NumSess;                    /* Max. Number of Active Sessions          */
N  U8  MaxRetry;                   /* Number of Retries                       */
N  U16 PortNum;                    /* Listening Port number                   */
N  U8  DefTout;                    /* Inactive Session Timeout in seconds     */
N  U8  EnFwall;                    /* Enable Firewall Support                 */
N} const TFTP_CFG;
N
Ntypedef struct tftpc_cfg {        /* << TFTPC Configuration info >>          */
N  U16 BlockSize;                  /* Transfer Block size                     */
N  U16 RetryTout;                  /* Retry Timeout in ticks                  */
N  U8  MaxRetry;                   /* Number of Retries                       */
N} const TFTPC_CFG;
N
Ntypedef struct ftp_cfg {          /* << FTP Configuration info >>            */
N  FTP_INFO *Scb;                  /* Session Control Block array             */
N  U8  NumSess;                    /* Max. Number of Active Sessions          */
N  U8  EnAuth;                     /* Enable User Authentication              */
N  U16 PortNum;                    /* Listening Port number                   */
N  U16 IdleTout;                   /* Idle Connection timeout in ticks        */
N  U8  MsgLen;                     /* Length of welcome message               */
N  U8 const *Msg;                  /* Server Welcome message                  */ 
N  U8 const *User;                 /* Authentication User Name                */
N  U8 *Passw;                      /* Authentication Password                 */
N} const FTP_CFG;
N
Ntypedef struct ftpc_cfg {         /* << FTPC Configuration info >>           */
N  U8  DefTout;                    /* Default inactivity timeout              */
N  U8  PasvMode;                   /* FTP Passive Mode used                   */
N} const FTPC_CFG;
N
Ntypedef struct dns_cfg {          /* << DNS Configuration info >>            */
N  DNS_CACHE *Table;               /* Cache Table array                       */
N  U8  TabSize;                    /* Cache Table size                        */
N} const DNS_CFG;
N
Ntypedef struct snmp_cfg {         /* << SNMP Configuration info >>           */
N  U16 PortNum;                    /* Listening Port number                   */
N  U16 TrapPort;                   /* Trap Port number                        */
N  U8  TrapIp[IP_ADRLEN];          /* Trap Server IP Address                  */
X  U8  TrapIp[4];           
N  U8 const *Community;            /* Community Name                          */
N  U8  TickItv;                    /* Tick Interval in ticks                  */
N} const SNMP_CFG;
N
Ntypedef struct sntp_cfg {         /* << SNTP Configuration info >>           */
N  U8  SrvIp[IP_ADRLEN];           /* NTP/SNTP Server IP Address              */
X  U8  SrvIp[4];            
N  U8  Bcast;                      /* Broadcast client mode (for LAN only)    */
N} const SNTP_CFG;
N
Ntypedef struct bsd_cfg {          /* << BSD Configuration info >>            */
N  BSD_INFO *Scb;                  /* Socket Control Block array              */
N  U8  NumSocks;                   /* Number of BSD Sockets                   */
N  U8  InRtx;                      /* Running in RTX environment              */
N  U16 RcvTout;                    /* Blocking recv timeout in ticks          */
N} const BSD_CFG;
N
Ntypedef enum {                    /* << Fatal System Error Codes >>          */
N  ERR_MEM_ALLOC,                  /* Alloc memory failed, out of memory      */
N  ERR_MEM_FREE,                   /* Free memory failed, memory slot invalid */
N  ERR_MEM_CORRUPT,                /* Memory corruption detected              */
N  ERR_MEM_LOCK,                   /* Locked memory function re-entered error */
N  ERR_UDP_ALLOC,                  /* No free UDP sockets available           */
N  ERR_TCP_ALLOC,                  /* No free TCP sockets available           */
N  ERR_TCP_STATE                   /* TCP socket in undefined state           */
N} ERROR_CODE;
N
N
N/*----------------------------------------------------------------------------
N *      Functions
N *---------------------------------------------------------------------------*/
N
N/* Net_Config.c */
Nextern void init_system (void);
Nextern void run_system (void);
Nextern void sys_error (ERROR_CODE code);
N
N/* at_Mem.c */
Nextern OS_FRAME *alloc_mem (U32 byte_size);
Nextern void free_mem (OS_FRAME *mem_ptr);
N
N/* at_Ethernet.c */
Nextern void eth_init_link (void);
Nextern void eth_run_link (void);
Nextern void put_in_queue (OS_FRAME *frame);
Nextern BOOL eth_send_frame (OS_FRAME *frame);
Nextern BOOL eth_chk_adr (OS_FRAME *frame);
Nextern U8  *eth_get_adr (U8 *ipadr);
N
N/* at_Ppp.c */
Nextern void ppp_init_link (void);
Nextern void ppp_run_link (void);
Nextern BOOL ppp_send_frame (OS_FRAME *frame, U16 prot);
N
N/* at_Ppp_Pap.c */
Nextern void pap_init (void);
Nextern void pap_process (OS_FRAME *frame);
Nextern void pap_run (void);
N
N/* at_Ppp_Chap.c */
Nextern void chap_init (void);
Nextern void chap_process (OS_FRAME *frame);
Nextern void chap_run (void);
N
N/* at_Slip.c */
Nextern void slip_init_link (void);
Nextern void slip_run_link (void);
Nextern BOOL slip_send_frame (OS_FRAME *frame);
N
N/* at_Lib.c */
Nextern int  mem_copy (void *dp, void *sp, int len);
Nextern void mem_rcopy (void *dp, void *sp, int len);
Nextern BOOL mem_comp (void *sp1, void *sp2, int len);
Nextern void mem_set (void *dp, U8 val, int len);
Nextern BOOL mem_test (void *sp, U8 val, int len);
Nextern BOOL str_scomp (U8 *sp, U8 const *cp);
Nextern int  str_copy (U8 *dp, U8 *sp);
Nextern void str_up_case (U8 *dp, U8 *sp);
N
N/* at_Arp.c */
Nextern void arp_notify (void);
Nextern BOOL arp_get_info (REMOTEM *info);
N
N/* at_Ip.c */
Nextern void ip_init (void);
Nextern void ip_run_local (void);
N
N/* at_Dhcp.c */
Nextern void dhcp_cbfunc (U8 opt, U8 *val, U16 len);
N
N/* at_Icmp.c */
Nextern void icmp_init (void);
Nextern void icmp_run_engine (void);
N
N/* at_Igmp.c */
Nextern void igmp_init (void);
Nextern void igmp_run_host (void);
Nextern void igmp_process (OS_FRAME *frame);
N
N/* at_Udp.c */
Nextern void udp_init (void);
Nextern void udp_process (OS_FRAME *frame);
N
N/* at_Tcp.c */
Nextern void tcp_init (void);
Nextern void tcp_poll_sockets (void);
Nextern void tcp_process (OS_FRAME *frame);
N
N/* at_Bsd.c */
Nextern void bsd_init (void);
Nextern void bsd_poll_sockets (void);
Nextern U8   bsd_wait (BSD_INFO *bsd_s, U8 evt);
Nextern void bsd_enable (BSD_INFO *bsd_s, U8 evt);
N
N/* at_Bsd_Host.c */
Nextern void bsd_init_host (void);
N
N/* at_Http.c */
Nextern void http_init (void);
Nextern void http_run_server (void);
Nextern void *http_fopen (U8 *name);
Nextern void http_fclose (void *file);
Nextern U16  http_fread (void *file, U8 *buf, U16 len);
Nextern BOOL http_fgets (void *file, U8 *buf, U16 size);
Nextern U32  http_finfo (U8 *name);
Nextern void cgi_process_var (U8 *qstr);
Nextern void cgi_process_data (U8 code, U8 *dat, U16 len);
Nextern U16  cgi_func (U8 *env, U8 *buf, U16 buflen, U32 *pcgi);
Nextern U8  *cgx_content_type (void);
Nextern U8  *http_encoding (void);
Nextern BOOL http_accept_host (U8 *rem_ip, U16 rem_port);
Nextern BOOL http_file_access (U8 *fname, U8 user_id);
Nextern U8   http_check_account (U8 *user, U8 *passw);
Nextern U8  *http_get_var (U8 *env, void *ansi, U16 maxlen);
Nextern U8  *http_get_lang (void);
Nextern void http_get_info (REMOTEM *info);
Nextern U8   http_get_session (void);
Nextern U8   http_get_user_id (void);
Nextern U8  *http_get_content_type (void);
Nextern U32  http_date (RL_TIME *time);
N
N/* at_Telnet.c */
Nextern void tnet_init (void);
Nextern void tnet_run_server (void);
Nextern U16  tnet_cbfunc (U8 code, U8 *buf, U16 buflen);
Nextern U16  tnet_process_cmd (U8 *cmd, U8 *buf, U16 buflen, U32 *pvar);
Nextern BOOL tnet_ccmp (U8 *buf, U8 *cmd);
Nextern void tnet_set_delay (U16 dly);
Nextern void tnet_get_info (REMOTEM *info);
Nextern U8   tnet_get_session (void);
Nextern U8   tnet_get_user_id (void);
Nextern BOOL tnet_msg_poll (U8 session);
Nextern BOOL tnet_accept_host (U8 *rem_ip, U16 rem_port);
Nextern U8   tnet_check_account (U8 code, U8 *id);
N
N/* at_Tftp.c */
Nextern void tftp_init (void);
Nextern void tftp_run_server (void);
Nextern void *tftp_fopen (U8 *fname, U8 *mode);
Nextern void tftp_fclose (void *file);
Nextern U16  tftp_fread (void *file, U8 *buf, U16 len);
Nextern U16  tftp_fwrite (void *file, U8 *buf, U16 len);
Nextern BOOL tftp_accept_host (U8 *rem_ip, U16 rem_port);
N
N/* at_Tftpc.c */
Nextern void tftpc_init (void);
Nextern void tftpc_run_client (void);
Nextern void *tftpc_fopen (U8 *fname, U8 *mode);
Nextern void tftpc_fclose (void *file);
Nextern U16  tftpc_fread (void *file, U8 *buf, U16 len);
Nextern U16  tftpc_fwrite (void *file, U8 *buf, U16 len);
N
N/* at_Ftp.c */
Nextern void ftp_init (void);
Nextern void ftp_run_server (void);
Nextern void *ftp_fopen (U8 *fname, U8 *mode);
Nextern void ftp_fclose (void *file);
Nextern U16  ftp_fread (void *file, U8 *buf, U16 len);
Nextern U16  ftp_fwrite (void *file, U8 *buf, U16 len);
Nextern BOOL ftp_fdelete (U8 *fname);
Nextern BOOL ftp_frename (U8 *fname, U8 *newn);
Nextern U16  ftp_ffind (U8 code, U8 *buf, U8 *mask, U16 len);
Nextern BOOL ftp_accept_host (U8 *rem_ip, U16 rem_port);
Nextern U8   ftp_check_account (U8 code, U8 *id);
Nextern U8   ftp_get_user_id (void);
Nextern BOOL ftp_file_access (U8 *fname, U8 mode, U8 user_id);
Nextern void ftp_evt_notify (U8 evt);
N
N/* at_Ftpc.c */
Nextern void ftpc_init (void);
Nextern void ftpc_run_client (void);
Nextern void *ftpc_fopen (U8 *mode);
Nextern void ftpc_fclose (void *file);
Nextern U16  ftpc_fread (void *file, U8 *buf, U16 len);
Nextern U16  ftpc_fwrite (void *file, U8 *buf, U16 len);
Nextern U16  ftpc_cbfunc (U8 code, U8 *buf, U16 buflen);
N
N/* at_Dhcp.c */
Nextern void dhcp_init (void);
Nextern void dhcp_run_client (void);
N#define init_dhcp   dhcp_init
N
N/* at_Nbns.c */
Nextern void nbns_init (void);
N
N/* at_Dns.c */
Nextern void dns_init (void);
Nextern void dns_run_client (void);
Nextern U8   get_host_by_name (U8 *hostn, void (*cbfunc)(U8, U8 *));
N
N/* at_Smtp.c */
Nextern void smtp_init (void);
Nextern void smtp_run_client (void);
Nextern U16  smtp_cbfunc (U8 code, U8 *buf, U16 buflen, U32 *pvar);
Nextern BOOL smtp_accept_auth (U8 *srv_ip);
N
N/* at_Snmp.c */
Nextern void snmp_init (void);
Nextern void snmp_run_agent (void);
N
N/* at_Sntp.c */
Nextern void sntp_init (void);
Nextern void sntp_run_client (void);
N
N/* Ethernet Device Driver */
Nextern void init_ethernet (void);
Nextern void send_frame (OS_FRAME *frame);
N__weak void poll_ethernet (void);
Nextern void int_enable_eth (void);
Nextern void int_disable_eth (void);
N
N/* Serial Device Driver */
Nextern void init_serial (void);
Nextern int  com_getchar (void);
Nextern BOOL com_putchar (U8 c);
Nextern BOOL com_tx_active (void);
N
N/* Modem Device Driver */
Nextern void modem_init (void);
Nextern void modem_dial (U8 *dialnum);
Nextern void modem_hangup (void);
Nextern void modem_listen (void);
Nextern BOOL modem_online (void);
Nextern BOOL modem_process (U8 ch);
Nextern void modem_run (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N
N#endif
N
L 13 "..\..\RL-ARM\Config\Net_Config.c" 2
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> -----------------
N//
N// <h>System Definitions
N// =====================
N// <i> Global TCPnet System definitions
N//   <s.15>Local Host Name
N//   <i> This is the name under which embedded host
N//   <i> can be accessed on a local area network.
N//   <i> Default: "mcb2300"
N#define LHOST_NAME     "armfly"
N
N//   <o>Memory Pool size <1536-262144:4><#/4>
N//   <i> This is the size of a memory pool in bytes. Buffers for
N//   <i> TCPnet packets are allocated from this memory pool.
N//   <i> Default: 8000 bytes
N#define MEM_SIZE       2048
N
N//   <o>Tick Timer interval <10=> 10 ms <20=> 20 ms <25=> 25 ms
N//                          <40=> 40 ms <50=> 50 ms <100=> 100 ms 
N//                          <200=> 200 ms
N//   <i> System Tick Timer interval for software timers
N//   <i> Default: 100 ms
N#define TICK_INTERVAL  100
N
N// </h>
N// <e>Ethernet Network Interface
N// =============================
N// <i> Enable or disable Ethernet Network Interface
N#define ETH_ENABLE     1
N
N//   <h>MAC Address
N//   ==============
N//   <i> Local Ethernet MAC Address
N//   <i> Value FF:FF:FF:FF:FF:FF is not allowed.
N//   <i> It is an ethernet Broadcast MAC address.
N//     <o>Address byte 1 <0x00-0xff:2>
N//     <i> LSB is an ethernet Multicast bit.
N//     <i> Must be 0 for local MAC address.
N//     <i> Default: 0x00
N#define _MAC1          0x1E
N
N//     <o>Address byte 2 <0x00-0xff>
N//     <i> Default: 0x30
N#define _MAC2          0x30
N
N//     <o>Address byte 3 <0x00-0xff>
N//     <i> Default: 0x6C
N#define _MAC3          0x6C
N
N//     <o>Address byte 4 <0x00-0xff>
N//     <i> Default: 0x00
N#define _MAC4          0xA2
N
N//     <o>Address byte 5 <0x00-0xff>
N//     <i> Default: 0x00
N#define _MAC5          0x45
N
N//     <o>Address byte 6 <0x00-0xff>
N//     <i> Default: 0x01
N#define _MAC6          0x5E
N
N//   </h>
N//   <h>IP Address
N//   =============
N//   <i> Local Static IP Address
N//   <i> Value 255.255.255.255 is not allowed.
N//   <i> It is a Broadcast IP address.
N//     <o>Address byte 1 <0-255>
N//     <i> Default: 192
N#define _IP1           192
N
N//     <o>Address byte 2 <0-255>
N//     <i> Default: 168
N#define _IP2           168
N
N//     <o>Address byte 3 <0-255>
N//     <i> Default: 0
N#define _IP3           1
N
N//     <o>Address byte 4 <0-255>
N//     <i> Default: 100
N#define _IP4           100
N
N//   </h>
N//   <h>Subnet mask
N//   ==============
N//   <i> Local Subnet mask
N//     <o>Mask byte 1 <0-255>
N//     <i> Default: 255
N#define _MSK1          255
N
N//     <o>Mask byte 2 <0-255>
N//     <i> Default: 255
N#define _MSK2          255
N
N//     <o>Mask byte 3 <0-255>
N//     <i> Default: 255
N#define _MSK3          255
N
N//     <o>Mask byte 4 <0-255>
N//     <i> Default: 0
N#define _MSK4          0
N
N//   </h>
N//   <h>Default Gateway
N//   ==================
N//   <i> Default Gateway IP Address
N//     <o>Address byte 1 <0-255>
N//     <i> Default: 192
N#define _GW1           192
N
N//     <o>Address byte 2 <0-255>
N//     <i> Default: 168
N#define _GW2           168
N
N//     <o>Address byte 3 <0-255>
N//     <i> Default: 0
N#define _GW3           1
N
N//     <o>Address byte 4 <0-255>
N//     <i> Default: 254
N#define _GW4           1
N
N//   </h>
N//   <h>Primary DNS Server
N//   =====================
N//   <i> Primary DNS Server IP Address
N//     <o>Address byte 1 <0-255>
N//     <i> Default: 194
N#define _pDNS1         194
N
N//     <o>Address byte 2 <0-255>
N//     <i> Default: 25
N#define _pDNS2         25
N
N//     <o>Address byte 3 <0-255>
N//     <i> Default: 2
N#define _pDNS3         2
N
N//     <o>Address byte 4 <0-255>
N//     <i> Default: 129
N#define _pDNS4         129
N
N//   </h>
N//   <h>Secondary DNS Server
N//   =======================
N//   <i> Secondary DNS Server IP Address
N//     <o>Address byte 1 <0-255>
N//     <i> Default: 194
N#define _sDNS1         194
N
N//     <o>Address byte 2 <0-255>
N//     <i> Default: 25
N#define _sDNS2         25
N
N//     <o>Address byte 3 <0-255>
N//     <i> Default: 2
N#define _sDNS3         2
N
N//     <o>Address byte 4 <0-255>
N//     <i> Default: 130
N#define _sDNS4         130
N
N//   </h>
N//   <h>ARP Definitions
N//   ==================
N//   <i> Address Resolution Protocol Definitions
N//     <o>Cache Table size <5-100>
N//     <i> Number of cached hardware/IP addresses
N//     <i> Default: 10
N#define ARP_TABSIZE    10
N
N//     <o>Cache Timeout in seconds <5-255>
N//     <i> A timeout for a cached hardware/IP addresses
N//     <i> Default: 150
N#define ARP_TIMEOUT    150
N
N//     <o>Number of Retries <0-20>
N//     <i> Number of Retries to resolve an IP address
N//     <i> before ARP module gives up
N//     <i> Default: 4
N#define ARP_MAXRETRY   4
N
N//     <o>Resend Timeout in seconds <1-10>
N//     <i> A timeout to resend the ARP Request
N//     <i> Default: 2
N#define ARP_RESEND     2
N
N//     <q>Send Notification on Address changes
N//     <i> When this option is enabled, the embedded host
N//     <i> will send a Gratuitous ARP notification at startup,
N//     <i> or when the device IP address has changed.
N//     <i> Default: Disabled
N#define ARP_NOTIFY     0
N
N//   </h>
N//   <e>IGMP Group Management
N//   ========================
N//   <i> Enable or disable Internet Group Management Protocol
N#define IGMP_ENABLE    0
N
N//     <o>Membership Table size <2-50>
N//     <i> Number of Groups this host can join
N//     <i> Default: 5
N#define IGMP_TABSIZE   5
N
N//   </e>
N//   <q>NetBIOS Name Service
N//   =======================
N//   <i> When this option is enabled, the embedded host can be
N//   <i> accessed by his name on the local LAN using NBNS protocol.
N#define NBNS_ENABLE    1
N
N//   <e>Dynamic Host Configuration
N//   =============================
N//   <i> When this option is enabled, local IP address, Net Mask
N//   <i> and Default Gateway are obtained automatically from
N//   <i> the DHCP Server on local LAN.
N#define DHCP_ENABLE    1
N
N//     <s.40>Vendor Class Identifier
N//     <i> This value is optional. If specified, it is added
N//     <i> to DHCP request message, identifying vendor type.
N//     <i> Default: ""
N#define DHCP_VCID      ""
N
N//     <q>Bootfile Name
N//     <i> This value is optional. If enabled, the Bootfile Name
N//     <i> (option 67) is also requested from DHCP server.
N//     <i> Default: disabled
N#define DHCP_BOOTF     0
N
N//     <q>NTP Servers
N//     <i> This value is optional. If enabled, a list of NTP Servers
N//     <i> (option 42) is also requested from DHCP server.
N//     <i> Default: disabled
N#define DHCP_NTPSRV    1
N
N//   </e>
N// </e>
N
N// <e>PPP Network Interface
N// ========================
N// <i> Enable or disable PPP Network Interface
N#define PPP_ENABLE     0
N
N//   <h>IP Address
N//   =============
N//   <i> Local Static IP Address
N//     <o>Address byte 1 <0-255>
N//     <i> Default: 192
N#define _IP1P          192
N
N//     <o>Address byte 2 <0-255>
N//     <i> Default: 168
N#define _IP2P          168
N
N//     <o>Address byte 3 <0-255>
N//     <i> Default: 125
N#define _IP3P          125
N
N//     <o>Address byte 4 <0-255>
N//     <i> Default: 1
N#define _IP4P          1
N
N//   </h>
N//   <h>Subnet mask
N//   ==============
N//   <i> Local Subnet mask
N//     <o>Mask byte 1 <0-255>
N//     <i> Default: 255
N#define _MSK1P         255
N
N//     <o>Mask byte 2 <0-255>
N//     <i> Default: 255
N#define _MSK2P         255
N
N//     <o>Mask byte 3 <0-255>
N//     <i> Default: 255
N#define _MSK3P         255
N
N//     <o>Mask byte 4 <0-255>
N//     <i> Default: 0
N#define _MSK4P         0
N
N//   </h>
N//   <h>Primary DNS Server
N//   =====================
N//   <i> Primary DNS Server IP Address
N//     <o>Address byte 1 <0-255>
N//     <i> Default: 194
N#define _pDNS1P        194
N
N//     <o>Address byte 2 <0-255>
N//     <i> Default: 25
N#define _pDNS2P        25
N
N//     <o>Address byte 3 <0-255>
N//     <i> Default: 2
N#define _pDNS3P        2
N
N//     <o>Address byte 4 <0-255>
N//     <i> Default: 129
N#define _pDNS4P        129
N
N//   </h>
N//   <h>Secondary DNS Server
N//   =======================
N//   <i> Secondary DNS Server IP Address
N//     <o>Address byte 1 <0-255>
N//     <i> Default: 194
N#define _sDNS1P        194
N
N//     <o>Address byte 2 <0-255>
N//     <i> Default: 25
N#define _sDNS2P        25
N
N//     <o>Address byte 3 <0-255>
N//     <i> Default: 2
N#define _sDNS3P        2
N
N//     <o>Address byte 4 <0-255>
N//     <i> Default: 130
N#define _sDNS4P        130
N
N//   </h>
N//   <e>Logon Authentication
N//   =======================
N//   <i> Enable or disable user authentication
N#define PPP_AUTHEN     1
N
N//     <q>Unsecured password (PAP)
N//     <i>Allow or use Password Authentication Protocol.
N#define PPP_PAPEN      1
N
N//     <q>Secured password (CHAP-MD5)
N//     <i>Request or use Challenge Handshake Authentication
N//     <i>Protocol with MD5 digest algorithm.
N#define PPP_CHAPEN     1
N
N//   </e>
N//   <q>Obtain Client IP address automatically
N//   =========================================
N//   <i> This option only applies when PPP Dial-up is used to dial
N//   <i> to remote PPP Server. If checked, network connection
N//   <i> dynamically obtains an IP address from remote PPP Server.
N#define PPP_GETIP      1
N
N//   <q>Use Default Gateway on remote Network
N//   ========================================
N//   <i> This option only applies when both Ethernet and PPP Dial-up
N//   <i> are used. If checked, data that cannot be sent to local LAN
N//   <i> is forwarded to Dial-up network instead.
N#define PPP_DEFGW      1
N
N//   <o>Async Control Character Map <0x0-0xffffffff>
N//   <i> A bit-map of control characters 0-31, which are
N//   <i> transmitted escaped as a 2 byte sequence.
N//   <i> For XON/XOFF set this value to: 0x000A 0000
N//   <i> Default: 0x00000000
N#define PPP_ACCM       0x00000000
N
N//   <o>LCP Echo Interval in seconds <0-3600>
N//   <i> If no frames are received within this interval, PPP sends an
N//   <i> Echo Request and expects an Echo Response from the peer.
N//   <i> If the response is not received, the link is terminated.
N//   <i> A value of 0 disables the LCP Echo test.
N//   <i> Default: 30
N#define PPP_ECHOTOUT   30
N
N//   <o>Number of Retries <0-20>
N//   <i> How many times PPP will try to retransmit data
N//   <i> before giving up. Increase this value for links
N//   <i> with low baud rates or high latency.
N//   <i> Default: 3
N#define PPP_MAXRETRY   3
N
N//   <o>Retry Timeout in seconds <1-10>
N//   <i> If no response received within this time frame,
N//   <i> PPP module will try to resend the data again.
N//   <i> Default: 2
N#define PPP_RETRYTOUT  2
N
N// </e>
N// <e>SLIP Network Interface
N// ========================
N// <i> Enable or disable SLIP Network Interface
N#define SLIP_ENABLE    0
N
N//   <h>IP Address
N//   =============
N//   <i> Local Static IP Address
N//     <o>Address byte 1 <0-255>
N//     <i> Default: 192
N#define _IP1S          192
N
N//     <o>Address byte 2 <0-255>
N//     <i> Default: 168
N#define _IP2S          168
N
N//     <o>Address byte 3 <0-255>
N//     <i> Default: 225
N#define _IP3S          225
N
N//     <o>Address byte 4 <0-255>
N//     <i> Default: 1
N#define _IP4S          1
N
N//   </h>
N//   <h>Subnet mask
N//   ==============
N//   <i> Local Subnet mask
N//     <o>Mask byte 1 <0-255>
N//     <i> Default: 255
N#define _MSK1S         255
N
N//     <o>Mask byte 2 <0-255>
N//     <i> Default: 255
N#define _MSK2S         255
N
N//     <o>Mask byte 3 <0-255>
N//     <i> Default: 255
N#define _MSK3S         255
N
N//     <o>Mask byte 4 <0-255>
N//     <i> Default: 0
N#define _MSK4S         0
N
N//   </h>
N//   <h>Primary DNS Server
N//   =====================
N//   <i> Primary DNS Server IP Address
N//     <o>Address byte 1 <0-255>
N//     <i> Default: 194
N#define _pDNS1S        194
N
N//     <o>Address byte 2 <0-255>
N//     <i> Default: 25
N#define _pDNS2S        25
N
N//     <o>Address byte 3 <0-255>
N//     <i> Default: 2
N#define _pDNS3S        2
N
N//     <o>Address byte 4 <0-255>
N//     <i> Default: 129
N#define _pDNS4S        129
N
N//   </h>
N//   <h>Secondary DNS Server
N//   =======================
N//   <i> Secondary DNS Server IP Address
N//     <o>Address byte 1 <0-255>
N//     <i> Default: 194
N#define _sDNS1S        194
N
N//     <o>Address byte 2 <0-255>
N//     <i> Default: 25
N#define _sDNS2S        25
N
N//     <o>Address byte 3 <0-255>
N//     <i> Default: 2
N#define _sDNS3S        2
N
N//     <o>Address byte 4 <0-255>
N//     <i> Default: 130
N#define _sDNS4S        130
N
N//   </h>
N//   <q>Use Default Gateway on remote Network
N//   ========================================
N//   <i> This option only applies when both Ethernet and SLIP Dial-up
N//   <i> are used. If checked, data that cannot be sent to local LAN
N//   <i> is forwarded to Dial-up network instead.
N#define SLIP_DEFGW     1
N
N// </e>
N// <e>UDP Sockets
N// ==============
N// <i> Enable or disable UDP Sockets
N#define UDP_ENABLE     1
N
N//   <o>Number of UDP Sockets <1-20>
N//   <i> Number of available UDP sockets
N//   <i> Default: 5
N#define UDP_NUMSOCKS   5
N
N// </e>
N// <e>TCP Sockets
N// ==============
N// <i> Enable or disable TCP Sockets
N#define TCP_ENABLE     1
N
N//   <o>Number of TCP Sockets <1-20>
N//   <i> Number of available TCP sockets
N//   <i> Default: 5
N#define TCP_NUMSOCKS   5
N
N//   <o>Number of Retries <0-20>
N//   <i> How many times TCP module will try to retransmit data
N//   <i> before giving up. Increase this value for high-latency
N//   <i> and low_throughput networks.
N//   <i> Default: 5
N#define TCP_MAXRETRY   5
N
N//   <o>Retry Timeout in seconds <1-10>
N//   <i> If data frame not acknowledged within this time frame,
N//   <i> TCP module will try to resend the data again.
N//   <i> Default: 4
N#define TCP_RETRYTOUT  4
N
N//   <o>Default Connect Timeout in seconds <1-600>
N//   <i> Default TCP Socket Keep Alive timeout. When it expires
N//   <i> with no TCP data frame send, TCP Connection is closed.
N//   <i> Default: 120
N#define TCP_DEFTOUT    120
N
N//   <o>Maximum Segment Size <536-1460>
N//   <i> The Maximum Segment Size specifies the maximum
N//   <i> number of bytes in the TCP segment's Data field.
N//   <i> Default: 1460
N#define TCP_MAXSEGSZ   1460
N
N//   <o>Receive Window Size <536-65535>
N//   <i> Receive Window Size specifies the size of data, 
N//   <i> that the socket is able to buffer in flow-control mode.
N//   <i> Default: 4380
N#define TCP_RECWINSZ   4380
N
N/* TCP fixed timeouts */
N#define TCP_INIT_RETRY_TOUT 1     /* TCP initial Retransmit period in sec.   */
N#define TCP_SYN_RETRY_TOUT  2     /* TCP SYN frame retransmit period in sec. */
N#define TCP_CONRETRY        7     /* Number of retries to establish a conn.  */
N
N// </e>
N// <e>HTTP Server
N// ==============
N// <i> Enable or disable HTTP Server
N#define HTTP_ENABLE    0
N
N//   <o>Number of HTTP Sessions <1-10>
N//   <i> Number of simultaneously active HTTP Sessions.
N//   <i> Default: 3
N#define HTTP_NUMSESS   5
N
N//   <o>Port Number <1-65535>
N//   <i> Listening port number.
N//   <i> Default: 80
N#define HTTP_PORTNUM   80
N
N//   <s.50>Server-Id header
N//   <i> This value is optional. If specified, it overrides 
N//   <i> the default HTTP Server header from the library.
N//   <i> Default: ""
N#define HTTP_SRVID     ""
N
N//   <e>Enable User Authentication
N//     <i> When enabled, the user will have to authenticate
N//     <i> himself by username and password before accessing
N//     <i> any page on this Embedded WEB server.
N#define HTTP_ENAUTH    1
N
N//     <s.20>Authentication Realm
N//     <i> Default: "Embedded WEB Server"
N#define HTTP_AUTHREALM "Embedded WEB Server"
N
N//     <s.15>Authentication Username
N//     <i> Default: "admin"
N#define HTTP_AUTHUSER  "admin"
N
N//     <s.15>Authentication Password
N//     <i> Default: ""
N#define HTTP_AUTHPASSW ""
N
N//   </e>
N// </e>
N// <e>Telnet Server
N// ================
N// <i> Enable or disable Telnet Server
N#define TNET_ENABLE    0
N
N//   <o>Number of Telnet Connections <1-10>
N//   <i> Number of simultaneously active Telnet Connections.
N//   <i> Default: 1
N#define TNET_NUMSESS   2
N
N//   <o>Port Number <1-65535>
N//   <i> Listening port number.
N//   <i> Default: 23
N#define TNET_PORTNUM   23
N
N//   <o>Idle Connection Timeout in seconds <0-3600>
N//   <i> When timeout expires, the connection is closed.
N//   <i> A value of 0 disables disconnection on timeout.
N//   <i> Default: 120
N#define TNET_IDLETOUT  120
N
N//   <q>Disable Echo
N//   <i> When disabled, the server will not echo
N//   <i> characters it receives.
N//   <i> Default: Not disabled
N#define TNET_NOECHO    0
N
N//   <e>Enable User Authentication
N//   <i> When enabled, the user will have to authenticate
N//   <i> himself by username and password before access
N//   <i> to the system is allowed.
N#define TNET_ENAUTH    1
N
N//     <s.15>Authentication Username
N//     <i> Default: "admin"
N#define TNET_AUTHUSER  "admin"
N
N//     <s.15>Authentication Password
N//     <i> Default: ""
N#define TNET_AUTHPASSW ""
N
N//   </e>
N// </e>
N// <e>TFTP Server
N// ==============
N// <i> Enable or disable TFTP Server
N#define TFTP_ENABLE    0
N
N//   <o>Number of TFTP Sessions <1-10>
N//   <i> Number of simultaneously active TFTP Sessions
N//   <i> Default: 1
N#define TFTP_NUMSESS   1
N
N//   <o>Port Number <1-65535>
N//   <i> Listening port number.
N//   <i> Default: 69
N#define TFTP_PORTNUM   69
N
N//   <q>Enable Firewall Support
N//   <i> Use the same Port Number to receive
N//   <i> requests and send answers to clients.
N//   <i> Default: Not Enabled
N#define TFTP_ENFWALL   0
N
N//   <o>Inactive Session Timeout in seconds <5-120>
N//   <i> When timeout expires TFTP Session is closed.
N//   <i> Default: 15
N#define TFTP_DEFTOUT   15
N
N//   <o>Number of Retries <1-10>
N//   <i> How many times TFTP Server will try to
N//   <i> retransmit the data before giving up.
N//   <i> Default: 4
N#define TFTP_MAXRETRY  4
N
N// </e>
N// <e>TFTP Client
N// ==============
N// <i> Enable or disable TFTP Client
N#define TFTPC_ENABLE   0
N
N//   <o>Block Size <128=>128   <256=>256   <512=>512
N//                 <1024=>1024 <1428=>1428
N//   <i> Size of transfer block in bytes.
N//   <i> Default: 512
N#define TFTPC_BLOCKSZ  512
N
N//   <o>Number of Retries <1-10>
N//   <i> How many times TFTP Client will try to
N//   <i> retransmit the data before giving up.
N//   <i> Default: 4
N#define TFTPC_MAXRETRY 4
N
N//   <o>Retry Timeout <2=>200 ms <5=>500 ms <10=>1 sec
N//                    <20=>2 sec <50=>5 sec <100=>10 sec
N//   <i> If data frame not acknowledged within this time frame,
N//   <i> TFTP Client will try to resend the data again.
N//   <i> Default: 500 ms
N#define TFTPC_RETRYTO  5
N
N// </e>
N// <e>FTP Server
N// ==============
N// <i> Enable or disable FTP Server
N#define FTP_ENABLE     0
N
N//   <o>Number of FTP Sessions <1-10>
N//   <i> Number of simultaneously active FTP Sessions
N//   <i> Default: 1
N#define FTP_NUMSESS    3
N
N//   <o>Port Number <1-65535>
N//   <i> Listening port number.
N//   <i> Default: 21
N#define FTP_PORTNUM    21
N
N//   <s.50>Welcome Message
N//   <i> This value is optional. If specified,
N//   <i> it overrides the default welcome message.
N//   <i> Default: ""
N#define FTP_WELMSG     ""
N
N//   <o>Idle Session Timeout in seconds <0-3600>
N//   <i> When timeout expires, the connection is closed.
N//   <i> A value of 0 disables disconnection on timeout.
N//   <i> Default: 120
N#define FTP_IDLETOUT   120
N
N//   <e>Enable User Authentication
N//   <i> When enabled, the user will have to authenticate
N//   <i> himself by username and password before access
N//   <i> to the system is allowed.
N#define FTP_ENAUTH     1
N
N//     <s.15>Authentication Username
N//     <i> Default: "admin"
N#define FTP_AUTHUSER   "admin"
N
N//     <s.15>Authentication Password
N//     <i> Default: ""
N#define FTP_AUTHPASSW  ""
N
N//   </e>
N// </e>
N// <e>FTP Client
N// =============
N// <i> Enable or disable FTP Client
N#define FTPC_ENABLE    0
N
N//     <o>Response Timeout in seconds <1-120>
N//     <i> This is a time for FTP Client to wait for a response from
N//     <i> the Server. If timeout expires, Client aborts operation.
N//     <i> Default: 10
N#define FTPC_DEFTOUT   10
N
N//     <q>Passive mode (PASV)
N//     <i> The client initiates a data connection to the server.
N//     <i> Default: Not passive (Active)
N#define FTPC_PASVMODE  0
N
N// </e>
N// <e>DNS Client
N// =============
N// <i> Enable or disable DNS Client
N#define DNS_ENABLE     0
N
N//     <o>Cache Table size <5-100>
N//     <i> Number of cached DNS host names/IP addresses
N//     <i> Default: 20
N#define DNS_TABSIZE    20
N
N// </e>
N// <e>SMTP Client
N// ==============
N// <i> Enable or disable SMTP Client
N#define SMTP_ENABLE    0
N
N//     <o>Response Timeout in seconds <5-120>
N//     <i> This is a time for SMTP Client to wait for a response from
N//     <i> SMTP Server. If timeout expires, Client aborts operation.
N//     <i> Default: 20
N#define SMTP_DEFTOUT   20
N
N// </e>
N// <e>SNMP Agent
N// =============
N// <i> Enable or disable SNMP Agent
N#define SNMP_ENABLE    0
N
N//   <s.15>Community Name
N//   <i> Defines where an SNMP message is destined for.
N//   <i> Default: "public"
N#define SNMP_COMMUNITY "public"
N
N//   <o>Port Number <1-65535>
N//   <i> Listening port number.
N//   <i> Default: 161
N#define SNMP_PORTNUM   161
N
N//   <o>Trap Port Number <1-65535>
N//   <i> Port number for Trap operations.
N//   <i> Default: 162
N#define SNMP_TRAPPORT  162
N
N//   <h>Trap Server
N//   ==============
N//   <i> Trap Server IP Address
N//   <o>Address byte 1 <0-255>
N//   <i> Default: 192
N#define SNMP_TRAPIP1   192
N
N//   <o>Address byte 2 <0-255>
N//   <i> Default: 168
N#define SNMP_TRAPIP2   168
N
N//   <o>Address byte 3 <0-255>
N//   <i> Default: 0
N#define SNMP_TRAPIP3   0
N
N//   <o>Address byte 4 <0-255>
N//   <i> Default: 100
N#define SNMP_TRAPIP4   1
N
N//   </h>
N// </e>
N// <e>SNTP Client
N// ==============
N// <i> Enable or disable SNTP Client
N#define SNTP_ENABLE    0
N
N//   <q>Broadcast Mode
N//   =================
N//   <i> Enable this option, if you have NTP/SNTP server
N//   <i> on LAN, which is broadcasting NTP time messages.
N//   <i> Disable this option to access public NTP server.
N//   <i> Default: disabled
N#define SNTP_BCMODE    0
N
N//   <h>NTP Server
N//   =============
N//   <i> Server IP Address
N//   <o>Address byte 1 <0-255>
N//   <i> Default: 217
N#define SNTP_SRVIP1    217
N
N//   <o>Address byte 2 <0-255>
N//   <i> Default: 79
N#define SNTP_SRVIP2    79
N
N//   <o>Address byte 3 <0-255>
N//   <i> Default: 179
N#define SNTP_SRVIP3    179
N
N//   <o>Address byte 4 <0-255>
N//   <i> Default: 106
N#define SNTP_SRVIP4    106
N
N//   </h>
N// </e>
N// <e>BSD Socket Interface
N// =======================
N// <i> Enable or disable Berkeley Socket Programming Interface
N#define BSD_ENABLE     1
N
N//   <o>Number of BSD Sockets <1-20>
N//   <i> Number of available Berkeley Sockets
N//   <i> Default: 2
N#define BSD_NUMSOCKS   2
N
N//   <o>Number of Streaming Server Sockets <0-20>
N//   <i> Defines a number of Streaming (TCP) Server sockets,
N//   <i> that listen for an incoming connection from the client.
N//   <i> Default: 1
N#define BSD_SRVSOCKS   1
N
N//   <o>Receive Timeout in seconds <0-600>
N//   <i> A timeout for socket receive in blocking mode.
N//   <i> Timeout value of 0 means indefinite timeout.
N//   <i> Default: 20
N#define BSD_RCVTOUT    20
N
N//   <q>Hostname Resolver
N//   <i> Enable or disable Berkeley style hostname resolver.
N#define BSD_GETHOSTEN  0
N
N// </e>
N//------------- <<< end of configuration section >>> -----------------------
N
N/*----------------------------------------------------------------------------
N *      Fatal Error Handler
N *---------------------------------------------------------------------------*/
N
Nvoid sys_error (ERROR_CODE code) {
N  /* This function is called when a fatal error is encountered. The normal */
N  /* program execution is not possible anymore. Add your crytical error   .*/
N  /* handler code here.                                                    */
N
N  switch (code) {
N    case ERR_MEM_ALLOC:
N      /* Out of memory. */
N      break;
N
N    case ERR_MEM_FREE:
N      /* Trying to release non existing memory block. */
N      break;
N
N    case ERR_MEM_CORRUPT:
N      /* Memory Link pointer is Corrupted. */
N      /* More data written than the size of allocated mem block. */
N      break;
N
N    case ERR_MEM_LOCK:
N      /* Locked Memory management function (alloc/free) re-entered. */
N      /* RTX multithread protection malfunctioning, not implemented */
N      /* or interrupt disable is not functioning correctly. */
N      break;
N
N    case ERR_UDP_ALLOC:
N      /* Out of UDP Sockets. */
N      break;
N
N    case ERR_TCP_ALLOC:
N      /* Out of TCP Sockets. */
N      break;
N
N    case ERR_TCP_STATE:
N      /* TCP State machine in undefined state. */
N      break;
N  }
N
N  /* End-less loop */
N  while (1);
N}
N
N/*----------------------------------------------------------------------------
N *      TCPnet Config Functions
N *---------------------------------------------------------------------------*/
N
N#define  __NET_CONFIG__
N
N#include <Net_lib.c>
L 1 "..\..\RL-ARM\Config\Net_lib.c" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - TCPnet
N *----------------------------------------------------------------------------
N *      Name:    NET_LIB.C
N *      Purpose: TCPnet System Configuration
N *      Rev.:    V4.72
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#pragma thumb
N#pragma O3
N
N/*----------------------------------------------------------------------------
N *      Library for Net_Config.c
N *---------------------------------------------------------------------------*/
N
N#ifdef __NET_CONFIG__
N
N#if (__RTX)
X#if (1)
N  #include "FreeRTOS.h"
L 1 "..\..\FreeRTOS\include\FreeRTOS.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 77 "..\..\FreeRTOS\include\FreeRTOS.h" 2
N
N/*
N * If stdint.h cannot be located then:
N *   + If using GCC ensure the -nostdint options is *not* being used.
N *   + Ensure the project's include path includes the directory in which your
N *     compiler stores stdint.h.
N *   + Set any compiler options necessary for it to support C99, as technically
N *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
N *     other way).
N *   + The FreeRTOS download includes a simple stdint.h definition that can be
N *     used in cases where none is provided by the compiler.  The files only
N *     contains the typedefs required to build FreeRTOS.  Read the instructions
N *     in FreeRTOS/source/stdint.readme for more information.
N */
N#include <stdint.h> /* READ COMMENT ABOVE. */
L 1 "C:\Keil_v5\ARM\ARMCC\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 92 "..\..\FreeRTOS\include\FreeRTOS.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 "..\..\User\FreeRTOSConfig.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE. 
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N 
N /* Ensure stdint is only used by the compiler, and not the assembler. */
N#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)
X#if 0L || 1L || 0L
N #include <stdint.h>
N extern volatile uint32_t ulHighFrequencyTimerTicks;
N#endif
N
N#define configUSE_PREEMPTION		1
N#define configUSE_IDLE_HOOK			0
N#define configUSE_TICK_HOOK			0
N#define configCPU_CLOCK_HZ			( ( unsigned long ) 168000000 )	
N#define configTICK_RATE_HZ			( ( TickType_t ) 1000 )
N#define configMAX_PRIORITIES		( 7 )
N#define configMINIMAL_STACK_SIZE	( ( unsigned short ) 128 )
N#define configTOTAL_HEAP_SIZE		( ( size_t ) ( 30 * 1024 ) )
N#define configMAX_TASK_NAME_LEN		( 16 )
N#define configUSE_TRACE_FACILITY	1
N#define configUSE_16_BIT_TICKS		0
N#define configIDLE_SHOULD_YIELD		1
N#define configUSE_MUTEXES			1
N
N/* Run time and task stats gathering related definitions. */
N#define configGENERATE_RUN_TIME_STATS                1
N#define configUSE_STATS_FORMATTING_FUNCTIONS         1
N#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()     (ulHighFrequencyTimerTicks = 0ul)
N#define portGET_RUN_TIME_COUNTER_VALUE()             ulHighFrequencyTimerTicks
N//#define portALT_GET_RUN_TIME_COUNTER_VALUE           1
N
N/* Co-routine definitions. */
N#define configUSE_CO_ROUTINES 		0
N#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
N
N/* Set the following definitions to 1 to include the API function, or zero
Nto exclude the API function. */
N
N#define INCLUDE_vTaskPrioritySet		1
N#define INCLUDE_uxTaskPriorityGet		1
N#define INCLUDE_vTaskDelete				1
N#define INCLUDE_vTaskCleanUpResources	0
N#define INCLUDE_vTaskSuspend			1
N#define INCLUDE_vTaskDelayUntil			1
N#define INCLUDE_vTaskDelay				1
N
N/* Cortex-M specific definitions. */
N#ifdef __NVIC_PRIO_BITS
S	/* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
S	#define configPRIO_BITS       		__NVIC_PRIO_BITS
N#else
N	#define configPRIO_BITS       		4        /* 15 priority levels */
N#endif
N
N/* The lowest interrupt priority that can be used in a call to a "set priority"
Nfunction. */
N#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY			0x0f
N
N/* The highest interrupt priority that can be used by any interrupt service
Nroutine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
NINTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
NPRIORITY THAN THIS! (higher priorities are lower numeric values. */
N#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY	0x01
N
N/* Interrupt priorities used by the kernel port layer itself.  These are generic
Nto all Cortex-M ports, and do not rely on any particular library functions. */
N#define configKERNEL_INTERRUPT_PRIORITY 		( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
NSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
N#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N	
N/* Normal assert() semantics without relying on the provision of an assert.h
Nheader file. */
N#define configASSERT( x ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }		
N	
N/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
Nstandard names. */
N#define vPortSVCHandler SVC_Handler
N#define xPortPendSVHandler PendSV_Handler
N#define xPortSysTickHandler SysTick_Handler
N
N
N#endif /* FREERTOS_CONFIG_H */
N
L 99 "..\..\FreeRTOS\include\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 "..\..\FreeRTOS\include\projdefs.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/*
N * Defines the prototype to which task functions must conform.  Defined in this
N * file to ensure the type is known before portable.h is included.
N */
Ntypedef void (*TaskFunction_t)( void * );
N
N/* Converts a time in milliseconds to a time in ticks. */
N#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
N
N#define pdFALSE			( ( BaseType_t ) 0 )
N#define pdTRUE			( ( BaseType_t ) 1 )
N
N#define pdPASS			( pdTRUE )
N#define pdFAIL			( pdFALSE )
N#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
N#define errQUEUE_FULL	( ( BaseType_t ) 0 )
N
N/* FreeRTOS error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N/* Macros used for basic data corruption checks. */
N#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
N	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
N#endif
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
N#else
N	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
N#endif
N
N/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
N#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
N#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
N#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
N#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
N#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
N#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
N#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
N#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
N#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
N#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
N#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
N#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
N#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
N#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
N#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
N#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
N#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
N#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
N#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
N#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
N#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
N#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
N#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
N#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
N#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
N#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
N#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
N#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
N#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
N#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
N#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
N#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
N#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
N#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
N#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
N#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
N#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
N#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
N
N/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_LITTLE_ENDIAN	0
N#define pdFREERTOS_BIG_ENDIAN		1
N
N#endif /* PROJDEFS_H */
N
N
N
L 102 "..\..\FreeRTOS\include\FreeRTOS.h" 2
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 "..\..\FreeRTOS\include\portable.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.
NPurely for reasons of backward compatibility the old method is still valid, but
Nto make it clear that new projects should not use it, support for the port
Nspecific constants has been moved into the deprecated_definitions.h header
Nfile. */
N#include "deprecated_definitions.h"
L 1 "..\..\FreeRTOS\include\deprecated_definitions.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef DEPRECATED_DEFINITIONS_H
N#define DEPRECATED_DEFINITIONS_H
N
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.  The
Ndefinitions below remain in the code for backward compatibility only.  New
Nprojects should not use them. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#endif /* DEPRECATED_DEFINITIONS_H */
N
L 88 "..\..\FreeRTOS\include\portable.h" 2
N
N/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
Ndid not result in a portmacro.h header file being included - and it should be
Nincluded here.  In this case the path to the correct portmacro.h header file
Nmust be set in the compiler's include path. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 "..\..\FreeRTOS\portable\RVDS\ARM_CM4F\portmacro.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		char
N#define portFLOAT		float
N#define portDOUBLE		double
N#define portLONG		long
N#define portSHORT		short
N#define portSTACK_TYPE	uint32_t
N#define portBASE_TYPE	long
N
Ntypedef portSTACK_TYPE StackType_t;
Xtypedef uint32_t StackType_t;
Ntypedef long BaseType_t;
Ntypedef unsigned long UBaseType_t;
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef uint16_t TickType_t;
S	#define portMAX_DELAY ( TickType_t ) 0xffff
N#else
N	typedef uint32_t TickType_t;
N	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
N
N	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
N	not need to be guarded with a critical section. */
N	#define portTICK_TYPE_IS_ATOMIC 1
N#endif
N/*-----------------------------------------------------------*/
N
N/* Architecture specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N
N/* Constants used with memory barrier intrinsics. */
N#define portSY_FULL_READ_WRITE		( 15 )
N
N/*-----------------------------------------------------------*/
N
N/* Scheduler utilities. */
N#define portYIELD()																\
N{																				\
N	/* Set a PendSV to request a context switch. */								\
N	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
N																				\
N	/* Barriers are normally not required but do ensure the code is completely	\
N	within the specified behaviour for the architecture. */						\
N	__dsb( portSY_FULL_READ_WRITE );											\
N	__isb( portSY_FULL_READ_WRITE );											\
N}
X#define portYIELD()																{																					 									portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;																													 							__dsb( portSY_FULL_READ_WRITE );												__isb( portSY_FULL_READ_WRITE );											}
N/*-----------------------------------------------------------*/
N
N#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
N#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
N#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
N#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
N/*-----------------------------------------------------------*/
N
N/* Critical section management. */
Nextern void vPortEnterCritical( void );
Nextern void vPortExitCritical( void );
N
N#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
N#define portENABLE_INTERRUPTS()					vPortSetBASEPRI( 0 )
N#define portENTER_CRITICAL()					vPortEnterCritical()
N#define portEXIT_CRITICAL()						vPortExitCritical()
N#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
N#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
N
N/*-----------------------------------------------------------*/
N
N/* Tickless idle/low power functionality. */
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
N#endif
N/*-----------------------------------------------------------*/
N
N/* Port specific optimisations. */
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
N	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
N#endif
N
N#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
X#if 1 == 1
N
N	/* Check the configuration. */
N	#if( configMAX_PRIORITIES > 32 )
X	#if( ( 7 ) > 32 )
S		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
N	#endif
N
N	/* Store/clear the ready priorities in a bit map. */
N	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
N	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
N
N	/*-----------------------------------------------------------*/
N
N	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31 - __clz( ( uxReadyPriorities ) ) )
N
N#endif /* taskRECORD_READY_PRIORITY */
N/*-----------------------------------------------------------*/
N
N/* Task function macros as described on the FreeRTOS.org WEB site.  These are
Nnot necessary for to use this port.  They are defined so the common demo files
N(which build with all the ports) will build. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
N/*-----------------------------------------------------------*/
N
N#ifdef configASSERT
N	void vPortValidateInterruptPriority( void );
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
N#endif
N
N/* portNOP() is not required by this port. */
N#define portNOP()
N
N#ifndef portFORCE_INLINE
N	#define portFORCE_INLINE __forceinline
N#endif
N
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
Xstatic __forceinline void vPortSetBASEPRI( uint32_t ulBASEPRI )
N{
N	__asm
N	{
N		/* Barrier instructions are not used as this function is only used to
N		lower the BASEPRI value. */
N		msr basepri, ulBASEPRI
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortRaiseBASEPRI( void )
Xstatic __forceinline void vPortRaiseBASEPRI( void )
N{
Nuint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulNewBASEPRI = ( 0x01 << (8 - 4) );
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
Xstatic __forceinline uint32_t ulPortRaiseBASEPRI( void )
N{
Nuint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulReturn, ulNewBASEPRI = ( 0x01 << (8 - 4) );
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		mrs ulReturn, basepri
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N
N	return ulReturn;
N}
N/*-----------------------------------------------------------*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTMACRO_H */
N
L 95 "..\..\FreeRTOS\include\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 32
X#if 8 == 32
S	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
N#endif
N
N#if portBYTE_ALIGNMENT == 16
X#if 8 == 16
S	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 "..\..\FreeRTOS\include\mpu_wrappers.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		#define xTaskGenericCreate				MPU_xTaskGenericCreate
S		#define vTaskAllocateMPURegions			MPU_vTaskAllocateMPURegions
S		#define vTaskDelete						MPU_vTaskDelete
S		#define vTaskDelayUntil					MPU_vTaskDelayUntil
S		#define vTaskDelay						MPU_vTaskDelay
S		#define uxTaskPriorityGet				MPU_uxTaskPriorityGet
S		#define vTaskPrioritySet				MPU_vTaskPrioritySet
S		#define eTaskGetState					MPU_eTaskGetState
S		#define vTaskSuspend					MPU_vTaskSuspend
S		#define vTaskResume						MPU_vTaskResume
S		#define vTaskSuspendAll					MPU_vTaskSuspendAll
S		#define xTaskResumeAll					MPU_xTaskResumeAll
S		#define xTaskGetTickCount				MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks			MPU_uxTaskGetNumberOfTasks
S		#define vTaskList						MPU_vTaskList
S		#define vTaskGetRunTimeStats			MPU_vTaskGetRunTimeStats
S		#define vTaskSetApplicationTaskTag		MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag		MPU_xTaskGetApplicationTaskTag
S		#define xTaskCallApplicationTaskHook	MPU_xTaskCallApplicationTaskHook
S		#define uxTaskGetStackHighWaterMark		MPU_uxTaskGetStackHighWaterMark
S		#define xTaskGetCurrentTaskHandle		MPU_xTaskGetCurrentTaskHandle
S		#define xTaskGetSchedulerState			MPU_xTaskGetSchedulerState
S		#define xTaskGetIdleTaskHandle			MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState			MPU_uxTaskGetSystemState
S		#define xTaskGenericNotify				MPU_xTaskGenericNotify
S		#define xTaskNotifyWait					MPU_xTaskNotifyWait
S		#define ulTaskNotifyTake				MPU_ulTaskNotifyTake
S
S		#define xQueueGenericCreate				MPU_xQueueGenericCreate
S		#define xQueueCreateMutex				MPU_xQueueCreateMutex
S		#define xQueueGiveMutexRecursive		MPU_xQueueGiveMutexRecursive
S		#define xQueueTakeMutexRecursive		MPU_xQueueTakeMutexRecursive
S		#define xQueueCreateCountingSemaphore	MPU_xQueueCreateCountingSemaphore
S		#define xQueueGenericSend				MPU_xQueueGenericSend
S		#define xQueueAltGenericSend			MPU_xQueueAltGenericSend
S		#define xQueueAltGenericReceive			MPU_xQueueAltGenericReceive
S		#define xQueueGenericReceive			MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting			MPU_uxQueueMessagesWaiting
S		#define vQueueDelete					MPU_vQueueDelete
S		#define xQueueGenericReset				MPU_xQueueGenericReset
S		#define xQueueCreateSet					MPU_xQueueCreateSet
S		#define xQueueSelectFromSet				MPU_xQueueSelectFromSet
S		#define xQueueAddToSet					MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet				MPU_xQueueRemoveFromSet
S		#define xQueueGetMutexHolder			MPU_xQueueGetMutexHolder
S		#define xQueueGetMutexHolder			MPU_xQueueGetMutexHolder
S
S		#define pvPortMalloc					MPU_pvPortMalloc
S		#define vPortFree						MPU_vPortFree
S		#define xPortGetFreeHeapSize			MPU_xPortGetFreeHeapSize
S		#define vPortInitialiseBlocks			MPU_vPortInitialiseBlocks
S		#define xPortGetMinimumEverFreeHeapSize	MPU_xPortGetMinimumEverFreeHeapSize
S
S		#if configQUEUE_REGISTRY_SIZE > 0
S			#define vQueueAddToRegistry				MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue			MPU_vQueueUnregisterQueue
S		#endif
S
S		#define xTimerCreate					MPU_xTimerCreate
S		#define pvTimerGetTimerID				MPU_pvTimerGetTimerID
S		#define vTimerSetTimerID				MPU_vTimerSetTimerID
S		#define xTimerIsTimerActive				MPU_xTimerIsTimerActive
S		#define xTimerGetTimerDaemonTaskHandle	MPU_xTimerGetTimerDaemonTaskHandle
S		#define xTimerPendFunctionCall			MPU_xTimerPendFunctionCall
S		#define pcTimerGetTimerName				MPU_pcTimerGetTimerName
S		#define xTimerGenericCommand			MPU_xTimerGenericCommand
S
S		#define xEventGroupCreate				MPU_xEventGroupCreate
S		#define xEventGroupWaitBits				MPU_xEventGroupWaitBits
S		#define xEventGroupClearBits			MPU_xEventGroupClearBits
S		#define xEventGroupSetBits				MPU_xEventGroupSetBits
S		#define xEventGroupSync					MPU_xEventGroupSync
S		#define vEventGroupDelete				MPU_vEventGroupDelete
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 134 "..\..\FreeRTOS\include\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;
N#endif
N
N/* Used by heap_5.c. */
Ntypedef struct HeapRegion
N{
N	uint8_t *pucStartAddress;
N	size_t xSizeInBytes;
N} HeapRegion_t;
N
N/*
N * Used to define multiple heap regions for use by heap_5.c.  This function
N * must be called before any calls to pvPortMalloc() - not creating a task,
N * queue, semaphore, mutex, software timer, event group, etc. will result in
N * pvPortMalloc being called.
N *
N * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
N * defines a region of memory that can be used as the heap.  The array is
N * terminated by a HeapRegions_t structure that has a size of 0.  The region
N * with the lowest start address must appear first in the array.
N */
Nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
Xvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
N
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
Nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetMinimumEverFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
XBaseType_t xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint16_t usStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 105 "..\..\FreeRTOS\include\FreeRTOS.h" 2
N
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configMINIMAL_STACK_SIZE
S	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#error Missing definition:  INCLUDE_vTaskPrioritySet must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#error Missing definition:  INCLUDE_uxTaskPriorityGet must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#error Missing definition:  INCLUDE_vTaskDelete must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#error Missing definition:  INCLUDE_vTaskSuspend must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#error Missing definition:  INCLUDE_vTaskDelayUntil must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#error Missing definition:  INCLUDE_vTaskDelay must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#define configUSE_CO_ROUTINES 0
N#endif
N
N#if configUSE_CO_ROUTINES != 0
X#if 0 != 0
S	#ifndef configMAX_CO_ROUTINE_PRIORITIES
S		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
S	#endif
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTimerGetTimerDaemonTaskHandle
N	#define INCLUDE_xTimerGetTimerDaemonTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_pcTaskGetTaskName
N	#define INCLUDE_pcTaskGetTaskName 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
N	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
N	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
N	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
N	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
N	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
S	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
N	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
N	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if ( 16 ) < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef INCLUDE_xEventGroupSetBitFromISR
N	#define INCLUDE_xEventGroupSetBitFromISR 0
N#endif
N
N#ifndef INCLUDE_xTimerPendFunctionCall
N	#define INCLUDE_xTimerPendFunctionCall 0
N#endif
N
N#ifndef configASSERT
S	#define configASSERT( x )
S	#define configASSERT_DEFINED 0
N#else
N	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 0 == 1
S
S	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
S	#endif /* configTIMER_TASK_PRIORITY */
S
S	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
S	#endif /* configTIMER_QUEUE_LENGTH */
S
S	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
S	#endif /* configTIMER_TASK_STACK_DEPTH */
S
N#endif /* configUSE_TIMERS */
N
N#ifndef INCLUDE_xTaskGetSchedulerState
N	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
N	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
S	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
S	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portPRE_TASK_DELETE_HOOK
N	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
N	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 0U < 1 )
N	#define vQueueAddToRegistry( xQueue, pcName )
N	#define vQueueUnregisterQueue( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE uint32_t
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
N	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL()
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE
N	#define traceEVENT_GROUP_CREATE( xEventGroup )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE_FAILED
N	#define traceEVENT_GROUP_CREATE_FAILED()
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_BLOCK
N	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_END
N	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
N	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_END
N	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS
N	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
N	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS
N	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
N	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_DELETE
N	#define traceEVENT_GROUP_DELETE( xEventGroup )
N#endif
N
N#ifndef tracePEND_FUNC_CALL
N	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef tracePEND_FUNC_CALL_FROM_ISR
N	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef traceQUEUE_REGISTRY_ADD
N	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE_BLOCK
N	#define traceTASK_NOTIFY_TAKE_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE
N	#define traceTASK_NOTIFY_TAKE()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT_BLOCK
N	#define traceTASK_NOTIFY_WAIT_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT
N	#define traceTASK_NOTIFY_WAIT()
N#endif
N
N#ifndef traceTASK_NOTIFY
N	#define traceTASK_NOTIFY()
N#endif
N
N#ifndef traceTASK_NOTIFY_FROM_ISR
N	#define traceTASK_NOTIFY_FROM_ISR()
N#endif
N
N#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
N	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
S	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 1 == 1 )
N
N	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
N	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
N
N	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
N	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
N
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
N	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef pvPortMallocAligned
N	#define pvPortMallocAligned( x, puxStackBuffer ) ( ( ( puxStackBuffer ) == NULL ) ? ( pvPortMalloc( ( x ) ) ) : ( puxStackBuffer ) )
N#endif
N
N#ifndef vPortFreeAligned
N	#define vPortFreeAligned( pvBlockToFree ) vPortFree( pvBlockToFree )
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
S	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef configUSE_TIME_SLICING
N	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
N	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_NEWLIB_REENTRANT
N	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
S	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
S	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N#ifndef configUSE_TRACE_FACILITY
S	#define configUSE_TRACE_FACILITY 0
N#endif
N
N#ifndef mtCOVERAGE_TEST_MARKER
N	#define mtCOVERAGE_TEST_MARKER()
N#endif
N
N#ifndef mtCOVERAGE_TEST_DELAY
N	#define mtCOVERAGE_TEST_DELAY()
N#endif
N
N#ifndef portASSERT_IF_IN_ISR
N	#define portASSERT_IF_IN_ISR()
N#endif
N
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
S	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N#ifndef configAPPLICATION_ALLOCATED_HEAP
N	#define configAPPLICATION_ALLOCATED_HEAP 0
N#endif
N
N#ifndef configUSE_TASK_NOTIFICATIONS
N	#define configUSE_TASK_NOTIFICATIONS 1
N#endif
N
N#ifndef portTICK_TYPE_IS_ATOMIC
S	#define portTICK_TYPE_IS_ATOMIC 0
N#endif
N
N#if( portTICK_TYPE_IS_ATOMIC == 0 )
X#if( 1 == 0 )
S	/* Either variables of tick type cannot be read atomically, or
S	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
S	the tick count is returned to the standard critical section macros. */
S	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
S	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
S	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
S	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
N#else
N	/* The tick type can be read atomically, so critical sections used when the
N	tick count is returned can be defined away. */
N	#define portTICK_TYPE_ENTER_CRITICAL()
N	#define portTICK_TYPE_EXIT_CRITICAL()
N	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
N	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
N#endif
N
N/* Definitions to allow backward compatibility with FreeRTOS versions prior to
NV8 if desired. */
N#ifndef configENABLE_BACKWARD_COMPATIBILITY
N	#define configENABLE_BACKWARD_COMPATIBILITY 1
N#endif
N
N#if configENABLE_BACKWARD_COMPATIBILITY == 1
X#if 1 == 1
N	#define eTaskStateGet eTaskGetState
N	#define portTickType TickType_t
N	#define xTaskHandle TaskHandle_t
N	#define xQueueHandle QueueHandle_t
N	#define xSemaphoreHandle SemaphoreHandle_t
N	#define xQueueSetHandle QueueSetHandle_t
N	#define xQueueSetMemberHandle QueueSetMemberHandle_t
N	#define xTimeOutType TimeOut_t
N	#define xMemoryRegion MemoryRegion_t
N	#define xTaskParameters TaskParameters_t
N	#define xTaskStatusType	TaskStatus_t
N	#define xTimerHandle TimerHandle_t
N	#define xCoRoutineHandle CoRoutineHandle_t
N	#define pdTASK_HOOK_CODE TaskHookFunction_t
N	#define portTICK_RATE_MS portTICK_PERIOD_MS
N
N	/* Backward compatibility within the scheduler code only - these definitions
N	are not really required but are included for completeness. */
N	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
N	#define pdTASK_CODE TaskFunction_t
N	#define xListItem ListItem_t
N	#define xList List_t
N#endif /* configENABLE_BACKWARD_COMPATIBILITY */
N
N/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
Nif floating point hardware is otherwise supported by the FreeRTOS port in use.
NThis constant is not supported by all FreeRTOS ports that include floating 
Npoint support. */
N#ifndef configUSE_TASK_FPU_SUPPORT
N	#define configUSE_TASK_FPU_SUPPORT 1
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* INC_FREERTOS_H */
N
L 23 "..\..\RL-ARM\Config\Net_lib.c" 2
N  #include "task.h"
L 1 "..\..\FreeRTOS\include\task.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 "..\..\FreeRTOS\include\list.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
N * If configLIST_VOLATILE is not defined then the preprocessor directives below
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Macros that can be used to place known values within the list structures,
Nthen check that the known values do not get corrupted during the execution of
Nthe application.   These may catch the list data structures being overwritten in
Nmemory.  They will not catch data errors caused by incorrect configuration or
Nuse of FreeRTOS.*/
N#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
X#if( 0 == 0 )
N	/* Define the macros to do nothing. */
N	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
N	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
N	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
N	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
N	#define listTEST_LIST_INTEGRITY( pxList )
N#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
N#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
N
N
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 TickType_t xItemValue;			 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
X	struct xLIST_ITEM *  pxNext;		 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
X	struct xLIST_ITEM *  pxPrevious;	 
N	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;				 
N	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N};
Ntypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;
X	 TickType_t xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM MiniListItem_t;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
X	 UBaseType_t uxNumberOfItems;
N	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
X	ListItem_t *  pxIndex;			 
N	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N} List_t;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
N
N/*
N * Access macro to retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_NEXT listGET_NEXT
N * \ingroup LinkedList
N */
N#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
N
N/*
N * Return the list item that marks the end of the list
N *
N * \page listGET_END_MARKER listGET_END_MARKER
N * \ingroup LinkedList
N */
N#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entry's pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxTCB pxTCB is set to the address of the owner of the next list item.
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NList_t * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the List_t object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
Xvoid vListInitialise( List_t * const pxList ) ;
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
Xvoid vListInitialiseItem( ListItem_t * const pxItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pvIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pvIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pvIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pvIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
NUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
XUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 79 "..\..\FreeRTOS\include\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V8.2.3"
N#define tskKERNEL_VERSION_MAJOR 8
N#define tskKERNEL_VERSION_MINOR 2
N#define tskKERNEL_VERSION_BUILD 3
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an TaskHandle_t variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup TaskHandle_t TaskHandle_t
N * \ingroup Tasks
N */
Ntypedef void * TaskHandle_t;
N
N/*
N * Defines the prototype to which the application task hook function must
N * conform.
N */
Ntypedef BaseType_t (*TaskHookFunction_t)( void * );
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N} eTaskState;
N
N/* Actions that can be performed when vTaskNotify() is called. */
Ntypedef enum
N{
N	eNoAction = 0,				/* Notify the task without updating its notify value. */
N	eSetBits,					/* Set bits in the task's notification value. */
N	eIncrement,					/* Increment the task's notification value. */
N	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
N	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
N} eNotifyAction;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	BaseType_t xOverflowCount;
N	TickType_t xTimeOnEntering;
N} TimeOut_t;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	uint32_t ulLengthInBytes;
N	uint32_t ulParameters;
N} MemoryRegion_t;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMETERS
N{
N	TaskFunction_t pvTaskCode;
N	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	uint16_t usStackDepth;
N	void *pvParameters;
N	UBaseType_t uxPriority;
N	StackType_t *puxStackBuffer;
N	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	MemoryRegion_t xRegions[ 1 ];
N} TaskParameters_t;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
N	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	UBaseType_t xTaskNumber;		/* A number unique to the task. */
N	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
N	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
N	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
N	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} TaskStatus_t;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N
N/**
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
N0 to generate more optimal code when configASSERT() is defined as the constant
Nis used in assert() statements. */
N#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
N#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
N#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
N
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreate(
N							  TaskFunction_t pvTaskCode,
N							  const char * const pcName,
N							  uint16_t usStackDepth,
N							  void *pvParameters,
N							  UBaseType_t uxPriority,
N							  TaskHandle_t *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static uint8_t ucParameterToPass;
N TaskHandle_t xHandle = NULL;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N     configASSERT( xHandle );
N
N	 // Use the handle to delete the task.
N     if( xHandle != NULL )
N     {
N	     vTaskDelete( xHandle );
N     }
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#define xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask ) xTaskGenericCreate( ( pvTaskCode ), ( pcName ), ( usStackDepth ), ( pvParameters ), ( uxPriority ), ( pxCreatedTask ), ( NULL ), ( NULL ) )
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#define xTaskCreateRestricted( x, pxCreatedTask ) xTaskGenericCreate( ((x)->pvTaskCode), ((x)->pcName), ((x)->usStackDepth), ((x)->pvParameters), ((x)->uxPriority), (pxCreatedTask), ((x)->puxStackBuffer), ((x)->xRegions) )
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an MemoryRegion_t structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of MemoryRegion_t structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernel's management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( TaskHandle_t xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a periodic task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( const TickType_t xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by periodic
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N TickType_t xLastWakeTime;
N const TickType_t xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
NUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
N *
N * A version of uxTaskPriorityGet() that can be used from an ISR.
N */
NUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with its priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( TaskHandle_t xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * xTaskResumeFromISR() should not be used to synchronise a task with an
N * interrupt if there is a chance that the interrupt could arrive prior to the
N * task being suspended - as this can lead to interrupts being missed. Use of a
N * semaphore as a synchronisation mechanism would avoid this eventuality.
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * @return pdTRUE if resuming the task should result in a context switch,
N * otherwise pdFALSE. This is used by the ISR to determine if a context switch
N * may be required following the ISR.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
N * in place of DOS, implements this function.
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends the scheduler without disabling interrupts.  Context switches will
N * not occur while the scheduler is suspended.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskResumeAll( void );</pre>
N *
N * Resumes scheduler activity after it was suspended by a call to
N * vTaskSuspendAll().
N *
N * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
N * that were previously suspended by a call to vTaskSuspend().
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
NBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeAll( void ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that TickType_t is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
NUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQuery.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be
N * set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available.
N *
N * \defgroup pcTaskGetTaskName pcTaskGetTaskName
N * \ingroup TaskUtils
N */
Nchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) ;  
N
N/**
N * task.h
N * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in words, so
N * actual spaces on the stack rather than bytes) since the task referenced by
N * xTask was created.
N */
NUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include task.h before
NFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X#if( 0 > 0 )
S
S	/* Each task contains an array of pointers that is dimensioned by the
S	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
S	kernel does not use the pointers itself, so the application writer can use
S	the pointers for any purpose they wish.  The following two functions are
S	used to set and query a pointer respectively. */
S	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
S	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/**
N * task.h
N * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.  The return value is the value returned by the task hook function
N * registered by the user.
N */
NBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetIdleTaskHandle( void ) ;
N
N/**
N * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
N * the system.  TaskStatus_t structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the TaskStatus_t structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
N * The array must contain at least one TaskStatus_t structure for each task
N * that is under the control of the RTOS.  The number of tasks under the control
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of TaskStatus_t structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of TaskStatus_t structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( char *pcWriteBuffer )
N	{
N	TaskStatus_t *pxTaskStatusArray;
N	volatile UBaseType_t uxArraySize, x;
N	uint32_t ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxTaskGetNumberOfTasks();
N
N		// Allocate a TaskStatus_t structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
NUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ASCII form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskList( char * pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ASCII form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N *  pulPreviousNotificationValue -
N *  Can be used to pass out the subject task's notification value before any
N *  bits are modified by the notify function.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
N#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
N#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotify() that can be used from an interrupt service routine
N * (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
N * be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
N#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
N#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
N * will be cleared in the calling task's notification value before the task
N * checks to see if any notifications are pending, and optionally blocks if no
N * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
N * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
N * the effect of resetting the task's notification value to 0.  Setting
N * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
N *
N * @param ulBitsToClearOnExit If a notification is pending or received before
N * the calling task exits the xTaskNotifyWait() function then the task's
N * notification value (see the xTaskNotify() API function) is passed out using
N * the pulNotificationValue parameter.  Then any bits that are set in
N * ulBitsToClearOnExit will be cleared in the task's notification value (note
N * *pulNotificationValue is set before any bits are cleared).  Setting
N * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
N * (if limits.h is not included) will have the effect of resetting the task's
N * notification value to 0 before the function exits.  Setting
N * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
N * when the function exits (in which case the value passed out in
N * pulNotificationValue will match the task's notification value).
N *
N * @param pulNotificationValue Used to pass the task's notification value out
N * of the function.  Note the value passed out will not be effected by the
N * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for a notification to be received, should a notification
N * not already be pending when xTaskNotifyWait() was called.  The task
N * will not consume any processing time while it is in the Blocked state.  This
N * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
N * used to convert a time specified in milliseconds to a time specified in
N * ticks.
N *
N * @return If a notification was received (including notifications that were
N * already pending when xTaskNotifyWait was called) then pdPASS is
N * returned.  Otherwise pdFAIL is returned.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * xTaskNotifyGive() is a helper macro intended for use when task notifications
N * are used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
N * the equivalent action that instead uses a task notification is
N * xTaskNotifyGive().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
N * eAction parameter set to eIncrement - so pdPASS is always returned.
N *
N * \defgroup xTaskNotifyGive xTaskNotifyGive
N * \ingroup TaskNotifications
N */
N#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
N
N/**
N * task. h
N * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotifyGive() that can be called from an interrupt service
N * routine (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * vTaskNotifyGiveFromISR() is intended for use when task notifications are
N * used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given from an ISR using the
N * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
N * a task notification is vTaskNotifyGiveFromISR().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
N * should be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
Nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
Xvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N/**
N * task. h
N * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * ulTaskNotifyTake() is intended for use when a task notification is used as a
N * faster and lighter weight binary or counting semaphore alternative.  Actual
N * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
N * equivalent action that instead uses a task notification is
N * ulTaskNotifyTake().
N *
N * When a task is using its notification value as a binary or counting semaphore
N * other tasks should send notifications to it using the xTaskNotifyGive()
N * macro, or xTaskNotify() function with the eAction parameter set to
N * eIncrement.
N *
N * ulTaskNotifyTake() can either clear the task's notification value to
N * zero on exit, in which case the notification value acts like a binary
N * semaphore, or decrement the task's notification value on exit, in which case
N * the notification value acts like a counting semaphore.
N *
N * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
N * the task's notification value to be non-zero.  The task does not consume any
N * CPU time while it is in the Blocked state.
N *
N * Where as xTaskNotifyWait() will return when a notification is pending,
N * ulTaskNotifyTake() will return when the task's notification value is
N * not zero.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
N * notification value is decremented when the function exits.  In this way the
N * notification value acts like a counting semaphore.  If xClearCountOnExit is
N * not pdFALSE then the task's notification value is cleared to zero when the
N * function exits.  In this way the notification value acts like a binary
N * semaphore.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for the task's notification value to be greater than zero,
N * should the count not already be greater than zero when
N * ulTaskNotifyTake() was called.  The task will not consume any processing
N * time while it is in the Blocked state.  This is specified in kernel ticks,
N * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
N * specified in milliseconds to a time specified in ticks.
N *
N * @return The task's notification count before it is either cleared to zero or
N * decremented (see the xClearCountOnExit parameter).
N *
N * \defgroup ulTaskNotifyTake ulTaskNotifyTake
N * \ingroup TaskNotifications
N */
Nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
N *
N * If the notification state of the task referenced by the handle xTask is
N * eNotified, then set the task's notification state to eNotWaitingNotification.
N * The task's notification value is not altered.  Set xTask to NULL to clear the
N * notification state of the calling task.
N *
N * @return pdTRUE if the task's notification state was set to
N * eNotWaitingNotification, otherwise pdFALSE.
N * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * The 'unordered' version replaces the event list item value with the
N * xItemValue value, and inserts the list item at the end of the list.
N *
N * The 'ordered' version uses the existing event list item value (which is the
N * owning tasks priority) to insert the list item into the event list is task
N * priority order.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xItemValue The item value to use for the event list item when the
N * event list is not ordered by task priority.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N */
Nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called
N * if either an event occurs to unblock a task, or the block timeout period
N * expires.
N *
N * xTaskRemoveFromEventList() is used when the event list is in task priority
N * order.  It removes the list item from the head of the event list as that will
N * have the highest priority owning task of all the tasks on the event list.
N * xTaskRemoveFromUnorderedEventList() is used when the event list is not
N * ordered and the event list items hold something other than the owning tasks
N * priority.  In this case the event list item value is updated to the value
N * passed in the xItemValue parameter.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
NBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
N * THE EVENT BITS MODULE.
N */
NTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
XTickType_t uxTaskResetEventItemValue( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
NBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Generic version of the task creation function which is in turn called by the
N * xTaskCreate() and xTaskCreateRestricted() macros.
N */
NBaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XBaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) ;  
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
NUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
N
N/*
N * Set the uxTaskNumber of the task referenced by the xTask parameter to
N * uxHandle.
N */
Nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
N
N/*
N * Only available when configUSE_TICKLESS_IDLE is set to 1.
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by a time
N * equal to the idle period.
N */
Nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
Xvoid vTaskStepTick( const TickType_t xTicksToJump ) ;
N
N/*
N * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
XeSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
N
N/*
N * For internal use only.  Increment the mutex held count when a mutex is
N * taken and return the handle of the task that has taken the mutex.
N */
Nvoid *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
Xvoid *pvTaskIncrementMutexHeldCount( void ) ;
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 24 "..\..\RL-ARM\Config\Net_lib.c" 2
N  #include "queue.h"
L 1 "..\..\FreeRTOS\include\queue.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef QUEUE_H
N#define QUEUE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * Type by which queues are referenced.  For example, a call to xQueueCreate()
N * returns an QueueHandle_t variable that can then be used as a parameter to
N * xQueueSend(), xQueueReceive(), etc.
N */
Ntypedef void * QueueHandle_t;
N
N/**
N * Type by which queue sets are referenced.  For example, a call to
N * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
N * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
N */
Ntypedef void * QueueSetHandle_t;
N
N/**
N * Queue sets can contain both queues and semaphores, so the
N * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
N * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
N */
Ntypedef void * QueueSetMemberHandle_t;
N
N/* For internal use only. */
N#define	queueSEND_TO_BACK		( ( BaseType_t ) 0 )
N#define	queueSEND_TO_FRONT		( ( BaseType_t ) 1 )
N#define queueOVERWRITE			( ( BaseType_t ) 2 )
N
N/* For internal use only.  These definitions *must* match those in queue.c. */
N#define queueQUEUE_TYPE_BASE				( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_SET					( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_MUTEX 				( ( uint8_t ) 1U )
N#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( ( uint8_t ) 2U )
N#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( ( uint8_t ) 3U )
N#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( ( uint8_t ) 4U )
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreate(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize
N						  );
N * </pre>
N *
N * Creates a new queue instance.  This allocates the storage required by the
N * new queue and returns a handle for the queue.
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @return If the queue is successfully create then a handle to the newly
N * created queue is returned.  If the queue cannot be created then 0 is
N * returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N	if( xQueue1 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue2 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreate xQueueCreate
N * \ingroup QueueManagement
N */
N#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( uxQueueLength, uxItemSize, queueQUEUE_TYPE_BASE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToToFront(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the front of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBack(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the back of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the queue
N * is full.  The  time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSend(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  TickType_t xTicksToWait
N						 );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().  It is included for
N * backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
N * equivalent to xQueueSendToBack().
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwrite(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue
N						 );
N * </pre>
N *
N * Only for use with queues that have a length of one - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * This function must not be called from an interrupt service routine.
N * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle of the queue to which the data is being sent.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
N * therefore has the same return values as xQueueSendToFront().  However, pdPASS
N * is the only value that can be returned because xQueueOverwrite() will write
N * to the queue even when the queue is already full.
N *
N * Example usage:
N   <pre>
N
N void vFunction( void *pvParameters )
N {
N QueueHandle_t xQueue;
N uint32_t ulVarToSend, ulValReceived;
N
N	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwrite() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N
N	// Write the value 10 to the queue using xQueueOverwrite().
N	ulVarToSend = 10;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// Peeking the queue should now return 10, but leave the value 10 in
N	// the queue.  A block time of zero is used as it is known that the
N	// queue holds a value.
N	ulValReceived = 0;
N	xQueuePeek( xQueue, &ulValReceived, 0 );
N
N	if( ulValReceived != 10 )
N	{
N		// Error unless the item was removed by a different task.
N	}
N
N	// The queue is still full.  Use xQueueOverwrite() to overwrite the
N	// value held in the queue with 100.
N	ulVarToSend = 100;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// This time read from the queue, leaving the queue empty once more.
N	// A block time of 0 is used again.
N	xQueueReceive( xQueue, &ulValReceived, 0 );
N
N	// The value read should be the last value written, even though the
N	// queue was already full when the value was written.
N	if( ulValReceived != 100 )
N	{
N		// Error!
N	}
N
N	// ...
N}
N </pre>
N * \defgroup xQueueOverwrite xQueueOverwrite
N * \ingroup QueueManagement
N */
N#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSend(
N									QueueHandle_t xQueue,
N									const void * pvItemToQueue,
N									TickType_t xTicksToWait
N									BaseType_t xCopyPosition
N								);
N * </pre>
N *
N * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
N * xQueueSendToBack() are used in place of calling this function directly.
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeek(
N							 QueueHandle_t xQueue,
N							 void *pvBuffer,
N							 TickType_t xTicksToWait
N						 );</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * This macro must not be used in an interrupt service routine.  See
N * xQueuePeekFromISR() for an alternative that can be called from an interrupt
N * service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
N * is empty.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to peek the data from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Peek a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask, but the item still remains on the queue.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueuePeek( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeekFromISR(
N									QueueHandle_t xQueue,
N									void *pvBuffer,
N								);</pre>
N *
N * A version of xQueuePeek() that can be called from an interrupt service
N * routine (ISR).
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * \defgroup xQueuePeekFromISR xQueuePeekFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
XBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceive(
N								 QueueHandle_t xQueue,
N								 void *pvBuffer,
N								 TickType_t xTicksToWait
N							);</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * Successfully received items are removed from the queue.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 xQueueReceive() will return immediately if xTicksToWait
N * is zero and the queue is empty.  The time is defined in tick periods so the
N * constant portTICK_PERIOD_MS should be used to convert to real time if this is
N * required.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericReceive(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   TickType_t	xTicksToWait
N									   BaseType_t	xJustPeek
N									);</pre>
N *
N * It is preferred that the macro xQueueReceive() be used rather than calling
N * this function directly.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueueGenericReceive() will return immediately if the queue is empty and
N * xTicksToWait is 0.
N *
N * @param xJustPeek When set to true, the item received from the queue is not
N * actually removed from the queue - meaning a subsequent call to
N * xQueueReceive() will return the same item.  When set to false, the item
N * being received from the queue is also removed from the queue.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of messages stored in a queue.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of messages available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of free spaces available in a queue.  This is equal to the
N * number of items that can be sent to the queue before the queue becomes full
N * if no items are removed.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of spaces available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
N *
N * Delete a queue - freeing all the memory allocated for storing of items
N * placed on the queue.
N *
N * @param xQueue A handle to the queue to be deleted.
N *
N * \defgroup vQueueDelete vQueueDelete
N * \ingroup QueueManagement
N */
Nvoid vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xvoid vQueueDelete( QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToFrontFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the front of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPrioritTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBackFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the back of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwriteFromISR(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  BaseType_t *pxHigherPriorityTaskWoken
N						 );
N * </pre>
N *
N * A version of xQueueOverwrite() that can be used in an interrupt service
N * routine (ISR).
N *
N * Only for use with queues that can hold a single item - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return xQueueOverwriteFromISR() is a macro that calls
N * xQueueGenericSendFromISR(), and therefore has the same return values as
N * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
N * returned because xQueueOverwriteFromISR() will write to the queue even when
N * the queue is already full.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N void vFunction( void *pvParameters )
N {
N 	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwriteFromISR() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N}
N
Nvoid vAnInterruptHandler( void )
N{
N// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
NBaseType_t xHigherPriorityTaskWoken = pdFALSE;
Nuint32_t ulVarToSend, ulValReceived;
N
N	// Write the value 10 to the queue using xQueueOverwriteFromISR().
N	ulVarToSend = 10;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// The queue is full, but calling xQueueOverwriteFromISR() again will still
N	// pass because the value held in the queue will be overwritten with the
N	// new value.
N	ulVarToSend = 100;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// Reading from the queue will now return 100.
N
N	// ...
N
N	if( xHigherPrioritytaskWoken == pdTRUE )
N	{
N		// Writing to the queue caused a task to unblock and the unblocked task
N		// has a priority higher than or equal to the priority of the currently
N		// executing task (the task this interrupt interrupted).  Perform a context
N		// switch so this interrupt returns directly to the unblocked task.
N		portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
N	}
N}
N </pre>
N * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
N * \ingroup QueueManagement
N */
N#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendFromISR(
N									 QueueHandle_t xQueue,
N									 const void *pvItemToQueue,
N									 BaseType_t *pxHigherPriorityTaskWoken
N								);
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().  It is included
N * for backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
N * macros.
N *
N * Post an item to the back of a queue.  It is safe to use this function from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		// Actual macro used here is port specific.
N		portYIELD_FROM_ISR ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSendFromISR(
N										   QueueHandle_t		xQueue,
N										   const	void	*pvItemToQueue,
N										   BaseType_t	*pxHigherPriorityTaskWoken,
N										   BaseType_t	xCopyPosition
N									   );
N </pre>
N *
N * It is preferred that the macros xQueueSendFromISR(),
N * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
N * of calling this function directly.  xQueueGiveFromISR() is an
N * equivalent for use by semaphores that don't actually copy any data.
N *
N * Post an item on a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWokenByPost;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWokenByPost = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post each byte.
N		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.  Note that the
N	// name of the yield function required is port specific.
N	if( xHigherPriorityTaskWokenByPost )
N	{
N		taskYIELD_YIELD_FROM_ISR();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;
NBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceiveFromISR(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   BaseType_t *pxTaskWoken
N								   );
N * </pre>
N *
N * Receive an item from a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param pxTaskWoken A task may be blocked waiting for space to become
N * available on the queue.  If xQueueReceiveFromISR causes such a task to
N * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
N * remain unchanged.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N // Function to create a queue and post some values.
N void vAFunction( void *pvParameters )
N {
N char cValueToPost;
N const TickType_t xTicksToWait = ( TickType_t )0xff;
N
N	// Create a queue capable of containing 10 characters.
N	xQueue = xQueueCreate( 10, sizeof( char ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Post some characters that will be used within an ISR.  If the queue
N	// is full then this task will block for xTicksToWait ticks.
N	cValueToPost = 'a';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N	cValueToPost = 'b';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N
N	// ... keep posting characters ... this task may block when the queue
N	// becomes full.
N
N	cValueToPost = 'c';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N }
N
N // ISR that outputs all the characters received on the queue.
N void vISR_Routine( void )
N {
N BaseType_t xTaskWokenByReceive = pdFALSE;
N char cRxedChar;
N
N	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
N	{
N		// A character was received.  Output the character now.
N		vOutputCharacter( cRxedChar );
N
N		// If removing the character from the queue woke the task that was
N		// posting onto the queue cTaskWokenByReceive will have been set to
N		// pdTRUE.  No matter how many times this loop iterates only one
N		// task will be woken.
N	}
N
N	if( cTaskWokenByPost != ( char ) pdFALSE;
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/*
N * Utilities to query queues that are safe to use from an ISR.  These utilities
N * should be used only from witin an ISR, or within a critical section.
N */
NBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
NBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
NUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;
N
N
N/*
N * xQueueAltGenericSend() is an alternative version of xQueueGenericSend().
N * Likewise xQueueAltGenericReceive() is an alternative version of
N * xQueueGenericReceive().
N *
N * The source code that implements the alternative (Alt) API is much
N * simpler	because it executes everything from within a critical section.
N * This is	the approach taken by many other RTOSes, but FreeRTOS.org has the
N * preferred fully featured API too.  The fully featured API has more
N * complex	code that takes longer to execute, but makes much less use of
N * critical sections.  Therefore the alternative API sacrifices interrupt
N * responsiveness to gain execution speed, whereas the fully featured API
N * sacrifices execution speed to ensure better interrupt responsiveness.
N */
NBaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition ) ;
NBaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking ) ;
N#define xQueueAltSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueAltGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N#define xQueueAltSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueAltGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N#define xQueueAltReceive( xQueue, pvBuffer, xTicksToWait ) xQueueAltGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N#define xQueueAltPeek( xQueue, pvBuffer, xTicksToWait ) xQueueAltGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/*
N * The functions defined above are for passing data to and from tasks.  The
N * functions below are the equivalents for passing data to and from
N * co-routines.
N *
N * These functions are called from the co-routine macro implementation and
N * should not be called directly from application code.  Instead use the macro
N * wrappers defined within croutine.h.
N */
NBaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
NBaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
NBaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
NBaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
N
N/*
N * For internal use only.  Use xSemaphoreCreateMutex(),
N * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
N * these functions directly.
N */
NQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
NQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
Nvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
Xvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
N
N/*
N * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
N * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
N */
NBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
NBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;
N
N/*
N * Reset a queue back to its original empty state.  The return value is now
N * obsolete and is always set to pdPASS.
N */
N#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger.  If you are not using a kernel
N * aware debugger then this function can be ignored.
N *
N * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
N * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
N * within FreeRTOSConfig.h for the registry to be available.  Its value
N * does not effect the number of queues, semaphores and mutexes that can be
N * created - just the number that the registry can hold.
N *
N * @param xQueue The handle of the queue being added to the registry.  This
N * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
N * handles can also be passed in here.
N *
N * @param pcName The name to be associated with the handle.  This is the
N * name that the kernel aware debugger will display.  The queue registry only
N * stores a pointer to the string - so the string must be persistent (global or
N * preferably in ROM/Flash), not on the stack.
N */
N#if configQUEUE_REGISTRY_SIZE > 0
X#if 0U > 0
S	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
N * remove the queue, semaphore or mutex from the register.  If you are not using
N * a kernel aware debugger then this function can be ignored.
N *
N * @param xQueue The handle of the queue being removed from the registry.
N */
N#if configQUEUE_REGISTRY_SIZE > 0
X#if 0U > 0
S	void vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * Generic version of the queue creation function, which is in turn called by
N * any queue, semaphore or mutex creation function or macro.
N */
NQueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
N
N/*
N * Queue sets provide a mechanism to allow a task to block (pend) on a read
N * operation from multiple queues or semaphores simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * A queue set must be explicitly created using a call to xQueueCreateSet()
N * before it can be used.  Once created, standard FreeRTOS queues and semaphores
N * can be added to the set using calls to xQueueAddToSet().
N * xQueueSelectFromSet() is then used to determine which, if any, of the queues
N * or semaphores contained in the set is in a state where a queue read or
N * semaphore take operation would be successful.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  An additional 4 bytes of RAM is required for each space in a every
N * queue added to a queue set.  Therefore counting semaphores that have a high
N * maximum count value should not be added to a queue set.
N *
N * Note 4:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param uxEventQueueLength Queue sets store events that occur on
N * the queues and semaphores contained in the set.  uxEventQueueLength specifies
N * the maximum number of events that can be queued at once.  To be absolutely
N * certain that events are not lost uxEventQueueLength should be set to the
N * total sum of the length of the queues added to the set, where binary
N * semaphores and mutexes have a length of 1, and counting semaphores have a
N * length set by their maximum count value.  Examples:
N *  + If a queue set is to hold a queue of length 5, another queue of length 12,
N *    and a binary semaphore, then uxEventQueueLength should be set to
N *    (5 + 12 + 1), or 18.
N *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
N *    should be set to (1 + 1 + 1 ), or 3.
N *  + If a queue set is to hold a counting semaphore that has a maximum count of
N *    5, and a counting semaphore that has a maximum count of 3, then
N *    uxEventQueueLength should be set to (5 + 3), or 8.
N *
N * @return If the queue set is created successfully then a handle to the created
N * queue set is returned.  Otherwise NULL is returned.
N */
NQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;
XQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;
N
N/*
N * Adds a queue or semaphore to a queue set that was previously created by a
N * call to xQueueCreateSet().
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
N * the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set to which the queue or semaphore
N * is being added.
N *
N * @return If the queue or semaphore was successfully added to the queue set
N * then pdPASS is returned.  If the queue could not be successfully added to the
N * queue set because it is already a member of a different queue set then pdFAIL
N * is returned.
N */
NBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
N * be removed from a set if the queue or semaphore is empty.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
N * from the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set in which the queue or semaphore
N * is included.
N *
N * @return If the queue or semaphore was successfully removed from the queue set
N * then pdPASS is returned.  If the queue was not in the queue set, or the
N * queue (or semaphore) was not empty, then pdFAIL is returned.
N */
NBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * xQueueSelectFromSet() selects from the members of a queue set a queue or
N * semaphore that either contains data (in the case of a queue) or is available
N * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
N * allows a task to block (pend) on a read operation on all the queues and
N * semaphores in a queue set simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueSet The queue set on which the task will (potentially) block.
N *
N * @param xTicksToWait The maximum time, in ticks, that the calling task will
N * remain in the Blocked state (with other tasks executing) to wait for a member
N * of the queue set to be ready for a successful queue read or semaphore take
N * operation.
N *
N * @return xQueueSelectFromSet() will return the handle of a queue (cast to
N * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
N * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
N * in the queue set that is available, or NULL if no such queue or semaphore
N * exists before before the specified block time expires.
N */
NQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;
N
N/*
N * A version of xQueueSelectFromSet() that can be used from an ISR.
N */
NQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;
N
N/* Not public API functions. */
Nvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
NBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
Nvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;
Xvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
NUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
Nuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* QUEUE_H */
N
L 25 "..\..\RL-ARM\Config\Net_lib.c" 2
N  #include "semphr.h"
L 1 "..\..\FreeRTOS\include\semphr.h" 1
N/*
N    FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef SEMAPHORE_H
N#define SEMAPHORE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include semphr.h"
N#endif
N
N#include "queue.h"
N
Ntypedef QueueHandle_t SemaphoreHandle_t;
N
N#define semBINARY_SEMAPHORE_QUEUE_LENGTH	( ( uint8_t ) 1U )
N#define semSEMAPHORE_QUEUE_ITEM_LENGTH		( ( uint8_t ) 0U )
N#define semGIVE_BLOCK_TIME					( ( TickType_t ) 0U )
N
N
N/**
N * semphr. h
N * <pre>vSemaphoreCreateBinary( SemaphoreHandle_t xSemaphore )</pre>
N *
N * This old vSemaphoreCreateBinary() macro is now deprecated in favour of the
N * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
N * the vSemaphoreCreateBinary() macro are created in a state such that the
N * first call to 'take' the semaphore would pass, whereas binary semaphores
N * created using xSemaphoreCreateBinary() are created in a state such that the
N * the semaphore must first be 'given' before it can be 'taken'.
N *
N * <i>Macro</i> that implements a semaphore by using the existing queue mechanism.
N * The queue length is 1 as this is a binary semaphore.  The data size is 0
N * as we don't want to actually store any data - we just want to know if the
N * queue is empty or full.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @param xSemaphore Handle to the created semaphore.  Should be of type SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to vSemaphoreCreateBinary ().
N    // This is a macro so pass the variable in directly.
N    vSemaphoreCreateBinary( xSemaphore );
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup vSemaphoreCreateBinary vSemaphoreCreateBinary
N * \ingroup Semaphores
N */
N#define vSemaphoreCreateBinary( xSemaphore )																							\
N	{																																	\
N		( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );	\
N		if( ( xSemaphore ) != NULL )																									\
N		{																																\
N			( void ) xSemaphoreGive( ( xSemaphore ) );																					\
N		}																																\
N	}
X#define vSemaphoreCreateBinary( xSemaphore )																								{																																			( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );			if( ( xSemaphore ) != NULL )																											{																																			( void ) xSemaphoreGive( ( xSemaphore ) );																							}																																	}
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateBinary( void )</pre>
N *
N * The old vSemaphoreCreateBinary() macro is now deprecated in favour of this
N * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
N * the vSemaphoreCreateBinary() macro are created in a state such that the
N * first call to 'take' the semaphore would pass, whereas binary semaphores
N * created using xSemaphoreCreateBinary() are created in a state such that the
N * the semaphore must first be 'given' before it can be 'taken'.
N *
N * Function that creates a semaphore by using the existing queue mechanism.
N * The queue length is 1 as this is a binary semaphore.  The data size is 0
N * as nothing is actually stored - all that is important is whether the queue is
N * empty or full (the binary semaphore is available or not).
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @return Handle to the created semaphore.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to vSemaphoreCreateBinary ().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateBinary();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup vSemaphoreCreateBinary vSemaphoreCreateBinary
N * \ingroup Semaphores
N */
N#define xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )
N
N/**
N * semphr. h
N * <pre>xSemaphoreTake(
N *                   SemaphoreHandle_t xSemaphore,
N *                   TickType_t xBlockTime
N *               )</pre>
N *
N * <i>Macro</i> to obtain a semaphore.  The semaphore must have previously been
N * created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
N * xSemaphoreCreateCounting().
N *
N * @param xSemaphore A handle to the semaphore being taken - obtained when
N * the semaphore was created.
N *
N * @param xBlockTime The time in ticks to wait for the semaphore to become
N * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
N * real time.  A block time of zero can be used to poll the semaphore.  A block
N * time of portMAX_DELAY can be used to block indefinitely (provided
N * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).
N *
N * @return pdTRUE if the semaphore was obtained.  pdFALSE
N * if xBlockTime expired without the semaphore becoming available.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N // A task that creates a semaphore.
N void vATask( void * pvParameters )
N {
N    // Create the semaphore to guard a shared resource.
N    vSemaphoreCreateBinary( xSemaphore );
N }
N
N // A task that uses the semaphore.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xSemaphore != NULL )
N    {
N        // See if we can obtain the semaphore.  If the semaphore is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the semaphore and can now access the
N            // shared resource.
N
N            // ...
N
N            // We have finished accessing the shared resource.  Release the
N            // semaphore.
N            xSemaphoreGive( xSemaphore );
N        }
N        else
N        {
N            // We could not obtain the semaphore and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreTake xSemaphoreTake
N * \ingroup Semaphores
N */
N#define xSemaphoreTake( xSemaphore, xBlockTime )		xQueueGenericReceive( ( QueueHandle_t ) ( xSemaphore ), NULL, ( xBlockTime ), pdFALSE )
N
N/**
N * semphr. h
N * xSemaphoreTakeRecursive(
N *                          SemaphoreHandle_t xMutex,
N *                          TickType_t xBlockTime
N *                        )
N *
N * <i>Macro</i> to recursively obtain, or 'take', a mutex type semaphore.
N * The mutex must have previously been created using a call to
N * xSemaphoreCreateRecursiveMutex();
N *
N * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
N * macro to be available.
N *
N * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * @param xMutex A handle to the mutex being obtained.  This is the
N * handle returned by xSemaphoreCreateRecursiveMutex();
N *
N * @param xBlockTime The time in ticks to wait for the semaphore to become
N * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
N * real time.  A block time of zero can be used to poll the semaphore.  If
N * the task already owns the semaphore then xSemaphoreTakeRecursive() will
N * return immediately no matter what the value of xBlockTime.
N *
N * @return pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime
N * expired without the semaphore becoming available.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xMutex = NULL;
N
N // A task that creates a mutex.
N void vATask( void * pvParameters )
N {
N    // Create the mutex to guard a shared resource.
N    xMutex = xSemaphoreCreateRecursiveMutex();
N }
N
N // A task that uses the mutex.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xMutex != NULL )
N    {
N        // See if we can obtain the mutex.  If the mutex is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTakeRecursive( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the mutex and can now access the
N            // shared resource.
N
N            // ...
N            // For some reason due to the nature of the code further calls to
N			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
N			// code these would not be just sequential calls as this would make
N			// no sense.  Instead the calls are likely to be buried inside
N			// a more complex call structure.
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N
N            // The mutex has now been 'taken' three times, so will not be
N			// available to another task until it has also been given back
N			// three times.  Again it is unlikely that real code would have
N			// these calls sequentially, but instead buried in a more complex
N			// call structure.  This is just for illustrative purposes.
N            xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N
N			// Now the mutex can be taken by other tasks.
N        }
N        else
N        {
N            // We could not obtain the mutex and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreTakeRecursive xSemaphoreTakeRecursive
N * \ingroup Semaphores
N */
N#define xSemaphoreTakeRecursive( xMutex, xBlockTime )	xQueueTakeMutexRecursive( ( xMutex ), ( xBlockTime ) )
N
N
N/*
N * xSemaphoreAltTake() is an alternative version of xSemaphoreTake().
N *
N * The source code that implements the alternative (Alt) API is much
N * simpler	because it executes everything from within a critical section.
N * This is	the approach taken by many other RTOSes, but FreeRTOS.org has the
N * preferred fully featured API too.  The fully featured API has more
N * complex	code that takes longer to execute, but makes much less use of
N * critical sections.  Therefore the alternative API sacrifices interrupt
N * responsiveness to gain execution speed, whereas the fully featured API
N * sacrifices execution speed to ensure better interrupt responsiveness.
N */
N#define xSemaphoreAltTake( xSemaphore, xBlockTime )		xQueueAltGenericReceive( ( QueueHandle_t ) ( xSemaphore ), NULL, ( xBlockTime ), pdFALSE )
N
N/**
N * semphr. h
N * <pre>xSemaphoreGive( SemaphoreHandle_t xSemaphore )</pre>
N *
N * <i>Macro</i> to release a semaphore.  The semaphore must have previously been
N * created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
N * xSemaphoreCreateCounting(). and obtained using sSemaphoreTake().
N *
N * This macro must not be used from an ISR.  See xSemaphoreGiveFromISR () for
N * an alternative which can be used from an ISR.
N *
N * This macro must also not be used on semaphores created using
N * xSemaphoreCreateRecursiveMutex().
N *
N * @param xSemaphore A handle to the semaphore being released.  This is the
N * handle returned when the semaphore was created.
N *
N * @return pdTRUE if the semaphore was released.  pdFALSE if an error occurred.
N * Semaphores are implemented using queues.  An error can occur if there is
N * no space on the queue to post a message - indicating that the
N * semaphore was not first obtained correctly.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Create the semaphore to guard a shared resource.
N    vSemaphoreCreateBinary( xSemaphore );
N
N    if( xSemaphore != NULL )
N    {
N        if( xSemaphoreGive( xSemaphore ) != pdTRUE )
N        {
N            // We would expect this call to fail because we cannot give
N            // a semaphore without first "taking" it!
N        }
N
N        // Obtain the semaphore - don't block if the semaphore is not
N        // immediately available.
N        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 0 ) )
N        {
N            // We now have the semaphore and can access the shared resource.
N
N            // ...
N
N            // We have finished accessing the shared resource so can free the
N            // semaphore.
N            if( xSemaphoreGive( xSemaphore ) != pdTRUE )
N            {
N                // We would not expect this call to fail because we must have
N                // obtained the semaphore to get here.
N            }
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreGive xSemaphoreGive
N * \ingroup Semaphores
N */
N#define xSemaphoreGive( xSemaphore )		xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )
N
N/**
N * semphr. h
N * <pre>xSemaphoreGiveRecursive( SemaphoreHandle_t xMutex )</pre>
N *
N * <i>Macro</i> to recursively release, or 'give', a mutex type semaphore.
N * The mutex must have previously been created using a call to
N * xSemaphoreCreateRecursiveMutex();
N *
N * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
N * macro to be available.
N *
N * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * @param xMutex A handle to the mutex being released, or 'given'.  This is the
N * handle returned by xSemaphoreCreateMutex();
N *
N * @return pdTRUE if the semaphore was given.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xMutex = NULL;
N
N // A task that creates a mutex.
N void vATask( void * pvParameters )
N {
N    // Create the mutex to guard a shared resource.
N    xMutex = xSemaphoreCreateRecursiveMutex();
N }
N
N // A task that uses the mutex.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xMutex != NULL )
N    {
N        // See if we can obtain the mutex.  If the mutex is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the mutex and can now access the
N            // shared resource.
N
N            // ...
N            // For some reason due to the nature of the code further calls to
N			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
N			// code these would not be just sequential calls as this would make
N			// no sense.  Instead the calls are likely to be buried inside
N			// a more complex call structure.
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N
N            // The mutex has now been 'taken' three times, so will not be
N			// available to another task until it has also been given back
N			// three times.  Again it is unlikely that real code would have
N			// these calls sequentially, it would be more likely that the calls
N			// to xSemaphoreGiveRecursive() would be called as a call stack
N			// unwound.  This is just for demonstrative purposes.
N            xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N
N			// Now the mutex can be taken by other tasks.
N        }
N        else
N        {
N            // We could not obtain the mutex and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreGiveRecursive xSemaphoreGiveRecursive
N * \ingroup Semaphores
N */
N#define xSemaphoreGiveRecursive( xMutex )	xQueueGiveMutexRecursive( ( xMutex ) )
N
N/*
N * xSemaphoreAltGive() is an alternative version of xSemaphoreGive().
N *
N * The source code that implements the alternative (Alt) API is much
N * simpler	because it executes everything from within a critical section.
N * This is	the approach taken by many other RTOSes, but FreeRTOS.org has the
N * preferred fully featured API too.  The fully featured API has more
N * complex	code that takes longer to execute, but makes much less use of
N * critical sections.  Therefore the alternative API sacrifices interrupt
N * responsiveness to gain execution speed, whereas the fully featured API
N * sacrifices execution speed to ensure better interrupt responsiveness.
N */
N#define xSemaphoreAltGive( xSemaphore )		xQueueAltGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )
N
N/**
N * semphr. h
N * <pre>
N xSemaphoreGiveFromISR(
N                          SemaphoreHandle_t xSemaphore,
N                          BaseType_t *pxHigherPriorityTaskWoken
N                      )</pre>
N *
N * <i>Macro</i> to  release a semaphore.  The semaphore must have previously been
N * created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().
N *
N * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
N * must not be used with this macro.
N *
N * This macro can be used from an ISR.
N *
N * @param xSemaphore A handle to the semaphore being released.  This is the
N * handle returned when the semaphore was created.
N *
N * @param pxHigherPriorityTaskWoken xSemaphoreGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xSemaphoreGiveFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.
N *
N * Example usage:
N <pre>
N \#define LONG_TIME 0xffff
N \#define TICKS_TO_WAIT	10
N SemaphoreHandle_t xSemaphore = NULL;
N
N // Repetitive task.
N void vATask( void * pvParameters )
N {
N    for( ;; )
N    {
N        // We want this task to run every 10 ticks of a timer.  The semaphore
N        // was created before this task was started.
N
N        // Block waiting for the semaphore to become available.
N        if( xSemaphoreTake( xSemaphore, LONG_TIME ) == pdTRUE )
N        {
N            // It is time to execute.
N
N            // ...
N
N            // We have finished our task.  Return to the top of the loop where
N            // we will block on the semaphore until it is time to execute
N            // again.  Note when using the semaphore for synchronisation with an
N			// ISR in this manner there is no need to 'give' the semaphore back.
N        }
N    }
N }
N
N // Timer ISR
N void vTimerISR( void * pvParameters )
N {
N static uint8_t ucLocalTickCount = 0;
N static BaseType_t xHigherPriorityTaskWoken;
N
N    // A timer tick has occurred.
N
N    // ... Do other time functions.
N
N    // Is it time for vATask () to run?
N	xHigherPriorityTaskWoken = pdFALSE;
N    ucLocalTickCount++;
N    if( ucLocalTickCount >= TICKS_TO_WAIT )
N    {
N        // Unblock the task by releasing the semaphore.
N        xSemaphoreGiveFromISR( xSemaphore, &xHigherPriorityTaskWoken );
N
N        // Reset the count so we release the semaphore again in 10 ticks time.
N        ucLocalTickCount = 0;
N    }
N
N    if( xHigherPriorityTaskWoken != pdFALSE )
N    {
N        // We can force a context switch here.  Context switching from an
N        // ISR uses port specific syntax.  Check the demo task for your port
N        // to find the syntax required.
N    }
N }
N </pre>
N * \defgroup xSemaphoreGiveFromISR xSemaphoreGiveFromISR
N * \ingroup Semaphores
N */
N#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * semphr. h
N * <pre>
N xSemaphoreTakeFromISR(
N                          SemaphoreHandle_t xSemaphore,
N                          BaseType_t *pxHigherPriorityTaskWoken
N                      )</pre>
N *
N * <i>Macro</i> to  take a semaphore from an ISR.  The semaphore must have
N * previously been created with a call to vSemaphoreCreateBinary() or
N * xSemaphoreCreateCounting().
N *
N * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
N * must not be used with this macro.
N *
N * This macro can be used from an ISR, however taking a semaphore from an ISR
N * is not a common operation.  It is likely to only be useful when taking a
N * counting semaphore when an interrupt is obtaining an object from a resource
N * pool (when the semaphore count indicates the number of resources available).
N *
N * @param xSemaphore A handle to the semaphore being taken.  This is the
N * handle returned when the semaphore was created.
N *
N * @param pxHigherPriorityTaskWoken xSemaphoreTakeFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the semaphore was successfully taken, otherwise
N * pdFALSE
N */
N#define xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateMutex( void )</pre>
N *
N * <i>Macro</i> that implements a mutex semaphore by using the existing queue
N * mechanism.
N *
N * Mutexes created using this macro can be accessed using the xSemaphoreTake()
N * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
N * xSemaphoreGiveRecursive() macros should not be used.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See vSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @return xSemaphore Handle to the created mutex semaphore.  Should be of type
N *		SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateMutex();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup vSemaphoreCreateMutex vSemaphoreCreateMutex
N * \ingroup Semaphores
N */
N#define xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )
N
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void )</pre>
N *
N * <i>Macro</i> that implements a recursive mutex by using the existing queue
N * mechanism.
N *
N * Mutexes created using this macro can be accessed using the
N * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
N * xSemaphoreTake() and xSemaphoreGive() macros should not be used.
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See vSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @return xSemaphore Handle to the created mutex semaphore.  Should be of type
N *		SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateRecursiveMutex();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup vSemaphoreCreateMutex vSemaphoreCreateMutex
N * \ingroup Semaphores
N */
N#define xSemaphoreCreateRecursiveMutex() xQueueCreateMutex( queueQUEUE_TYPE_RECURSIVE_MUTEX )
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount )</pre>
N *
N * <i>Macro</i> that creates a counting semaphore by using the existing
N * queue mechanism.
N *
N * Counting semaphores are typically used for two things:
N *
N * 1) Counting events.
N *
N *    In this usage scenario an event handler will 'give' a semaphore each time
N *    an event occurs (incrementing the semaphore count value), and a handler
N *    task will 'take' a semaphore each time it processes an event
N *    (decrementing the semaphore count value).  The count value is therefore
N *    the difference between the number of events that have occurred and the
N *    number that have been processed.  In this case it is desirable for the
N *    initial count value to be zero.
N *
N * 2) Resource management.
N *
N *    In this usage scenario the count value indicates the number of resources
N *    available.  To obtain control of a resource a task must first obtain a
N *    semaphore - decrementing the semaphore count value.  When the count value
N *    reaches zero there are no free resources.  When a task finishes with the
N *    resource it 'gives' the semaphore back - incrementing the semaphore count
N *    value.  In this case it is desirable for the initial count value to be
N *    equal to the maximum count value, indicating that all resources are free.
N *
N * @param uxMaxCount The maximum count value that can be reached.  When the
N *        semaphore reaches this value it can no longer be 'given'.
N *
N * @param uxInitialCount The count value assigned to the semaphore when it is
N *        created.
N *
N * @return Handle to the created semaphore.  Null if the semaphore could not be
N *         created.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N SemaphoreHandle_t xSemaphore = NULL;
N
N    // Semaphore cannot be used before a call to xSemaphoreCreateCounting().
N    // The max value to which the semaphore can count should be 10, and the
N    // initial value assigned to the count should be 0.
N    xSemaphore = xSemaphoreCreateCounting( 10, 0 );
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateCounting xSemaphoreCreateCounting
N * \ingroup Semaphores
N */
N#define xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )
N
N/**
N * semphr. h
N * <pre>void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</pre>
N *
N * Delete a semaphore.  This function must be used with care.  For example,
N * do not delete a mutex type semaphore if the mutex is held by a task.
N *
N * @param xSemaphore A handle to the semaphore to be deleted.
N *
N * \defgroup vSemaphoreDelete vSemaphoreDelete
N * \ingroup Semaphores
N */
N#define vSemaphoreDelete( xSemaphore ) vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) )
N
N/**
N * semphr.h
N * <pre>TaskHandle_t xSemaphoreGetMutexHolder( SemaphoreHandle_t xMutex );</pre>
N *
N * If xMutex is indeed a mutex type semaphore, return the current mutex holder.
N * If xMutex is not a mutex type semaphore, or the mutex is available (not held
N * by a task), return NULL.
N *
N * Note: This is a good way of determining if the calling task is the mutex
N * holder, but not a good way of determining the identity of the mutex holder as
N * the holder may change between the function exiting and the returned value
N * being tested.
N */
N#define xSemaphoreGetMutexHolder( xSemaphore ) xQueueGetMutexHolder( ( xSemaphore ) )
N
N#endif /* SEMAPHORE_H */
N
N
L 26 "..\..\RL-ARM\Config\Net_lib.c" 2
N#endif
N
N/* Non-Critical Net_Config.c upgrade */
N#ifndef HTTP_SRVID
S #define HTTP_SRVID     ""
N#endif
N#ifndef FTP_WELMSG
S #define FTP_WELMSG     ""
N#endif
N#ifndef DHCP_VCID
S #define DHCP_VCID      ""
N#endif
N#ifndef DHCP_BOOTF
S #define DHCP_BOOTF     0
N#endif
N#ifndef DHCP_NTPSRV
S #define DHCP_NTPSRV    0
N#endif
N#ifndef TNET_NOECHO
S #define TNET_NOECHO    0
N#endif
N#ifndef TFTP_ENFWALL
S #define TFTP_ENFWALL   0
N#endif
N#ifndef TCP_MAXSEGSZ
S #define TCP_MAXSEGSZ   1460
N#endif
N#ifndef TCP_RECWINSZ
S #define TCP_RECWINSZ   TCP_DEF_WINSIZE
N#endif
N
N#define TICK_RATE       (1000 / TICK_INTERVAL)
N
N/* Some configuration error checking. */
N#if !(SLIP_ENABLE || PPP_ENABLE || ETH_ENABLE)
X#if !(0 || 0 || 1)
S #error All network interfaces disabled in configuration
N#endif
N
N#if (SLIP_ENABLE && PPP_ENABLE)
X#if (0 && 0)
S #error Both SLIP and PPP interfaces enabled
N#endif
N
N/* Check TCP Socket enable. */
N#if (!TCP_ENABLE & (BSD_ENABLE | HTTP_ENABLE | TNET_ENABLE | FTP_ENABLE | \
N                    FTPC_ENABLE | SMTP_ENABLE))
X#if (!1 & (1 | 0 | 0 | 0 |                     0 | 0))
S #error Application needs TCP Sockets enabled
N#endif
N
N/* Check UDP Socket enable */
N#if (!UDP_ENABLE & (BSD_ENABLE | TFTP_ENABLE | DNS_ENABLE | SNMP_ENABLE | \
N                    SNTP_ENABLE | ((DHCP_ENABLE | NBNS_ENABLE) & ETH_ENABLE)))
X#if (!1 & (1 | 0 | 0 | 0 |                     0 | ((1 | 1) & 1)))
S #error Application needs UDP Sockets enabled
N#endif
N
N/* Check number of TCP sockets available. */
N#define __TCPNS    ((BSD_ENABLE  * BSD_NUMSOCKS)   + \
N                    (HTTP_ENABLE * HTTP_NUMSESS)   + \
N                    (TNET_ENABLE * TNET_NUMSESS)   + \
N                    (FTP_ENABLE  * FTP_NUMSESS*2)  + \
N                    (FTPC_ENABLE * 2)              + \
N                    (SMTP_ENABLE * 1))
X#define __TCPNS    ((BSD_ENABLE  * BSD_NUMSOCKS)   +                     (HTTP_ENABLE * HTTP_NUMSESS)   +                     (TNET_ENABLE * TNET_NUMSESS)   +                     (FTP_ENABLE  * FTP_NUMSESS*2)  +                     (FTPC_ENABLE * 2)              +                     (SMTP_ENABLE * 1))
N
N#if (__TCPNS > TCP_NUMSOCKS)
X#if (((1 * 2) + (0 * 5) + (0 * 2) + (0 * 3*2) + (0 * 2) + (0 * 1)) > 5)
S #error Number of TCP Sockets too small
N#endif
N
N/* Calculate number of UDP sockets needed for TFTP server. */
N#if (TFTP_ENFWALL)
X#if (0)
S #define __TFTP_NSOCKS  1
N#else
N #define __TFTP_NSOCKS  (1 + TFTP_NUMSESS)
N#endif
N
N/* Check number of UDP sockets available. */
N#define __UDPNS    ((BSD_ENABLE  * BSD_NUMSOCKS)   + \
N                    (TFTP_ENABLE * __TFTP_NSOCKS)  + \
N                    (TFTPC_ENABLE* 1)              + \
N                    (DNS_ENABLE  * 1)              + \
N                    (SNMP_ENABLE * 1)              + \
N                    (SNTP_ENABLE * 1)              + \
N                    (DHCP_ENABLE * ETH_ENABLE)     + \
N                    (NBNS_ENABLE * ETH_ENABLE))
X#define __UDPNS    ((BSD_ENABLE  * BSD_NUMSOCKS)   +                     (TFTP_ENABLE * __TFTP_NSOCKS)  +                     (TFTPC_ENABLE* 1)              +                     (DNS_ENABLE  * 1)              +                     (SNMP_ENABLE * 1)              +                     (SNTP_ENABLE * 1)              +                     (DHCP_ENABLE * ETH_ENABLE)     +                     (NBNS_ENABLE * ETH_ENABLE))
N
N#if (__UDPNS > UDP_NUMSOCKS)
X#if (((1 * 2) + (0 * (1 + 1)) + (0* 1) + (0 * 1) + (0 * 1) + (0 * 1) + (1 * 1) + (1 * 1)) > 5)
S #error Number of UDP Sockets too small
N#endif
N
N/* Check BSD Server sockets */
N#if (BSD_ENABLE && (BSD_SRVSOCKS > BSD_NUMSOCKS))
X#if (1 && (1 > 2))
S #error Number of BSD Server sockets too large
N#endif
N
N/* Check BSD Hostname resolver */
N#if (BSD_ENABLE && BSD_GETHOSTEN && !DNS_ENABLE)
X#if (1 && 0 && !0)
S #error BSD Hostname resolver needs DNS enabled
N#endif
N
N/* Check PPP Authentication protocols */
N#if (PPP_ENABLE && PPP_AUTHEN && !(PPP_PAPEN | PPP_CHAPEN))
X#if (0 && 1 && !(1 | 1))
S #error PPP Authentication needs PAP or/and CHAP enabled
N#endif
N
N/* Check Net_Config.c version */
N#if (TNET_ENABLE && !defined(TNET_IDLETOUT))                     || \
N    (FTP_ENABLE  && !defined(FTP_IDLETOUT))                      || \
N    (PPP_ENABLE  && (defined(_ACCM1) || defined(LCP_MAXRETRY)))
X#if (0 && !1L)                     ||     (0  && !1L)                      ||     (0  && (0L || 0L))
S #error Net_Config.c too old, needs update
N#endif
N
N/* Check Maximum Segment Size of TCP Socket */
N#if (TCP_ENABLE && ((TCP_MAXSEGSZ < 536) || (TCP_MAXSEGSZ > 1460)))
X#if (1 && ((1460 < 536) || (1460 > 1460)))
S #error TCP Maximum Segment Size out of range
N#endif
N
N/* Check Receive Window Size of TCP Socket */
N#if (TCP_ENABLE && (TCP_RECWINSZ < TCP_MAXSEGSZ))
X#if (1 && (4380 < 1460))
S #error TCP Receive Window Size too small
N#endif
N
N/* Check Block Size of TFTP Server */
N#if (TFTPC_ENABLE && ((TFTPC_BLOCKSZ < 128) || (TFTPC_BLOCKSZ > 1428)))
X#if (0 && ((512 < 128) || (512 > 1428)))
S #error TFTP Client Block Size out of range
N#endif
N
N/* Local Machine info */
NLOCALM const nlocalm[3] = {
N /* Ethernet: Local IP address */
N#if (ETH_ENABLE)
X#if (1)
N {{_IP1,_IP2,_IP3,_IP4},
X {{192,168,1,100},
N  /* Default Gateway IP address */
N  {_GW1,_GW2,_GW3,_GW4},
X  {192,168,1,1},
N  /* Subnet IP Mask */
N  {_MSK1,_MSK2,_MSK3,_MSK4},
X  {255,255,255,0},
N  /* Primary DNS Server IP */
N  {_pDNS1,_pDNS2,_pDNS3,_pDNS4},
X  {194,25,2,129},
N  /* Secondary DNS Server IP */
N  {_sDNS1,_sDNS2,_sDNS3,_sDNS4}},
X  {194,25,2,130}},
N#else
S {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}},
N#endif
N /* PPP: Local IP address */
N#if (PPP_ENABLE)
X#if (0)
S {{_IP1P,_IP2P,_IP3P,_IP4P},
S  /* Default Gateway IP address */
S  {0,0,0,0},
S  /* Subnet IP Mask */
S  {_MSK1P,_MSK2P,_MSK3P,_MSK4P},
S  /* Primary DNS Server IP */
S  {_pDNS1P,_pDNS2P,_pDNS3P,_pDNS4P},
S  /* Secondary DNS Server IP */
S  {_sDNS1P,_sDNS2P,_sDNS3P,_sDNS4P}},
N#else
N {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}},
N#endif
N /* SLIP: Local IP address */
N#if (SLIP_ENABLE)
X#if (0)
S {{_IP1S,_IP2S,_IP3S,_IP4S},
S  /* Default Gateway IP address */
S  {0,0,0,0},
S  /* Subnet IP Mask */
S  {_MSK1S,_MSK2S,_MSK3S,_MSK4S},
S  /* Primary DNS Server IP */
S  {_pDNS1S,_pDNS2S,_pDNS3S,_pDNS4S},
S  /* Secondary DNS Server IP */
S  {_sDNS1S,_sDNS2S,_sDNS3S,_sDNS4S}}
N#else
N {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}},
N#endif
N};
N/* System configuration */
Nstatic U32 mem_pool[MEM_SIZE];
Xstatic U32 mem_pool[2048];
N       U8  lhost_name[16] = LHOST_NAME;
X       U8  lhost_name[16] = "armfly";
NSYS_CFG sys_config = {
N  mem_pool,
N  sizeof (mem_pool),
N  TICK_RATE,
X  (1000 / 100),
N  TICK_INTERVAL,
X  100,
N  TICK_RATE / 5,
X  (1000 / 100) / 5,
N  (PPP_GETIP<<5   | SLIP_DEFGW<<4 | PPP_DEFGW<<3 |
X  (1<<5   | 1<<4 | 1<<3 |
N   SLIP_ENABLE<<2 | PPP_ENABLE<<1 | ETH_ENABLE),
X   0<<2 | 0<<1 | 1),
N  lhost_name
N};
N/* Ethernet network interface */
N#if (ETH_ENABLE)
X#if (1)
N static ARP_INFO arp_table[ARP_TABSIZE];
X static ARP_INFO arp_table[10];
N U8     own_hw_adr[ETH_ADRLEN] = {_MAC1,_MAC2,_MAC3,_MAC4,_MAC5,_MAC6};
X U8     own_hw_adr[6] = {0x1E,0x30,0x6C,0xA2,0x45,0x5E};
N ARP_CFG arp_config = {
N   arp_table,
N   ARP_TABSIZE,
X   10,
N   ARP_TIMEOUT,
X   150,
N   ARP_MAXRETRY,
X   4,
N   ARP_RESEND,
X   2,
N   ARP_NOTIFY
X   0
N };
N#endif
N#if (PPP_ENABLE)
X#if (0)
S PPP_CFG ppp_config = {
S   PPP_ACCM,
S   5 * TICK_RATE,
S   PPP_RETRYTOUT * TICK_RATE,
S   PPP_ECHOTOUT,
S   PPP_MAXRETRY,
S   ((PPP_CHAPEN << 1) | PPP_PAPEN) * PPP_AUTHEN
S };
N#endif
N#if (SLIP_ENABLE)
X#if (0)
S U16 const slip_SerTout  = 5 * TICK_RATE;
N#endif
N#if (ETH_ENABLE && IGMP_ENABLE)
X#if (1 && 0)
S static IGMP_INFO igmp_table[IGMP_TABSIZE];
S IGMP_CFG  igmp_config = {
S   igmp_table,
S   IGMP_TABSIZE,
S };
N#endif
N#if (ETH_ENABLE && DHCP_ENABLE)
X#if (1 && 1)
N DHCP_CFG dhcp_config = {
N   DHCP_VCID,
X   "",
N   (DHCP_NTPSRV << 1) | DHCP_BOOTF
X   (1 << 1) | 0
N };
N#endif
N#if (UDP_ENABLE)
X#if (1)
N static UDP_INFO udp_scb[UDP_NUMSOCKS];
X static UDP_INFO udp_scb[5];
N UDP_CFG udp_config = {
N   udp_scb,
N   UDP_NUMSOCKS,
X   5,
N };
N#endif
N#if (TCP_ENABLE)
X#if (1)
N static TCP_INFO tcp_scb[TCP_NUMSOCKS];
X static TCP_INFO tcp_scb[5];
N TCP_CFG tcp_config = {
N   tcp_scb,
N   TCP_NUMSOCKS,
X   5,
N   TCP_MAXRETRY,
X   5,
N   TCP_RETRYTOUT * TICK_RATE,
X   4 * (1000 / 100),
N   (200 + TICK_INTERVAL - 1) / TICK_INTERVAL,
X   (200 + 100 - 1) / 100,
N   TCP_SYN_RETRY_TOUT * TICK_RATE,
X   2 * (1000 / 100),
N   TCP_INIT_RETRY_TOUT * TICK_RATE,
X   1 * (1000 / 100),
N   TCP_DEFTOUT,
X   120,
N   TCP_MAXSEGSZ,
X   1460,
N   TCP_RECWINSZ,
X   4380,
N   TCP_CONRETRY
X   7
N };
N#endif
N#if (HTTP_ENABLE)
X#if (0)
S static HTTP_INFO http_scb[HTTP_NUMSESS];
S static U8 http_passw[PASSW_SZ] = HTTP_AUTHPASSW;
S HTTP_CFG  http_config = {
S   http_scb,
S   HTTP_NUMSESS,
S   HTTP_ENAUTH,
S   HTTP_PORTNUM,
S   HTTP_SRVID,
S #if (HTTP_ENAUTH)
S   HTTP_AUTHREALM,
S   HTTP_AUTHUSER,
S   http_passw
S #else
S   "","",""
S #endif
S };
N#endif
N#if (TNET_ENABLE)
X#if (0)
S static TNET_INFO tnet_scb[TNET_NUMSESS];
S static U8 tnet_passw[PASSW_SZ] = TNET_AUTHPASSW;
S TNET_CFG  tnet_config = {
S   tnet_scb,
S   TNET_NUMSESS,
S   TNET_ENAUTH,
S   TNET_NOECHO,
S   TNET_PORTNUM,
S   TNET_IDLETOUT,
S #if (TNET_ENAUTH)
S   TNET_AUTHUSER,
S   tnet_passw
S #else
S   "",""
S #endif
S };
N#endif
N#if (TFTP_ENABLE)
X#if (0)
S static TFTP_INFO tftp_scb[TFTP_NUMSESS];
S TFTP_CFG tftp_config = {
S   &tftp_scb[0],
S   TFTP_NUMSESS,
S   TFTP_MAXRETRY,
S   TFTP_PORTNUM,
S   TFTP_DEFTOUT,
S   TFTP_ENFWALL
S };
N#endif
N#if (TFTPC_ENABLE)
X#if (0)
S TFTPC_CFG tftpc_config = {
S   TFTPC_BLOCKSZ,
S   (TFTPC_RETRYTO * TICK_RATE + 5) / 10,
S   TFTPC_MAXRETRY
S };
N#endif
N#if (FTP_ENABLE)
X#if (0)
S static FTP_INFO ftp_scb[FTP_NUMSESS];
S static U8 ftp_passw[PASSW_SZ] = FTP_AUTHPASSW;
S #define _LS(s)  sizeof(s)-1,s
S FTP_CFG ftp_config = {
S   ftp_scb,
S   FTP_NUMSESS,
S   FTP_ENAUTH,
S   FTP_PORTNUM,
S   FTP_IDLETOUT,
S  _LS(FTP_WELMSG),
S #if (FTP_ENAUTH)
S   FTP_AUTHUSER,
S   ftp_passw
S #else
S   "",""
S #endif
S };
N#endif
N#if (FTPC_ENABLE)
X#if (0)
S FTPC_CFG ftpc_config = {
S   FTPC_DEFTOUT,
S   FTPC_PASVMODE
S };
N#endif
N#if (DNS_ENABLE)
X#if (0)
S static DNS_CACHE dns_table[DNS_TABSIZE];
SDNS_CFG dns_config = {
S   dns_table,
S   DNS_TABSIZE
S };
N#endif
N#if (SMTP_ENABLE)
X#if (0)
S U8 const smtp_DefTout = SMTP_DEFTOUT;
N#endif
N#if (SNMP_ENABLE)
X#if (0)
S SNMP_CFG snmp_config = {
S   SNMP_PORTNUM,
S   SNMP_TRAPPORT,
S   { SNMP_TRAPIP1, SNMP_TRAPIP2, SNMP_TRAPIP3, SNMP_TRAPIP4 },
S   SNMP_COMMUNITY,
S   TICK_INTERVAL / 5
S };
N#endif
N#if (SNTP_ENABLE)
X#if (0)
S SNTP_CFG sntp_config = {
S { SNTP_SRVIP1, SNTP_SRVIP2, SNTP_SRVIP3, SNTP_SRVIP4 },
S SNTP_BCMODE
S };
N#endif
N#if (BSD_ENABLE) 
X#if (1) 
N static BSD_INFO bsd_scb[BSD_NUMSOCKS + BSD_SRVSOCKS];
X static BSD_INFO bsd_scb[2 + 1];
N #ifdef __RTX
N   SemaphoreHandle_t  bsd_mutex = NULL;
X   SemaphoreHandle_t  bsd_mutex = 0;
N   SemaphoreHandle_t  bsd_sem = NULL;
X   SemaphoreHandle_t  bsd_sem = 0;
N  #define BSD_INRTX  __TRUE
N #else
S  #define BSD_INRTX  __FALSE
N #endif
N BSD_CFG bsd_config = {
N   bsd_scb,
N   BSD_NUMSOCKS + BSD_SRVSOCKS,
X   2 + 1,
N   BSD_INRTX,
X   1,
N   BSD_RCVTOUT * TICK_RATE
X   20 * (1000 / 100)
N };
N#endif
N
N/*----------------------------------------------------------------------------
N *      Library Interface
N *---------------------------------------------------------------------------*/
N
N
N/*--------------------------- init_system -----------------------------------*/
N
Nvoid init_system (void) {
N  /* Initialize configured interfaces and applications. */
N	
N#if (ETH_ENABLE)
X#if (1)
N  eth_init_link ();
N#endif
N#if (PPP_ENABLE)
X#if (0)
S  ppp_init_link ();
N#endif
N#if (SLIP_ENABLE)
X#if (0)
S  slip_init_link ();
N#endif
N  ip_init ();
N  icmp_init ();
N#if (ETH_ENABLE && IGMP_ENABLE)
X#if (1 && 0)
S  igmp_init ();
N#endif
N#if (UDP_ENABLE)
X#if (1)
N  udp_init ();
N#endif
N#if (TCP_ENABLE)
X#if (1)
N  tcp_init ();
N#endif
N#if (BSD_ENABLE)
X#if (1)
N  bsd_init ();
N #if (BSD_GETHOSTEN)
X #if (0)
S  bsd_init_host ();
N #endif
N#endif
N#if (HTTP_ENABLE)
X#if (0)
S  http_init ();
N#endif
N#if (TNET_ENABLE)
X#if (0)
S  tnet_init ();
N#endif
N#if (TFTP_ENABLE)
X#if (0)
S  tftp_init ();
N#endif
N#if (TFTPC_ENABLE)
X#if (0)
S  tftpc_init ();
N#endif
N#if (FTP_ENABLE)
X#if (0)
S  ftp_init ();
N#endif
N#if (FTPC_ENABLE)
X#if (0)
S  ftpc_init ();
N#endif
N#if (ETH_ENABLE && NBNS_ENABLE)
X#if (1 && 1)
N  nbns_init ();
N#endif
N#if (ETH_ENABLE && DHCP_ENABLE)
X#if (1 && 1)
N  dhcp_init ();
N#elif (ETH_ENABLE)
S  arp_notify ();
N#endif
N#if (DNS_ENABLE)
X#if (0)
S  dns_init ();
N#endif
N#if (SMTP_ENABLE)
X#if (0)
S  smtp_init ();
N#endif
N#if (SNMP_ENABLE)
X#if (0)
S  snmp_init ();
N#endif
N#if (SNTP_ENABLE)
X#if (0)
S  sntp_init ();
N#endif
N
N#if (BSD_ENABLE && __RTX)
X#if (1 && 1)
N {
N	bsd_mutex = xSemaphoreCreateMutex();
X	bsd_mutex = xQueueCreateMutex( ( ( uint8_t ) 1U ) );
N	if(bsd_mutex == NULL)
X	if(bsd_mutex == 0)
N    {
N        /* ERR */
N    }	 
N	
N	bsd_sem = xSemaphoreCreateBinary();
X	bsd_sem = xQueueGenericCreate( ( UBaseType_t ) 1, ( ( uint8_t ) 0U ), ( ( uint8_t ) 3U ) );
N	if(bsd_sem == NULL)
X	if(bsd_sem == 0)
N    {
N        /* ERR */
N    }
N }
N#endif
N}
N
N
N/*--------------------------- run_system ------------------------------------*/
N
Nvoid run_system (void) {
N  /* Run configured interfaces and applications. */
N
N#if (BSD_ENABLE && __RTX)
X#if (1 && 1)
N	xSemaphoreTake(bsd_mutex, portMAX_DELAY);
X	xQueueGenericReceive( ( QueueHandle_t ) ( bsd_mutex ), 0, ( ( TickType_t ) 0xffffffffUL ), ( ( BaseType_t ) 0 ) );
N#endif
N
N#if (ETH_ENABLE)
X#if (1)
N  eth_run_link ();
N#endif
N#if (PPP_ENABLE)
X#if (0)
S  ppp_run_link ();
N#endif
N#if (SLIP_ENABLE)
X#if (0)
S  slip_run_link ();
N#endif
N  ip_run_local ();
N  icmp_run_engine ();
N#if (ETH_ENABLE && IGMP_ENABLE)
X#if (1 && 0)
S  igmp_run_host ();
N#endif
N#if (TCP_ENABLE)
X#if (1)
N  tcp_poll_sockets ();
N#endif
N#if (BSD_ENABLE)
X#if (1)
N  bsd_poll_sockets ();
N#endif
N#if (HTTP_ENABLE)
X#if (0)
S  http_run_server ();
N#endif
N#if (TNET_ENABLE)
X#if (0)
S  tnet_run_server ();
N#endif
N#if (TFTP_ENABLE)
X#if (0)
S  tftp_run_server ();
N#endif
N#if (TFTPC_ENABLE)
X#if (0)
S  tftpc_run_client ();
N#endif
N#if (FTP_ENABLE)
X#if (0)
S  ftp_run_server ();
N#endif
N#if (FTPC_ENABLE)
X#if (0)
S  ftpc_run_client ();
N#endif
N#if (ETH_ENABLE && DHCP_ENABLE)
X#if (1 && 1)
N  dhcp_run_client ();
N#endif
N#if (DNS_ENABLE)
X#if (0)
S  dns_run_client ();
N#endif
N#if (SMTP_ENABLE)
X#if (0)
S  smtp_run_client ();
N#endif
N#if (SNMP_ENABLE)
X#if (0)
S  snmp_run_agent ();
N#endif
N#if (SNTP_ENABLE)
X#if (0)
S  sntp_run_client ();
N#endif
N
N#if (BSD_ENABLE && __RTX)
X#if (1 && 1)
N  xSemaphoreGive(bsd_mutex);
X  xQueueGenericSend( ( QueueHandle_t ) ( bsd_mutex ), 0, ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );
N#endif
N}
N
N
N/*--------------------------- bsd_suspend/resume ----------------------------*/
N
N#if (BSD_ENABLE && __RTX)
X#if (1 && 1)
N__used void bsd_suspend (U8 *tsk_id) {
X__attribute__((used)) void bsd_suspend (U8 *tsk_id) {
N  /* Suspend a socket owner task. */
N  xSemaphoreGive(bsd_mutex);
X  xQueueGenericSend( ( QueueHandle_t ) ( bsd_mutex ), 0, ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );
N  xSemaphoreTake(bsd_sem, portMAX_DELAY);
X  xQueueGenericReceive( ( QueueHandle_t ) ( bsd_sem ), 0, ( ( TickType_t ) 0xffffffffUL ), ( ( BaseType_t ) 0 ) );
N  xSemaphoreTake(bsd_mutex, portMAX_DELAY);	
X  xQueueGenericReceive( ( QueueHandle_t ) ( bsd_mutex ), 0, ( ( TickType_t ) 0xffffffffUL ), ( ( BaseType_t ) 0 ) );	
N}
N
N__used void bsd_resume (U8 tsk_id) {
X__attribute__((used)) void bsd_resume (U8 tsk_id) {
N  /* Resume a task waiting for a socket event. */
N  xSemaphoreGive(bsd_sem);
X  xQueueGenericSend( ( QueueHandle_t ) ( bsd_sem ), 0, ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );
N}
N#endif
N
N
N/*--------------------------- bsd_lock/unlock -------------------------------*/
N
N#if (BSD_ENABLE && __RTX)
X#if (1 && 1)
N__used void bsd_lock (void) {
X__attribute__((used)) void bsd_lock (void) {
N  /* Acquire mutex - Lock TCPnet functions. */
N  xSemaphoreTake(bsd_mutex, portMAX_DELAY);	
X  xQueueGenericReceive( ( QueueHandle_t ) ( bsd_mutex ), 0, ( ( TickType_t ) 0xffffffffUL ), ( ( BaseType_t ) 0 ) );	
N}
N
N__used void bsd_unlock (void) {
X__attribute__((used)) void bsd_unlock (void) {
N  /* Release mutex - Unlock TCPnet functions. */
N  xSemaphoreGive(bsd_mutex);
X  xQueueGenericSend( ( QueueHandle_t ) ( bsd_mutex ), 0, ( ( TickType_t ) 0U ), ( ( BaseType_t ) 0 ) );
N}
N#endif
N
N
N/*--------------------------- size optimization -----------------------------*/
N
N#if !(ETH_ENABLE)
X#if !(1)
S/* Empty functions when Ethernet Interface is disabled. */
SBOOL eth_chk_adr (OS_FRAME *frame)   { return (__FALSE); }
SU8  *eth_get_adr (U8 *ipadr)         { return (NULL); }
SBOOL eth_send_frame (OS_FRAME *frame){ return (__FALSE); }
N#endif
N
N#if !(ETH_ENABLE && IGMP_ENABLE)
X#if !(1 && 0)
N/* Empty functions when IP Multicasting is not enabled. */
NBOOL igmp_is_member (U8 *ipadr)      { return (__FALSE); }
XBOOL igmp_is_member (U8 *ipadr)      { return (0); }
Nvoid igmp_process (OS_FRAME *frame)  { ; }
N#endif
N
N#if (ETH_ENABLE && !DHCP_ENABLE)
X#if (1 && !1)
S/* Empty function when DHCP not enabled. */
Svoid dhcp_disable (void)             { ; }
N#endif
N
N#if !(PPP_ENABLE)
X#if !(0)
N/* Empty function when PPP Interface is disabled. */
NBOOL ppp_send_frame (OS_FRAME *frame, U16 prot) { return (__FALSE); }
XBOOL ppp_send_frame (OS_FRAME *frame, U16 prot) { return (0); }
N#endif
N
N#if (PPP_ENABLE && !(PPP_AUTHEN && PPP_PAPEN))
X#if (0 && !(1 && 1))
S/* Empty functions when PAP authentication not enabled. */
Svoid pap_init (void)                 { ; }
Svoid pap_run (void)                  { ; }
Svoid pap_process (OS_FRAME *frame)   { ; }
N#endif
N
N#if (PPP_ENABLE && !(PPP_AUTHEN && PPP_CHAPEN))
X#if (0 && !(1 && 1))
S/* Empty functions when CHAP authentication not enabled. */
Svoid chap_init (void)                { ; }
Svoid chap_run (void)                 { ; }
Svoid chap_process (OS_FRAME *frame)  { ; }
N#endif
N
N#if !(SLIP_ENABLE)
X#if !(0)
N/* Empty function when SLIP Interface is disabled. */
NBOOL slip_send_frame (OS_FRAME *frame) { return (__FALSE); }
XBOOL slip_send_frame (OS_FRAME *frame) { return (0); }
N#endif
N
N#if !(UDP_ENABLE)
X#if !(1)
S/* Empty function when UDP socket not enabled. */
Svoid udp_process (OS_FRAME *frame)   { ; }
N#endif
N
N#if !(TCP_ENABLE)
X#if !(1)
S/* Empty function when TCP socket not enabled. */
Svoid tcp_process (OS_FRAME *frame)   { ; }
N#endif
N
N#if !(SNTP_ENABLE)
X#if !(0)
N/* Empty function when SNTP not enabled. */
NBOOL sntp_get_time (U8 *ipadr, void (*cbfunc)(U32)) { return(__FALSE); }
XBOOL sntp_get_time (U8 *ipadr, void (*cbfunc)(U32)) { return(0); }
N#endif
N
N#if (BSD_ENABLE && !__RTX)
X#if (1 && !1)
S/* Empty functions for non RTX environment. */
S__used U8   bsd_wait   (BSD_INFO *bsd_s, U8 evt) { return (0);}
S__used void bsd_enable (BSD_INFO *bsd_s, U8 evt) { ; }
N#endif
N
N#endif    /* __NET_CONFIG__ */
N
N
N/*----------------------------------------------------------------------------
N *      Library for Net_Debug.c
N *---------------------------------------------------------------------------*/
N
N#ifdef __NET_DEBUG__
S
S/* Non-Critical Net_Debug.c upgrade */
S#ifndef DBG_TIME
S #define DBG_TIME   1
S#endif
S#ifdef DBG_APP
S #define DBG_HTTP   DBG_APP
S #define DBG_FTP    DBG_APP
S #define DBG_FTPC   DBG_APP
S #define DBG_TNET   DBG_APP
S #define DBG_TFTP   DBG_APP
S #define DBG_TFTPC  DBG_APP
S #define DBG_SMTP   DBG_APP
S#endif
S
S#include <stdarg.h>
S#include <stdio.h>
S
S#pragma diag_suppress 111
S
Sextern char *dbg_time (void);
Sextern char *dbg_proc (U32 proc);
S
S/*--------------------------- __debug__ -------------------------------------*/
S
Svoid __debug__ (U32 proc, const char *fmt, ...) {
S  /* Print TCPnet Debug messages. */
S  va_list args;
S
S  switch (proc) {
S#if (DBG_MEM > 1)
S    case MODULE_MEM:  break;
S#endif
S#if (DBG_ETH > 1)
S    case MODULE_ETH:  break;
S#endif
S#if (DBG_PPP > 1)
S    case MODULE_PPP:  break;
S#endif
S#if (DBG_SLIP > 1)
S    case MODULE_SLIP: break;
S#endif
S#if (DBG_ARP > 1)
S    case MODULE_ARP:  break;
S#endif
S#if (DBG_IP > 1)
S    case MODULE_IP:   break;
S#endif
S#if (DBG_ICMP > 1)
S    case MODULE_ICMP: break;
S#endif
S#if (DBG_IGMP > 1)
S    case MODULE_IGMP: break;
S#endif
S#if (DBG_UDP > 1)
S    case MODULE_UDP:  break;
S#endif
S#if (DBG_TCP > 1)
S    case MODULE_TCP:  break;
S#endif
S#if (DBG_NBNS > 1)
S    case MODULE_NBNS: break;
S#endif
S#if (DBG_DHCP > 1)
S    case MODULE_DHCP: break;
S#endif
S#if (DBG_DNS > 1)
S    case MODULE_DNS:  break;
S#endif
S#if (DBG_SNMP > 1)
S    case MODULE_SNMP: break;
S#endif
S#if (DBG_BSD > 1)
S    case MODULE_BSD:  break;
S#endif
S#if (DBG_HTTP > 1)
S    case MODULE_HTTP: break;
S#endif
S#if (DBG_FTP > 1)
S    case MODULE_FTP:  break;
S#endif
S#if (DBG_FTPC > 1)
S    case MODULE_FTPC: break;
S#endif
S#if (DBG_TNET > 1)
S    case MODULE_TNET: break;
S#endif
S#if (DBG_TFTP > 1)
S    case MODULE_TFTP: break;
S#endif
S#if (DBG_TFTPC > 1)
S    case MODULE_TFTPC:break;
S#endif
S#if (DBG_SMTP > 1)
S    case MODULE_SMTP: break;
S#endif
S#if (DBG_SNTP > 1)
S    case MODULE_SNTP: break;
S#endif
S    default: return;
S  }
S#if (DBG_TIME)
S  printf (dbg_time());
S#endif
S  printf ("%s:",dbg_proc(proc));
S
S  va_start (args,fmt);
S  vprintf (fmt,args);
S  va_end (args);
S}
S
S
S/*--------------------------- __error__ -------------------------------------*/
S
Svoid __error__ (U32 proc, const char *fmt, ...) {
S  /* Print TCPnet Error messages. */
S  va_list args;
S
S  switch (proc) {
S#if (DBG_MEM > 0)
S    case MODULE_MEM:  break;
S#endif
S#if (DBG_ETH > 0)
S    case MODULE_ETH:  break;
S#endif
S#if (DBG_PPP > 0)
S    case MODULE_PPP:  break;
S#endif
S#if (DBG_SLIP > 0)
S    case MODULE_SLIP: break;
S#endif
S#if (DBG_ARP > 0)
S    case MODULE_ARP:  break;
S#endif
S#if (DBG_IP > 0)
S    case MODULE_IP:   break;
S#endif
S#if (DBG_ICMP > 0)
S    case MODULE_ICMP: break;
S#endif
S#if (DBG_IGMP > 0)
S    case MODULE_IGMP: break;
S#endif
S#if (DBG_UDP > 0)
S    case MODULE_UDP:  break;
S#endif
S#if (DBG_TCP > 0)
S    case MODULE_TCP:  break;
S#endif
S#if (DBG_NBNS > 0)
S    case MODULE_NBNS: break;
S#endif
S#if (DBG_DHCP > 0)
S    case MODULE_DHCP: break;
S#endif
S#if (DBG_DNS > 0)
S    case MODULE_DNS:  break;
S#endif
S#if (DBG_SNMP > 0)
S    case MODULE_SNMP: break;
S#endif
S#if (DBG_BSD > 0)
S    case MODULE_BSD:  break;
S#endif
S#if (DBG_HTTP > 0)
S    case MODULE_HTTP: break;
S#endif
S#if (DBG_FTP > 0)
S    case MODULE_FTP:  break;
S#endif
S#if (DBG_FTPC > 0)
S    case MODULE_FTPC: break;
S#endif
S#if (DBG_TNET > 0)
S    case MODULE_TNET: break;
S#endif
S#if (DBG_TFTP > 0)
S    case MODULE_TFTP: break;
S#endif
S#if (DBG_TFTPC > 0)
S    case MODULE_TFTPC:break;
S#endif
S#if (DBG_SMTP > 0)
S    case MODULE_SMTP: break;
S#endif
S#if (DBG_SNTP > 0)
S    case MODULE_SNTP: break;
S#endif
S    default: return;
S  }
S#if (DBG_TIME)
S  printf (dbg_time());
S#endif
S  printf ("%s-ERR:",dbg_proc(proc));
S
S  va_start (args,fmt);
S  vprintf (fmt,args);
S  va_end (args);
S}
S
N#endif    /* __NET_DEBUG__ */
N
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
L 931 "..\..\RL-ARM\Config\Net_Config.c" 2
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
