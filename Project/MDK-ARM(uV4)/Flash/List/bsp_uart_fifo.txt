; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\..\RL-ARM\Config -I..\..\RL-ARM\Driver -I..\..\RL-ARM\RL-RTX\inc -IC:\Keil4.74\ARM\RV31\INC -IC:\Keil4.74\ARM\CMSIS\Include -IC:\Keil4.74\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -D__RTX --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUSARTx||, CODE, READONLY, ALIGN=2

                  ComToUSARTx PROC
;;;165    */
;;;166    USART_TypeDef *ComToUSARTx(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;167    {
;;;168    	if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L1.8|
;;;169    	{
;;;170    		#if UART1_FIFO_EN == 1
;;;171    			return USART1;
000004  4809              LDR      r0,|L1.44|
                  |L1.6|
;;;172    		#else
;;;173    			return 0;
;;;174    		#endif
;;;175    	}
;;;176    	else if (_ucPort == COM2)
;;;177    	{
;;;178    		#if UART2_FIFO_EN == 1
;;;179    			return USART2;
;;;180    		#else
;;;181    			return NULL;
;;;182    		#endif
;;;183    	}
;;;184    	else if (_ucPort == COM3)
;;;185    	{
;;;186    		#if UART3_FIFO_EN == 1
;;;187    			return USART3;
;;;188    		#else
;;;189    			return 0;
;;;190    		#endif
;;;191    	}
;;;192    	else if (_ucPort == COM4)
;;;193    	{
;;;194    		#if UART4_FIFO_EN == 1
;;;195    			return USART4;
;;;196    		#else
;;;197    			return 0;
;;;198    		#endif
;;;199    	}
;;;200    	else if (_ucPort == COM5)
;;;201    	{
;;;202    		#if UART5_FIFO_EN == 1
;;;203    			return USART5;
;;;204    		#else
;;;205    			return 0;
;;;206    		#endif
;;;207    	}
;;;208    	else
;;;209    	{
;;;210    		/* 不做任何处理 */
;;;211    		return 0;
;;;212    	}
;;;213    }
000006  4770              BX       lr
                  |L1.8|
000008  2901              CMP      r1,#1                 ;176
00000a  d101              BNE      |L1.16|
00000c  2000              MOVS     r0,#0                 ;181
00000e  e7fa              B        |L1.6|
                  |L1.16|
000010  2902              CMP      r1,#2                 ;184
000012  d101              BNE      |L1.24|
000014  2000              MOVS     r0,#0                 ;189
000016  e7f6              B        |L1.6|
                  |L1.24|
000018  2903              CMP      r1,#3                 ;192
00001a  d101              BNE      |L1.32|
00001c  2000              MOVS     r0,#0                 ;197
00001e  e7f2              B        |L1.6|
                  |L1.32|
000020  2904              CMP      r1,#4                 ;200
000022  d101              BNE      |L1.40|
000024  2000              MOVS     r0,#0                 ;205
000026  e7ee              B        |L1.6|
                  |L1.40|
000028  2000              MOVS     r0,#0                 ;211
00002a  e7ec              B        |L1.6|
;;;214    
                          ENDP

                  |L1.44|
                          DCD      0x40011000

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;99     */
;;;100    UART_T *ComToUart(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;101    {
;;;102    	if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L2.8|
;;;103    	{
;;;104    		#if UART1_FIFO_EN == 1
;;;105    			return &g_tUart1;
000004  480b              LDR      r0,|L2.52|
                  |L2.6|
;;;106    		#else
;;;107    			return 0;
;;;108    		#endif
;;;109    	}
;;;110    	else if (_ucPort == COM2)
;;;111    	{
;;;112    		#if UART2_FIFO_EN == 1
;;;113    			return &g_tUart2;
;;;114    		#else
;;;115    			return NULL;
;;;116    		#endif
;;;117    	}
;;;118    	else if (_ucPort == COM3)
;;;119    	{
;;;120    		#if UART3_FIFO_EN == 1
;;;121    			return &g_tUart3;
;;;122    		#else
;;;123    			return 0;
;;;124    		#endif
;;;125    	}
;;;126    	else if (_ucPort == COM4)
;;;127    	{
;;;128    		#if UART4_FIFO_EN == 1
;;;129    			return &g_tUart4;
;;;130    		#else
;;;131    			return 0;
;;;132    		#endif
;;;133    	}
;;;134    	else if (_ucPort == COM5)
;;;135    	{
;;;136    		#if UART5_FIFO_EN == 1
;;;137    			return &g_tUart5;
;;;138    		#else
;;;139    			return 0;
;;;140    		#endif
;;;141    	}
;;;142    	else if (_ucPort == COM6)
;;;143    	{
;;;144    		#if UART6_FIFO_EN == 1
;;;145    			return &g_tUart6;
;;;146    		#else
;;;147    			return 0;
;;;148    		#endif
;;;149    	}
;;;150    	else
;;;151    	{
;;;152    		/* 不做任何处理 */
;;;153    		return 0;
;;;154    	}
;;;155    }
000006  4770              BX       lr
                  |L2.8|
000008  2901              CMP      r1,#1                 ;110
00000a  d101              BNE      |L2.16|
00000c  2000              MOVS     r0,#0                 ;115
00000e  e7fa              B        |L2.6|
                  |L2.16|
000010  2902              CMP      r1,#2                 ;118
000012  d101              BNE      |L2.24|
000014  2000              MOVS     r0,#0                 ;123
000016  e7f6              B        |L2.6|
                  |L2.24|
000018  2903              CMP      r1,#3                 ;126
00001a  d101              BNE      |L2.32|
00001c  2000              MOVS     r0,#0                 ;131
00001e  e7f2              B        |L2.6|
                  |L2.32|
000020  2904              CMP      r1,#4                 ;134
000022  d101              BNE      |L2.40|
000024  2000              MOVS     r0,#0                 ;139
000026  e7ee              B        |L2.6|
                  |L2.40|
000028  2905              CMP      r1,#5                 ;142
00002a  d101              BNE      |L2.48|
00002c  2000              MOVS     r0,#0                 ;147
00002e  e7ea              B        |L2.6|
                  |L2.48|
000030  2000              MOVS     r0,#0                 ;153
000032  e7e8              B        |L2.6|
;;;156    
                          ENDP

                  |L2.52|
                          DCD      g_tUart1

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;1046   */
;;;1047   static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;1048   {
;;;1049   	NVIC_InitTypeDef NVIC_InitStructure;
;;;1050   
;;;1051   	/* Configure the NVIC Preemption Priority Bits */
;;;1052   	/*	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  --- 在 bsp.c 中 bsp_Init() 中配置中断优先级组 */
;;;1053   
;;;1054   #if UART1_FIFO_EN == 1
;;;1055   	/* 使能串口1中断 */
;;;1056   	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000002  2025              MOVS     r0,#0x25
000004  f88d0000          STRB     r0,[sp,#0]
;;;1057   	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
000008  200d              MOVS     r0,#0xd
00000a  f88d0001          STRB     r0,[sp,#1]
;;;1058   	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00000e  2000              MOVS     r0,#0
000010  f88d0002          STRB     r0,[sp,#2]
;;;1059   	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;1060   	NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;1061   #endif
;;;1062   
;;;1063   #if UART2_FIFO_EN == 1
;;;1064   	/* 使能串口2中断 */
;;;1065   	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
;;;1066   	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
;;;1067   	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;1068   	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;1069   	NVIC_Init(&NVIC_InitStructure);
;;;1070   #endif
;;;1071   
;;;1072   #if UART3_FIFO_EN == 1
;;;1073   	/* 使能串口3中断t */
;;;1074   	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
;;;1075   	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
;;;1076   	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;1077   	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;1078   	NVIC_Init(&NVIC_InitStructure);
;;;1079   #endif
;;;1080   
;;;1081   #if UART4_FIFO_EN == 1
;;;1082   	/* 使能串口4中断t */
;;;1083   	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
;;;1084   	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
;;;1085   	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;1086   	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;1087   	NVIC_Init(&NVIC_InitStructure);
;;;1088   #endif
;;;1089   
;;;1090   #if UART5_FIFO_EN == 1
;;;1091   	/* 使能串口5中断t */
;;;1092   	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
;;;1093   	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
;;;1094   	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;1095   	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;1096   	NVIC_Init(&NVIC_InitStructure);
;;;1097   #endif
;;;1098   
;;;1099   #if UART6_FIFO_EN == 1
;;;1100   	/* 使能串口6中断t */
;;;1101   	NVIC_InitStructure.NVIC_IRQChannel = USART6_IRQn;
;;;1102   	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
;;;1103   	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;1104   	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;1105   	NVIC_Init(&NVIC_InitStructure);
;;;1106   #endif
;;;1107   }
000020  bd08              POP      {r3,pc}
;;;1108   
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;640    */
;;;641    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;642    {
000002  b087              SUB      sp,sp,#0x1c
;;;643    	GPIO_InitTypeDef GPIO_InitStructure;
;;;644    	USART_InitTypeDef USART_InitStructure;
;;;645    
;;;646    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;647    
;;;648    	/* 第1步： 配置GPIO */
;;;649    	#if 1	/* TX = PA9   RX = PA10 */
;;;650    		/* 打开 GPIO 时钟 */
;;;651    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;652    
;;;653    		/* 打开 UART 时钟 */
;;;654    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2010              MOVS     r0,#0x10
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;655    
;;;656    		/* 将 PA9 映射为 USART1_TX */
;;;657    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
000014  2207              MOVS     r2,#7
000016  2109              MOVS     r1,#9
000018  4822              LDR      r0,|L4.164|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;658    
;;;659    		/* 将 PA10 映射为 USART1_RX */
;;;660    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
00001e  2207              MOVS     r2,#7
000020  210a              MOVS     r1,#0xa
000022  4820              LDR      r0,|L4.164|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;661    
;;;662    		/* 配置 USART Tx 为复用功能 */
;;;663    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
000028  2000              MOVS     r0,#0
00002a  f88d001a          STRB     r0,[sp,#0x1a]
;;;664    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
00002e  2001              MOVS     r0,#1
000030  f88d001b          STRB     r0,[sp,#0x1b]
;;;665    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
000034  2002              MOVS     r0,#2
000036  f88d0018          STRB     r0,[sp,#0x18]
;;;666    
;;;667    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00003a  0200              LSLS     r0,r0,#8
00003c  9005              STR      r0,[sp,#0x14]
;;;668    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003e  2002              MOVS     r0,#2
000040  f88d0019          STRB     r0,[sp,#0x19]
;;;669    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000044  a905              ADD      r1,sp,#0x14
000046  4817              LDR      r0,|L4.164|
000048  f7fffffe          BL       GPIO_Init
;;;670    
;;;671    		/* 配置 USART Rx 为复用功能 */
;;;672    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00004c  2002              MOVS     r0,#2
00004e  f88d0018          STRB     r0,[sp,#0x18]
;;;673    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000052  0240              LSLS     r0,r0,#9
000054  9005              STR      r0,[sp,#0x14]
;;;674    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000056  a905              ADD      r1,sp,#0x14
000058  4812              LDR      r0,|L4.164|
00005a  f7fffffe          BL       GPIO_Init
;;;675    	#else	/* TX = PB6   RX = PB7  */
;;;676    		/* 打开 GPIO 时钟 */
;;;677    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;678    
;;;679    		/* 打开 UART 时钟 */
;;;680    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
;;;681    
;;;682    		/* 将 PB6 映射为 USART1_TX */
;;;683    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_USART1);
;;;684    
;;;685    		/* 将 PB7 映射为 USART1_RX */
;;;686    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_USART1);
;;;687    
;;;688    		/* 配置 USART Tx 为复用功能 */
;;;689    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;690    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;691    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;692    
;;;693    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
;;;694    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;695    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;696    
;;;697    		/* 配置 USART Rx 为复用功能 */
;;;698    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;699    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
;;;700    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;701    	#endif
;;;702    
;;;703    	/* 第2步： 配置串口硬件参数 */
;;;704    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
00005e  f44f30e1          MOV      r0,#0x1c200
000062  9001              STR      r0,[sp,#4]
;;;705    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000064  2000              MOVS     r0,#0
000066  f8ad0008          STRH     r0,[sp,#8]
;;;706    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00006a  f8ad000a          STRH     r0,[sp,#0xa]
;;;707    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00006e  f8ad000c          STRH     r0,[sp,#0xc]
;;;708    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000072  f8ad0010          STRH     r0,[sp,#0x10]
;;;709    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000076  200c              MOVS     r0,#0xc
000078  f8ad000e          STRH     r0,[sp,#0xe]
;;;710    	USART_Init(USART1, &USART_InitStructure);
00007c  a901              ADD      r1,sp,#4
00007e  480a              LDR      r0,|L4.168|
000080  f7fffffe          BL       USART_Init
;;;711    
;;;712    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000084  2201              MOVS     r2,#1
000086  f2405125          MOV      r1,#0x525
00008a  4807              LDR      r0,|L4.168|
00008c  f7fffffe          BL       USART_ITConfig
;;;713    	/*
;;;714    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;715    		注意: 不要在此处打开发送中断
;;;716    		发送中断使能在SendUart()函数打开
;;;717    	*/
;;;718    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000090  2101              MOVS     r1,#1
000092  4805              LDR      r0,|L4.168|
000094  f7fffffe          BL       USART_Cmd
;;;719    
;;;720    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;721    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;722    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000098  2140              MOVS     r1,#0x40
00009a  4803              LDR      r0,|L4.168|
00009c  f7fffffe          BL       USART_ClearFlag
;;;723    #endif
;;;724    
;;;725    #if UART2_FIFO_EN == 1		/* 串口2 TX = PD5   RX = PD6 或  TX = PA2， RX = PA3  */
;;;726    	/* 第1步： 配置GPIO */
;;;727    	#if 0	/* 串口2 TX = PD5   RX = PD6 */
;;;728    		/* 打开 GPIO 时钟 */
;;;729    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
;;;730    
;;;731    		/* 打开 UART 时钟 */
;;;732    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
;;;733    
;;;734    		/* 将 PD5 映射为 USART2_TX */
;;;735    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_USART2);
;;;736    
;;;737    		/* 将 PD6 映射为 USART2_RX */
;;;738    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_USART2);
;;;739    
;;;740    		/* 配置 USART Tx 为复用功能 */
;;;741    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;742    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;743    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;744    
;;;745    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
;;;746    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;747    		GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;748    
;;;749    		/* 配置 USART Rx 为复用功能 */
;;;750    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;751    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
;;;752    		GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;753    
;;;754    	#else	/* 串口2   TX = PA2， RX = PA3 */
;;;755    		/* 打开 GPIO 时钟 */
;;;756    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
;;;757    
;;;758    		/* 打开 UART 时钟 */
;;;759    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
;;;760    
;;;761    		/* 将 PA2 映射为 USART2_TX. 在STM32-V5板中，PA2 管脚用于以太网 */
;;;762    		//GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
;;;763    
;;;764    		/* 将 PA3 映射为 USART2_RX */
;;;765    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
;;;766    
;;;767    		/* 配置 USART Tx 为复用功能 */
;;;768    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;769    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;770    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;771    
;;;772    		//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;773    		//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;774    		//GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;775    
;;;776    		/* 配置 USART Rx 为复用功能 */
;;;777    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;778    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
;;;779    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;780    		GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;781    	#endif
;;;782    
;;;783    	/* 第2步： 配置串口硬件参数 */
;;;784    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
;;;785    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;786    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;787    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;788    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;789    	USART_InitStructure.USART_Mode = USART_Mode_Rx;		/* 仅选择接收模式 */
;;;790    	USART_Init(USART2, &USART_InitStructure);
;;;791    
;;;792    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;793    	/*
;;;794    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;795    		注意: 不要在此处打开发送中断
;;;796    		发送中断使能在SendUart()函数打开
;;;797    	*/
;;;798    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
;;;799    
;;;800    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;801    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;802    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;803    #endif
;;;804    
;;;805    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;806    
;;;807    	/* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;808    	{
;;;809    		RCC_AHB1PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
;;;810    
;;;811    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
;;;812    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
;;;813    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
;;;814    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
;;;815    
;;;816    		GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
;;;817    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
;;;818    	}
;;;819    
;;;820    	/* 打开 GPIO 时钟 */
;;;821    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;822    
;;;823    	/* 打开 UART 时钟 */
;;;824    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
;;;825    
;;;826    	/* 将 PB10 映射为 USART3_TX */
;;;827    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_USART3);
;;;828    
;;;829    	/* 将 PB11 映射为 USART3_RX */
;;;830    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_USART3);
;;;831    
;;;832    	/* 配置 USART Tx 为复用功能 */
;;;833    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;834    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;835    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;836    
;;;837    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;838    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;839    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;840    
;;;841    	/* 配置 USART Rx 为复用功能 */
;;;842    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;843    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;844    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;845    
;;;846    	/* 第2步： 配置串口硬件参数 */
;;;847    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
;;;848    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;849    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;850    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;851    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;852    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;853    	USART_Init(USART3, &USART_InitStructure);
;;;854    
;;;855    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;856    	/*
;;;857    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;858    		注意: 不要在此处打开发送中断
;;;859    		发送中断使能在SendUart()函数打开
;;;860    	*/
;;;861    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
;;;862    
;;;863    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;864    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;865    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;866    #endif
;;;867    
;;;868    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;869    	/* 第1步： 配置GPIO */
;;;870    
;;;871    	/* 打开 GPIO 时钟 */
;;;872    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
;;;873    
;;;874    	/* 打开 UART 时钟 */
;;;875    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;876    
;;;877    	/* 将 PC10 映射为 UART4_TX */
;;;878    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART1);
;;;879    
;;;880    	/* 将 PC11 映射为 UART4_RX */
;;;881    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_USART1);
;;;882    
;;;883    	/* 配置 USART Tx 为复用功能 */
;;;884    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;885    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;886    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;887    
;;;888    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;889    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;890    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;891    
;;;892    	/* 配置 USART Rx 为复用功能 */
;;;893    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;894    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;895    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;896    
;;;897    	/* 第2步： 配置串口硬件参数 */
;;;898    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
;;;899    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;900    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;901    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;902    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;903    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;904    	USART_Init(UART4, &USART_InitStructure);
;;;905    
;;;906    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;907    	/*
;;;908    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;909    		注意: 不要在此处打开发送中断
;;;910    		发送中断使能在SendUart()函数打开
;;;911    	*/
;;;912    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;913    
;;;914    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;915    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;916    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;917    #endif
;;;918    
;;;919    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;920    	/* 第1步： 配置GPIO */
;;;921    
;;;922    	/* 打开 GPIO 时钟 */
;;;923    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC |RCC_AHB1Periph_GPIOD, ENABLE);
;;;924    
;;;925    	/* 打开 UART 时钟 */
;;;926    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;927    
;;;928    	/* 将 PC12 映射为 UART5_TX */
;;;929    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_UART5);
;;;930    
;;;931    	/* 将 PD2 映射为 UART5_RX */
;;;932    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource2, GPIO_AF_UART5);
;;;933    
;;;934    	/* 配置 UART Tx 为复用功能 */
;;;935    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;936    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;937    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;938    
;;;939    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;940    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;941    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;942    
;;;943    	/* 配置 UART Rx 为复用功能 */
;;;944    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;945    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;946    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;947    
;;;948    	/* 第2步： 配置串口硬件参数 */
;;;949    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;950    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;951    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;952    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;953    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;954    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;955    	USART_Init(UART5, &USART_InitStructure);
;;;956    
;;;957    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;958    	/*
;;;959    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;960    		注意: 不要在此处打开发送中断
;;;961    		发送中断使能在SendUart()函数打开
;;;962    	*/
;;;963    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;964    
;;;965    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;966    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;967    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;968    #endif
;;;969    
;;;970    #if UART6_FIFO_EN == 1			/* PG14/USART6_TX , PC7/USART6_RX,PG8/USART6_RTS, PG15/USART6_CTS */
;;;971    	/* 第1步： 配置GPIO */
;;;972    
;;;973    	/* 打开 GPIO 时钟 */
;;;974    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC |RCC_AHB1Periph_GPIOG, ENABLE);
;;;975    
;;;976    	/* 打开 UART 时钟 */
;;;977    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, ENABLE);
;;;978    
;;;979    	/* 将 PG14 映射为 USART6_TX */
;;;980    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_USART6);
;;;981    
;;;982    	/* 将 PC7 映射为 USART6_RX */
;;;983    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_USART6);
;;;984    
;;;985    	/* 将 PG8 映射为 USART6_RTS */
;;;986    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource8, GPIO_AF_USART6);
;;;987    
;;;988    	/* 将 PG15 映射为 USART6_CTS */
;;;989    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource15, GPIO_AF_USART6);
;;;990    
;;;991    	/* 配置 PG14/USART6_TX 为复用功能 */
;;;992    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;993    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;994    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;995    
;;;996    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
;;;997    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;998    	GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;999    
;;;1000   	/* 配置 PC7/USART6_RX 为复用功能 */
;;;1001   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;1002   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
;;;1003   	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;1004   
;;;1005   	/* 配置 PG8/USART6_RTS 为复用功能 */
;;;1006   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;1007   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
;;;1008   	GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;1009   
;;;1010   	/* 配置 PG15/USART6_CTS 为复用功能 */
;;;1011   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;1012   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
;;;1013   	GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;1014   
;;;1015   	/* 第2步： 配置串口硬件参数 */
;;;1016   	USART_InitStructure.USART_BaudRate = UART6_BAUD;	/* 波特率 */
;;;1017   	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;1018   	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;1019   	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;1020   	//USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_RTS_CTS;	/* 选择硬件流控 */
;;;1021   	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	/* 不要硬件流控 */
;;;1022   	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;1023   	USART_Init(USART6, &USART_InitStructure);
;;;1024   
;;;1025   	USART_ITConfig(USART6, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;1026   	/*
;;;1027   		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;1028   		注意: 不要在此处打开发送中断
;;;1029   		发送中断使能在SendUart()函数打开
;;;1030   	*/
;;;1031   	USART_Cmd(USART6, ENABLE);		/* 使能串口 */
;;;1032   
;;;1033   	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;1034   		如下语句解决第1个字节无法正确发送出去的问题 */
;;;1035   	USART_ClearFlag(USART6, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;1036   #endif
;;;1037   }
0000a0  b007              ADD      sp,sp,#0x1c
0000a2  bd00              POP      {pc}
;;;1038   
                          ENDP

                  |L4.164|
                          DCD      0x40020000
                  |L4.168|
                          DCD      0x40011000

                          AREA ||i.RS485_InitTXE||, CODE, READONLY, ALIGN=2

                  RS485_InitTXE PROC
;;;420    */
;;;421    void RS485_InitTXE(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;422    {
;;;423    	GPIO_InitTypeDef GPIO_InitStructure;
;;;424    
;;;425    	RCC_AHB1PeriphClockCmd(RCC_RS485_TXEN, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;426    
;;;427    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;428    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽 */
000010  2000              MOVS     r0,#0
000012  f88d0006          STRB     r0,[sp,#6]
;;;429    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无上拉电阻 */
000016  f88d0007          STRB     r0,[sp,#7]
;;;430    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;431    	GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000020  2004              MOVS     r0,#4
000022  9000              STR      r0,[sp,#0]
;;;432    	GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  4802              LDR      r0,|L5.48|
000028  f7fffffe          BL       GPIO_Init
;;;433    }
00002c  bd1c              POP      {r2-r4,pc}
;;;434    
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      0x40020400

                          AREA ||i.RS485_ReciveNew||, CODE, READONLY, ALIGN=1

                  RS485_ReciveNew PROC
;;;513    //extern void MODBUS_ReciveNew(uint8_t _byte);
;;;514    void RS485_ReciveNew(uint8_t _byte)
000000  4770              BX       lr
;;;515    {
;;;516    //	MODBUS_ReciveNew(_byte);
;;;517    }
;;;518    
                          ENDP


                          AREA ||i.RS485_SendBefor||, CODE, READONLY, ALIGN=2

                  RS485_SendBefor PROC
;;;456    */
;;;457    void RS485_SendBefor(void)
000000  2004              MOVS     r0,#4
;;;458    {
;;;459    	RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000002  4901              LDR      r1,|L7.8|
000004  8008              STRH     r0,[r1,#0]
;;;460    }
000006  4770              BX       lr
;;;461    
                          ENDP

                  |L7.8|
                          DCD      0x40020418

                          AREA ||i.RS485_SendBuf||, CODE, READONLY, ALIGN=1

                  RS485_SendBuf PROC
;;;485    */
;;;486    void RS485_SendBuf(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;487    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;488    	comSendBuf(COM3, _ucaBuf, _usLen);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       comSendBuf
;;;489    }
000010  bd70              POP      {r4-r6,pc}
;;;490    
                          ENDP


                          AREA ||i.RS485_SendOver||, CODE, READONLY, ALIGN=2

                  RS485_SendOver PROC
;;;470    */
;;;471    void RS485_SendOver(void)
000000  2004              MOVS     r0,#4
;;;472    {
;;;473    	RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000002  4901              LDR      r1,|L9.8|
000004  8008              STRH     r0,[r1,#0]
;;;474    }
000006  4770              BX       lr
;;;475    
                          ENDP

                  |L9.8|
                          DCD      0x4002041a

                          AREA ||i.RS485_SendStr||, CODE, READONLY, ALIGN=1

                  RS485_SendStr PROC
;;;499    */
;;;500    void RS485_SendStr(char *_pBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;501    {
000002  4604              MOV      r4,r0
;;;502    	RS485_SendBuf((uint8_t *)_pBuf, strlen(_pBuf));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       strlen
00000a  b285              UXTH     r5,r0
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RS485_SendBuf
;;;503    }
000014  bd70              POP      {r4-r6,pc}
;;;504    
                          ENDP


                          AREA ||i.RS485_SetBaud||, CODE, READONLY, ALIGN=1

                  RS485_SetBaud PROC
;;;442    */
;;;443    void RS485_SetBaud(uint32_t _baud)
000000  b510              PUSH     {r4,lr}
;;;444    {
000002  4604              MOV      r4,r0
;;;445    	comSetBaud(COM3, _baud);
000004  4621              MOV      r1,r4
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       comSetBaud
;;;446    }
00000c  bd10              POP      {r4,pc}
;;;447    
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1320   #if UART1_FIFO_EN == 1
;;;1321   void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1322   {
;;;1323   	UartIRQ(&g_tUart1);
000002  4802              LDR      r0,|L12.12|
000004  f7fffffe          BL       UartIRQ
;;;1324   }
000008  bd10              POP      {r4,pc}
;;;1325   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      g_tUart1

                          AREA ||i.USART_SetBaudRate||, CODE, READONLY, ALIGN=2

                  USART_SetBaudRate PROC
;;;356    */
;;;357    void USART_SetBaudRate(USART_TypeDef* USARTx, uint32_t BaudRate)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;358    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;359    	uint32_t tmpreg = 0x00, apbclock = 0x00;
000008  2500              MOVS     r5,#0
00000a  46a9              MOV      r9,r5
;;;360    	uint32_t integerdivider = 0x00;
00000c  bf00              NOP      
;;;361    	uint32_t fractionaldivider = 0x00;
00000e  2700              MOVS     r7,#0
;;;362    	RCC_ClocksTypeDef RCC_ClocksStatus;
;;;363    
;;;364    	/* Check the parameters */
;;;365    	assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;366    	assert_param(IS_USART_BAUDRATE(BaudRate));  
;;;367    
;;;368    	/*---------------------------- USART BRR Configuration -----------------------*/
;;;369    	/* Configure the USART Baud Rate */
;;;370    	RCC_GetClocksFreq(&RCC_ClocksStatus);
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       RCC_GetClocksFreq
;;;371    
;;;372    	if ((USARTx == USART1) || (USARTx == USART6))
000016  4820              LDR      r0,|L13.152|
000018  4284              CMP      r4,r0
00001a  d002              BEQ      |L13.34|
00001c  481f              LDR      r0,|L13.156|
00001e  4284              CMP      r4,r0
000020  d102              BNE      |L13.40|
                  |L13.34|
;;;373    	{
;;;374    		apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000022  f8dd900c          LDR      r9,[sp,#0xc]
000026  e001              B        |L13.44|
                  |L13.40|
;;;375    	}
;;;376    	else
;;;377    	{
;;;378    		apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000028  f8dd9008          LDR      r9,[sp,#8]
                  |L13.44|
;;;379    	}
;;;380    
;;;381    	/* Determine the integer part */
;;;382    	if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
00002c  89a0              LDRH     r0,[r4,#0xc]
00002e  f4104f00          TST      r0,#0x8000
000032  d008              BEQ      |L13.70|
;;;383    	{
;;;384    		/* Integer part computing in case Oversampling mode is 8 Samples */
;;;385    		integerdivider = ((25 * apbclock) / (2 * (BaudRate)));    
000034  eb0900c9          ADD      r0,r9,r9,LSL #3
000038  eb001009          ADD      r0,r0,r9,LSL #4
00003c  ea4f0148          LSL      r1,r8,#1
000040  fbb0f6f1          UDIV     r6,r0,r1
000044  e007              B        |L13.86|
                  |L13.70|
;;;386    	}
;;;387    	else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;388    	{
;;;389    		/* Integer part computing in case Oversampling mode is 16 Samples */
;;;390    		integerdivider = ((25 * apbclock) / (4 * (BaudRate)));    
000046  eb0900c9          ADD      r0,r9,r9,LSL #3
00004a  eb001009          ADD      r0,r0,r9,LSL #4
00004e  ea4f0188          LSL      r1,r8,#2
000052  fbb0f6f1          UDIV     r6,r0,r1
                  |L13.86|
;;;391    	}
;;;392    	tmpreg = (integerdivider / 100) << 4;
000056  2064              MOVS     r0,#0x64
000058  fbb6f0f0          UDIV     r0,r6,r0
00005c  0105              LSLS     r5,r0,#4
;;;393    
;;;394    	/* Determine the fractional part */
;;;395    	fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
00005e  0928              LSRS     r0,r5,#4
000060  2164              MOVS     r1,#0x64
000062  fb016710          MLS      r7,r1,r0,r6
;;;396    
;;;397    	/* Implement the fractional part in the register */
;;;398    	if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
000066  89a0              LDRH     r0,[r4,#0xc]
000068  f4104f00          TST      r0,#0x8000
00006c  d008              BEQ      |L13.128|
;;;399    	{
;;;400    		tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
00006e  2032              MOVS     r0,#0x32
000070  eb0000c7          ADD      r0,r0,r7,LSL #3
000074  fbb0f0f1          UDIV     r0,r0,r1
000078  f0000007          AND      r0,r0,#7
00007c  4305              ORRS     r5,r5,r0
00007e  e008              B        |L13.146|
                  |L13.128|
;;;401    	}
;;;402    	else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;403    	{
;;;404    		tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
000080  2032              MOVS     r0,#0x32
000082  eb001007          ADD      r0,r0,r7,LSL #4
000086  2164              MOVS     r1,#0x64
000088  fbb0f0f1          UDIV     r0,r0,r1
00008c  f000000f          AND      r0,r0,#0xf
000090  4305              ORRS     r5,r5,r0
                  |L13.146|
;;;405    	}
;;;406    
;;;407    	/* Write to USART BRR register */
;;;408    	USARTx->BRR = (uint16_t)tmpreg;
000092  8125              STRH     r5,[r4,#8]
;;;409    }
000094  e8bd87ff          POP      {r0-r10,pc}
;;;410    
                          ENDP

                  |L13.152|
                          DCD      0x40011000
                  |L13.156|
                          DCD      0x40011400

                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;1188   */
;;;1189   static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;1190   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1191   	uint16_t usCount;
;;;1192   
;;;1193   	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;1194   	DISABLE_INT();
000006  f7fffffe          BL       vPortEnterCritical
;;;1195   	usCount = _pUart->usRxCount;
00000a  8b66              LDRH     r6,[r4,#0x1a]
;;;1196   	ENABLE_INT();
00000c  f7fffffe          BL       vPortExitCritical
;;;1197   
;;;1198   	/* 如果读和写索引相同，则返回0 */
;;;1199   	//if (_pUart->usRxRead == usRxWrite)
;;;1200   	if (usCount == 0)	/* 已经没有数据 */
000010  b90e              CBNZ     r6,|L14.22|
;;;1201   	{
;;;1202   		return 0;
000012  2000              MOVS     r0,#0
                  |L14.20|
;;;1203   	}
;;;1204   	else
;;;1205   	{
;;;1206   		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
;;;1207   
;;;1208   		/* 改写FIFO读索引 */
;;;1209   		DISABLE_INT();
;;;1210   		if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;1211   		{
;;;1212   			_pUart->usRxRead = 0;
;;;1213   		}
;;;1214   		_pUart->usRxCount--;
;;;1215   		ENABLE_INT();
;;;1216   		return 1;
;;;1217   	}
;;;1218   }
000014  bd70              POP      {r4-r6,pc}
                  |L14.22|
000016  8b21              LDRH     r1,[r4,#0x18]         ;1206
000018  68a0              LDR      r0,[r4,#8]            ;1206
00001a  5c40              LDRB     r0,[r0,r1]            ;1206
00001c  7028              STRB     r0,[r5,#0]            ;1206
00001e  f7fffffe          BL       vPortEnterCritical
000022  8b20              LDRH     r0,[r4,#0x18]         ;1210
000024  1c40              ADDS     r0,r0,#1              ;1210
000026  b280              UXTH     r0,r0                 ;1210
000028  8320              STRH     r0,[r4,#0x18]         ;1210
00002a  89e1              LDRH     r1,[r4,#0xe]          ;1210
00002c  4288              CMP      r0,r1                 ;1210
00002e  db01              BLT      |L14.52|
000030  2000              MOVS     r0,#0                 ;1212
000032  8320              STRH     r0,[r4,#0x18]         ;1212
                  |L14.52|
000034  8b60              LDRH     r0,[r4,#0x1a]         ;1214
000036  1e40              SUBS     r0,r0,#1              ;1214
000038  8360              STRH     r0,[r4,#0x1a]         ;1214
00003a  f7fffffe          BL       vPortExitCritical
00003e  2001              MOVS     r0,#1                 ;1216
000040  e7e8              B        |L14.20|
;;;1219   
                          ENDP


                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;1227   */
;;;1228   static void UartIRQ(UART_T *_pUart)
000000  b570              PUSH     {r4-r6,lr}
;;;1229   {
000002  4604              MOV      r4,r0
;;;1230   	/* 处理接收中断  */
;;;1231   	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1e0              CBZ      r0,|L15.74|
;;;1232   	{
;;;1233   		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;1234   		uint8_t ch;
;;;1235   
;;;1236   		ch = USART_ReceiveData(_pUart->uart);
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c5              UXTB     r5,r0
;;;1237   		_pUart->pRxBuf[_pUart->usRxWrite] = ch;
000018  8ae1              LDRH     r1,[r4,#0x16]
00001a  68a0              LDR      r0,[r4,#8]
00001c  5445              STRB     r5,[r0,r1]
;;;1238   		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
00001e  8ae0              LDRH     r0,[r4,#0x16]
000020  1c40              ADDS     r0,r0,#1
000022  b280              UXTH     r0,r0
000024  82e0              STRH     r0,[r4,#0x16]
000026  89e1              LDRH     r1,[r4,#0xe]
000028  4288              CMP      r0,r1
00002a  db01              BLT      |L15.48|
;;;1239   		{
;;;1240   			_pUart->usRxWrite = 0;
00002c  2000              MOVS     r0,#0
00002e  82e0              STRH     r0,[r4,#0x16]
                  |L15.48|
;;;1241   		}
;;;1242   		if (_pUart->usRxCount < _pUart->usRxBufSize)
000030  8b60              LDRH     r0,[r4,#0x1a]
000032  89e1              LDRH     r1,[r4,#0xe]
000034  4288              CMP      r0,r1
000036  da02              BGE      |L15.62|
;;;1243   		{
;;;1244   			_pUart->usRxCount++;
000038  8b60              LDRH     r0,[r4,#0x1a]
00003a  1c40              ADDS     r0,r0,#1
00003c  8360              STRH     r0,[r4,#0x1a]
                  |L15.62|
;;;1245   		}
;;;1246   
;;;1247   		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;1248   		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;1249   		//if (_pUart->usRxCount == 1)
;;;1250   		{
;;;1251   			if (_pUart->ReciveNew)
00003e  6a60              LDR      r0,[r4,#0x24]
000040  b110              CBZ      r0,|L15.72|
;;;1252   			{
;;;1253   				_pUart->ReciveNew(ch);
000042  4628              MOV      r0,r5
000044  6a61              LDR      r1,[r4,#0x24]
000046  4788              BLX      r1
                  |L15.72|
;;;1254   			}
;;;1255   		}
;;;1256   	}
000048  bf00              NOP      
                  |L15.74|
;;;1257   
;;;1258   	/* 处理发送缓冲区空中断 */
;;;1259   	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
00004a  f2407127          MOV      r1,#0x727
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       USART_GetITStatus
000054  b308              CBZ      r0,|L15.154|
;;;1260   	{
;;;1261   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1262   		if (_pUart->usTxCount == 0)
000056  8aa0              LDRH     r0,[r4,#0x14]
000058  b960              CBNZ     r0,|L15.116|
;;;1263   		{
;;;1264   			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;1265   			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
00005a  2200              MOVS     r2,#0
00005c  f2407127          MOV      r1,#0x727
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       USART_ITConfig
;;;1266   
;;;1267   			/* 使能数据发送完毕中断 */
;;;1268   			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000066  2201              MOVS     r2,#1
000068  f2406126          MOV      r1,#0x626
00006c  6820              LDR      r0,[r4,#0]
00006e  f7fffffe          BL       USART_ITConfig
000072  e037              B        |L15.228|
                  |L15.116|
;;;1269   		}
;;;1270   		else
;;;1271   		{
;;;1272   			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;1273   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000074  8a63              LDRH     r3,[r4,#0x12]
000076  6862              LDR      r2,[r4,#4]
000078  5cd1              LDRB     r1,[r2,r3]
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       USART_SendData
;;;1274   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
000080  8a60              LDRH     r0,[r4,#0x12]
000082  1c40              ADDS     r0,r0,#1
000084  b280              UXTH     r0,r0
000086  8260              STRH     r0,[r4,#0x12]
000088  89a1              LDRH     r1,[r4,#0xc]
00008a  4288              CMP      r0,r1
00008c  db01              BLT      |L15.146|
;;;1275   			{
;;;1276   				_pUart->usTxRead = 0;
00008e  2000              MOVS     r0,#0
000090  8260              STRH     r0,[r4,#0x12]
                  |L15.146|
;;;1277   			}
;;;1278   			_pUart->usTxCount--;
000092  8aa0              LDRH     r0,[r4,#0x14]
000094  1e40              SUBS     r0,r0,#1
000096  82a0              STRH     r0,[r4,#0x14]
000098  e024              B        |L15.228|
                  |L15.154|
;;;1279   		}
;;;1280   
;;;1281   	}
;;;1282   	/* 数据bit位全部发送完毕的中断 */
;;;1283   	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
00009a  f2406126          MOV      r1,#0x626
00009e  6820              LDR      r0,[r4,#0]
0000a0  f7fffffe          BL       USART_GetITStatus
0000a4  b1f0              CBZ      r0,|L15.228|
;;;1284   	{
;;;1285   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1286   		if (_pUart->usTxCount == 0)
0000a6  8aa0              LDRH     r0,[r4,#0x14]
0000a8  b950              CBNZ     r0,|L15.192|
;;;1287   		{
;;;1288   			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;1289   			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
0000aa  2200              MOVS     r2,#0
0000ac  f2406126          MOV      r1,#0x626
0000b0  6820              LDR      r0,[r4,#0]
0000b2  f7fffffe          BL       USART_ITConfig
;;;1290   
;;;1291   			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1292   			if (_pUart->SendOver)
0000b6  6a20              LDR      r0,[r4,#0x20]
0000b8  b1a0              CBZ      r0,|L15.228|
;;;1293   			{
;;;1294   				_pUart->SendOver();
0000ba  6a20              LDR      r0,[r4,#0x20]
0000bc  4780              BLX      r0
0000be  e011              B        |L15.228|
                  |L15.192|
;;;1295   			}
;;;1296   		}
;;;1297   		else
;;;1298   		{
;;;1299   			/* 正常情况下，不会进入此分支 */
;;;1300   
;;;1301   			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1302   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000c0  8a63              LDRH     r3,[r4,#0x12]
0000c2  6862              LDR      r2,[r4,#4]
0000c4  5cd1              LDRB     r1,[r2,r3]
0000c6  6820              LDR      r0,[r4,#0]
0000c8  f7fffffe          BL       USART_SendData
;;;1303   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000cc  8a60              LDRH     r0,[r4,#0x12]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  b280              UXTH     r0,r0
0000d2  8260              STRH     r0,[r4,#0x12]
0000d4  89a1              LDRH     r1,[r4,#0xc]
0000d6  4288              CMP      r0,r1
0000d8  db01              BLT      |L15.222|
;;;1304   			{
;;;1305   				_pUart->usTxRead = 0;
0000da  2000              MOVS     r0,#0
0000dc  8260              STRH     r0,[r4,#0x12]
                  |L15.222|
;;;1306   			}
;;;1307   			_pUart->usTxCount--;
0000de  8aa0              LDRH     r0,[r4,#0x14]
0000e0  1e40              SUBS     r0,r0,#1
0000e2  82a0              STRH     r0,[r4,#0x14]
                  |L15.228|
;;;1308   		}
;;;1309   	}
;;;1310   }
0000e4  bd70              POP      {r4-r6,pc}
;;;1311   
                          ENDP


                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;1116   */
;;;1117   static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1118   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1119   	uint16_t i;
;;;1120   
;;;1121   	for (i = 0; i < _usLen; i++)
000008  2500              MOVS     r5,#0
00000a  e025              B        |L16.88|
                  |L16.12|
;;;1122   	{
;;;1123   		/* 如果发送缓冲区已经满了，则等待缓冲区空 */
;;;1124   	#if 0
;;;1125   		/*
;;;1126   			在调试GPRS例程时，下面的代码出现死机，while 死循环
;;;1127   			原因： 发送第1个字节时 _pUart->usTxWrite = 1；_pUart->usTxRead = 0;
;;;1128   			将导致while(1) 无法退出
;;;1129   		*/
;;;1130   		while (1)
;;;1131   		{
;;;1132   			uint16_t usRead;
;;;1133   
;;;1134   			DISABLE_INT();
;;;1135   			usRead = _pUart->usTxRead;
;;;1136   			ENABLE_INT();
;;;1137   
;;;1138   			if (++usRead >= _pUart->usTxBufSize)
;;;1139   			{
;;;1140   				usRead = 0;
;;;1141   			}
;;;1142   
;;;1143   			if (usRead != _pUart->usTxWrite)
;;;1144   			{
;;;1145   				break;
;;;1146   			}
;;;1147   		}
;;;1148   	#else
;;;1149   		/* 当 _pUart->usTxBufSize == 1 时, 下面的函数会死掉(待完善) */
;;;1150   		while (1)
00000c  e00c              B        |L16.40|
                  |L16.14|
;;;1151   		{
;;;1152   			__IO uint16_t usCount;
;;;1153   
;;;1154   			DISABLE_INT();
00000e  f7fffffe          BL       vPortEnterCritical
;;;1155   			usCount = _pUart->usTxCount;
000012  8aa0              LDRH     r0,[r4,#0x14]
000014  9000              STR      r0,[sp,#0]
;;;1156   			ENABLE_INT();
000016  f7fffffe          BL       vPortExitCritical
;;;1157   
;;;1158   			if (usCount < _pUart->usTxBufSize)
00001a  89a0              LDRH     r0,[r4,#0xc]
00001c  f8bd1000          LDRH     r1,[sp,#0]
000020  4288              CMP      r0,r1
000022  dd00              BLE      |L16.38|
;;;1159   			{
;;;1160   				break;
000024  e001              B        |L16.42|
                  |L16.38|
;;;1161   			}
;;;1162   		}
000026  bf00              NOP      
                  |L16.40|
000028  e7f1              B        |L16.14|
                  |L16.42|
00002a  bf00              NOP                            ;1160
;;;1163   	#endif
;;;1164   
;;;1165   		/* 将新数据填入发送缓冲区 */
;;;1166   		_pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
00002c  5d70              LDRB     r0,[r6,r5]
00002e  8a22              LDRH     r2,[r4,#0x10]
000030  6861              LDR      r1,[r4,#4]
000032  5488              STRB     r0,[r1,r2]
;;;1167   
;;;1168   		DISABLE_INT();
000034  f7fffffe          BL       vPortEnterCritical
;;;1169   		if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
000038  8a20              LDRH     r0,[r4,#0x10]
00003a  1c40              ADDS     r0,r0,#1
00003c  b280              UXTH     r0,r0
00003e  8220              STRH     r0,[r4,#0x10]
000040  89a1              LDRH     r1,[r4,#0xc]
000042  4288              CMP      r0,r1
000044  db01              BLT      |L16.74|
;;;1170   		{
;;;1171   			_pUart->usTxWrite = 0;
000046  2000              MOVS     r0,#0
000048  8220              STRH     r0,[r4,#0x10]
                  |L16.74|
;;;1172   		}
;;;1173   		_pUart->usTxCount++;
00004a  8aa0              LDRH     r0,[r4,#0x14]
00004c  1c40              ADDS     r0,r0,#1
00004e  82a0              STRH     r0,[r4,#0x14]
;;;1174   		ENABLE_INT();
000050  f7fffffe          BL       vPortExitCritical
000054  1c68              ADDS     r0,r5,#1              ;1121
000056  b285              UXTH     r5,r0                 ;1121
                  |L16.88|
000058  42bd              CMP      r5,r7                 ;1121
00005a  dbd7              BLT      |L16.12|
;;;1175   	}
;;;1176   
;;;1177   	USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
00005c  2201              MOVS     r2,#1
00005e  f2407127          MOV      r1,#0x727
000062  6820              LDR      r0,[r4,#0]
000064  f7fffffe          BL       USART_ITConfig
;;;1178   }
000068  bdf8              POP      {r3-r7,pc}
;;;1179   
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;526    */
;;;527    static void UartVarInit(void)
000000  480a              LDR      r0,|L17.44|
;;;528    {
;;;529    #if UART1_FIFO_EN == 1
;;;530    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  490b              LDR      r1,|L17.48|
000004  6008              STR      r0,[r1,#0]  ; g_tUart1
;;;531    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
000006  480b              LDR      r0,|L17.52|
000008  6048              STR      r0,[r1,#4]  ; g_tUart1
;;;532    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000a  480b              LDR      r0,|L17.56|
00000c  6088              STR      r0,[r1,#8]  ; g_tUart1
;;;533    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00000e  f44f6080          MOV      r0,#0x400
000012  8188              STRH     r0,[r1,#0xc]
;;;534    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000014  81c8              STRH     r0,[r1,#0xe]
;;;535    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
000016  2000              MOVS     r0,#0
000018  8208              STRH     r0,[r1,#0x10]
;;;536    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001a  8248              STRH     r0,[r1,#0x12]
;;;537    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
00001c  82c8              STRH     r0,[r1,#0x16]
;;;538    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
00001e  8308              STRH     r0,[r1,#0x18]
;;;539    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000020  8348              STRH     r0,[r1,#0x1a]
;;;540    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000022  8288              STRH     r0,[r1,#0x14]
;;;541    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
000024  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;542    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000026  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;543    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000028  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;544    #endif
;;;545    
;;;546    #if UART2_FIFO_EN == 1
;;;547    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
;;;548    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
;;;549    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
;;;550    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;551    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;552    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;553    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
;;;554    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;555    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
;;;556    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
;;;557    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
;;;558    	g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;559    	g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;560    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;561    #endif
;;;562    
;;;563    #if UART3_FIFO_EN == 1
;;;564    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
;;;565    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
;;;566    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
;;;567    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;568    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;569    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;570    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
;;;571    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;572    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
;;;573    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
;;;574    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
;;;575    	g_tUart3.SendBefor = RS485_SendBefor;		/* 发送数据前的回调函数 */
;;;576    	g_tUart3.SendOver = RS485_SendOver;			/* 发送完毕后的回调函数 */
;;;577    	g_tUart3.ReciveNew = RS485_ReciveNew;		/* 接收到新数据后的回调函数 */
;;;578    #endif
;;;579    
;;;580    #if UART4_FIFO_EN == 1
;;;581    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;582    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;583    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;584    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;585    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;586    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;587    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;588    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;589    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;590    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;591    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
;;;592    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;593    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;594    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;595    #endif
;;;596    
;;;597    #if UART5_FIFO_EN == 1
;;;598    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;599    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;600    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;601    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;602    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;603    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;604    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;605    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;606    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;607    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;608    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
;;;609    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;610    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;611    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;612    #endif
;;;613    
;;;614    
;;;615    #if UART6_FIFO_EN == 1
;;;616    	g_tUart6.uart = USART6;						/* STM32 串口设备 */
;;;617    	g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
;;;618    	g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
;;;619    	g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;620    	g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;621    	g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;622    	g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
;;;623    	g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;624    	g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
;;;625    	g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
;;;626    	g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */
;;;627    	g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;628    	g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;629    	g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;630    #endif
;;;631    }
00002a  4770              BX       lr
;;;632    
                          ENDP

                  |L17.44|
                          DCD      0x40011000
                  |L17.48|
                          DCD      g_tUart1
                  |L17.52|
                          DCD      g_TxBuf1
                  |L17.56|
                          DCD      g_RxBuf1

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;80     */
;;;81     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;82     {
;;;83     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;84     
;;;85     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;86     
;;;87     //	RS485_InitTXE();	/* 配置RS485芯片的发送使能硬件，配置为推挽输出 */
;;;88     
;;;89     	ConfigUartNVIC();	/* 配置串口中断 */
00000a  f7fffffe          BL       ConfigUartNVIC
;;;90     }
00000e  bd10              POP      {r4,pc}
;;;91     
                          ENDP


                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;309    */
;;;310    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;311    {
000002  4603              MOV      r3,r0
;;;312    	UART_T *pUart;
;;;313    
;;;314    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;315    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L19.16|
                  |L19.14|
;;;316    	{
;;;317    		return;
;;;318    	}
;;;319    
;;;320    	pUart->usRxWrite = 0;
;;;321    	pUart->usRxRead = 0;
;;;322    	pUart->usRxCount = 0;
;;;323    }
00000e  bd00              POP      {pc}
                  |L19.16|
000010  2000              MOVS     r0,#0                 ;320
000012  82d0              STRH     r0,[r2,#0x16]         ;320
000014  8310              STRH     r0,[r2,#0x18]         ;321
000016  8350              STRH     r0,[r2,#0x1a]         ;322
000018  bf00              NOP      
00001a  e7f8              B        |L19.14|
;;;324    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;286    */
;;;287    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;288    {
000002  4603              MOV      r3,r0
;;;289    	UART_T *pUart;
;;;290    
;;;291    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;292    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L20.16|
                  |L20.14|
;;;293    	{
;;;294    		return;
;;;295    	}
;;;296    
;;;297    	pUart->usTxWrite = 0;
;;;298    	pUart->usTxRead = 0;
;;;299    	pUart->usTxCount = 0;
;;;300    }
00000e  bd00              POP      {pc}
                  |L20.16|
000010  2000              MOVS     r0,#0                 ;297
000012  8210              STRH     r0,[r2,#0x10]         ;297
000014  8250              STRH     r0,[r2,#0x12]         ;298
000016  8290              STRH     r0,[r2,#0x14]         ;299
000018  bf00              NOP      
00001a  e7f8              B        |L20.14|
;;;301    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;265    */
;;;266    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;267    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;268    	UART_T *pUart;
;;;269    
;;;270    	pUart = ComToUart(_ucPort);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;271    	if (pUart == 0)
00000e  b90c              CBNZ     r4,|L21.20|
;;;272    	{
;;;273    		return 0;
000010  2000              MOVS     r0,#0
                  |L21.18|
;;;274    	}
;;;275    
;;;276    	return UartGetChar(pUart, _pByte);
;;;277    }
000012  bd70              POP      {r4-r6,pc}
                  |L21.20|
000014  4631              MOV      r1,r6                 ;276
000016  4620              MOV      r0,r4                 ;276
000018  f7fffffe          BL       UartGetChar
00001c  e7f9              B        |L21.18|
;;;278    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;224    */
;;;225    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;226    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;227    	UART_T *pUart;
;;;228    
;;;229    	pUart = ComToUart(_ucPort);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ComToUart
000010  4604              MOV      r4,r0
;;;230    	if (pUart == 0)
000012  b90c              CBNZ     r4,|L22.24|
                  |L22.20|
;;;231    	{
;;;232    		return;
;;;233    	}
;;;234    
;;;235    	if (pUart->SendBefor != 0)
;;;236    	{
;;;237    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
;;;238    	}
;;;239    
;;;240    	UartSend(pUart, _ucaBuf, _usLen);
;;;241    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L22.24|
000018  69e0              LDR      r0,[r4,#0x1c]         ;235
00001a  b108              CBZ      r0,|L22.32|
00001c  69e0              LDR      r0,[r4,#0x1c]         ;237
00001e  4780              BLX      r0                    ;237
                  |L22.32|
000020  463a              MOV      r2,r7                 ;240
000022  4631              MOV      r1,r6                 ;240
000024  4620              MOV      r0,r4                 ;240
000026  f7fffffe          BL       UartSend
00002a  bf00              NOP      
00002c  e7f2              B        |L22.20|
;;;242    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;251    */
;;;252    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;253    {
000002  4604              MOV      r4,r0
;;;254    	comSendBuf(_ucPort, &_ucByte, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       comSendBuf
;;;255    }
00000e  bd1c              POP      {r2-r4,pc}
;;;256    
                          ENDP


                          AREA ||i.comSetBaud||, CODE, READONLY, ALIGN=1

                  comSetBaud PROC
;;;333    */
;;;334    void comSetBaud(COM_PORT_E _ucPort, uint32_t _BaudRate)
000000  b570              PUSH     {r4-r6,lr}
;;;335    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;336    	USART_TypeDef* USARTx;
;;;337    	
;;;338    	USARTx = ComToUSARTx(_ucPort);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUSARTx
00000c  4604              MOV      r4,r0
;;;339    	if (USARTx == 0)
00000e  b904              CBNZ     r4,|L24.18|
                  |L24.16|
;;;340    	{
;;;341    		return;
;;;342    	}
;;;343    	
;;;344    	USART_SetBaudRate(USARTx, _BaudRate);
;;;345    }
000010  bd70              POP      {r4-r6,pc}
                  |L24.18|
000012  4631              MOV      r1,r6                 ;344
000014  4620              MOV      r0,r4                 ;344
000016  f7fffffe          BL       USART_SetBaudRate
00001a  bf00              NOP      
00001c  e7f8              B        |L24.16|
;;;346    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;1402   */
;;;1403   int fgetc(FILE *f)
000000  b538              PUSH     {r3-r5,lr}
;;;1404   {
000002  4604              MOV      r4,r0
;;;1405   
;;;1406   #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1407   	uint8_t ucData;
;;;1408   
;;;1409   	while(comGetChar(COM1, &ucData) == 0);
000004  bf00              NOP      
                  |L25.6|
000006  4669              MOV      r1,sp
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comGetChar
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L25.6|
;;;1410   
;;;1411   	return ucData;
000012  f89d0000          LDRB     r0,[sp,#0]
;;;1412   #else
;;;1413   	/* 等待串口1输入数据 */
;;;1414   	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
;;;1415   
;;;1416   	return (int)USART_ReceiveData(USART1);
;;;1417   #endif
;;;1418   }
000016  bd38              POP      {r3-r5,pc}
;;;1419   
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;1369   */
;;;1370   int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;1371   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1372   #if 0	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;1373   	comSendChar(COM1, ch);
;;;1374   
;;;1375   	return ch;
;;;1376   #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;1377   	/* 使用了RL-TCPnet网络协议栈，这里特别调整下 */
;;;1378   	if (ch == '\n')  
000006  2c0a              CMP      r4,#0xa
000008  d10a              BNE      |L26.32|
;;;1379   	{
;;;1380   		USART_SendData(USART1, '\r');
00000a  210d              MOVS     r1,#0xd
00000c  480b              LDR      r0,|L26.60|
00000e  f7fffffe          BL       USART_SendData
;;;1381   		
;;;1382   		/* 等待发送结束 */
;;;1383   		while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET){}
000012  bf00              NOP      
                  |L26.20|
000014  2140              MOVS     r1,#0x40
000016  4809              LDR      r0,|L26.60|
000018  f7fffffe          BL       USART_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0f9              BEQ      |L26.20|
                  |L26.32|
;;;1384   	}
;;;1385   	
;;;1386   	USART_SendData(USART1, (uint8_t) ch);
000020  b2e1              UXTB     r1,r4
000022  4806              LDR      r0,|L26.60|
000024  f7fffffe          BL       USART_SendData
;;;1387   	
;;;1388   	/* 等待发送结束 */
;;;1389   	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET){}
000028  bf00              NOP      
                  |L26.42|
00002a  2140              MOVS     r1,#0x40
00002c  4803              LDR      r0,|L26.60|
00002e  f7fffffe          BL       USART_GetFlagStatus
000032  2800              CMP      r0,#0
000034  d0f9              BEQ      |L26.42|
;;;1390   
;;;1391   	return ch;
000036  4620              MOV      r0,r4
;;;1392   #endif
;;;1393   }
000038  bd70              POP      {r4-r6,pc}
;;;1394   
                          ENDP

00003a  0000              DCW      0x0000
                  |L26.60|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        1024
                  g_RxBuf1
                          %        1024

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 144
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____RRX|
#line 300
|__asm___15_bsp_uart_fifo_c_b28b0d00____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
