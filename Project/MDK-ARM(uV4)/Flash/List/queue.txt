; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\queue.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\queue.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\..\RL-ARM\Config -I..\..\RL-ARM\Driver -I..\..\RL-ARM\RL-RTX\inc -IC:\Keil4.74\ARM\RV31\INC -IC:\Keil4.74\ARM\CMSIS\Include -IC:\Keil4.74\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -D__RTX --omf_browse=.\flash\obj\queue.crf ..\..\FreeRTOS\queue.c]
                          THUMB

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;1857   
;;;1858   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;1859   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1860   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
000006  6c20              LDR      r0,[r4,#0x40]
000008  b170              CBZ      r0,|L1.40|
;;;1861   	{
;;;1862   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
00000a  6c21              LDR      r1,[r4,#0x40]
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  4408              ADD      r0,r0,r1
000010  60e0              STR      r0,[r4,#0xc]
;;;1863   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
000012  6861              LDR      r1,[r4,#4]
000014  68e0              LDR      r0,[r4,#0xc]
000016  4288              CMP      r0,r1
000018  d301              BCC      |L1.30|
;;;1864   		{
;;;1865   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
00001a  6820              LDR      r0,[r4,#0]
00001c  60e0              STR      r0,[r4,#0xc]
                  |L1.30|
;;;1866   		}
;;;1867   		else
;;;1868   		{
;;;1869   			mtCOVERAGE_TEST_MARKER();
;;;1870   		}
;;;1871   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
00001e  4628              MOV      r0,r5
000020  6c22              LDR      r2,[r4,#0x40]
000022  68e1              LDR      r1,[r4,#0xc]
000024  f7fffffe          BL       __aeabi_memcpy
                  |L1.40|
;;;1872   	}
;;;1873   }
000028  bd70              POP      {r4-r6,pc}
;;;1874   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;1783   
;;;1784   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1785   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1786   BaseType_t xReturn = pdFALSE;
00000a  2700              MOVS     r7,#0
;;;1787   
;;;1788   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  b940              CBNZ     r0,|L2.34|
;;;1789   	{
;;;1790   		#if ( configUSE_MUTEXES == 1 )
;;;1791   		{
;;;1792   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000010  6820              LDR      r0,[r4,#0]
000012  bb78              CBNZ     r0,|L2.116|
;;;1793   			{
;;;1794   				/* The mutex is no longer being held. */
;;;1795   				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
000014  6860              LDR      r0,[r4,#4]
000016  f7fffffe          BL       xTaskPriorityDisinherit
00001a  4607              MOV      r7,r0
;;;1796   				pxQueue->pxMutexHolder = NULL;
00001c  2000              MOVS     r0,#0
00001e  6060              STR      r0,[r4,#4]
000020  e028              B        |L2.116|
                  |L2.34|
;;;1797   			}
;;;1798   			else
;;;1799   			{
;;;1800   				mtCOVERAGE_TEST_MARKER();
;;;1801   			}
;;;1802   		}
;;;1803   		#endif /* configUSE_MUTEXES */
;;;1804   	}
;;;1805   	else if( xPosition == queueSEND_TO_BACK )
000022  b97d              CBNZ     r5,|L2.68|
;;;1806   	{
;;;1807   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
000024  4631              MOV      r1,r6
000026  6c22              LDR      r2,[r4,#0x40]
000028  68a0              LDR      r0,[r4,#8]
00002a  f7fffffe          BL       __aeabi_memcpy
;;;1808   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
00002e  6c21              LDR      r1,[r4,#0x40]
000030  68a0              LDR      r0,[r4,#8]
000032  4408              ADD      r0,r0,r1
000034  60a0              STR      r0,[r4,#8]
;;;1809   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000036  e9d41001          LDRD     r1,r0,[r4,#4]
00003a  4288              CMP      r0,r1
00003c  d31a              BCC      |L2.116|
;;;1810   		{
;;;1811   			pxQueue->pcWriteTo = pxQueue->pcHead;
00003e  6820              LDR      r0,[r4,#0]
000040  60a0              STR      r0,[r4,#8]
000042  e017              B        |L2.116|
                  |L2.68|
;;;1812   		}
;;;1813   		else
;;;1814   		{
;;;1815   			mtCOVERAGE_TEST_MARKER();
;;;1816   		}
;;;1817   	}
;;;1818   	else
;;;1819   	{
;;;1820   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000044  4631              MOV      r1,r6
000046  6c22              LDR      r2,[r4,#0x40]
000048  68e0              LDR      r0,[r4,#0xc]
00004a  f7fffffe          BL       __aeabi_memcpy
;;;1821   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
00004e  6c21              LDR      r1,[r4,#0x40]
000050  68e0              LDR      r0,[r4,#0xc]
000052  1a40              SUBS     r0,r0,r1
000054  60e0              STR      r0,[r4,#0xc]
;;;1822   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000056  6821              LDR      r1,[r4,#0]
000058  68e0              LDR      r0,[r4,#0xc]
00005a  4288              CMP      r0,r1
00005c  d203              BCS      |L2.102|
;;;1823   		{
;;;1824   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
00005e  6c21              LDR      r1,[r4,#0x40]
000060  6860              LDR      r0,[r4,#4]
000062  1a40              SUBS     r0,r0,r1
000064  60e0              STR      r0,[r4,#0xc]
                  |L2.102|
;;;1825   		}
;;;1826   		else
;;;1827   		{
;;;1828   			mtCOVERAGE_TEST_MARKER();
;;;1829   		}
;;;1830   
;;;1831   		if( xPosition == queueOVERWRITE )
000066  2d02              CMP      r5,#2
000068  d104              BNE      |L2.116|
;;;1832   		{
;;;1833   			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
00006a  6ba0              LDR      r0,[r4,#0x38]
00006c  b110              CBZ      r0,|L2.116|
;;;1834   			{
;;;1835   				/* An item is not being added but overwritten, so subtract
;;;1836   				one from the recorded number of items in the queue so when
;;;1837   				one is added again below the number of recorded items remains
;;;1838   				correct. */
;;;1839   				--( pxQueue->uxMessagesWaiting );
00006e  6ba0              LDR      r0,[r4,#0x38]
000070  1e40              SUBS     r0,r0,#1
000072  63a0              STR      r0,[r4,#0x38]
                  |L2.116|
;;;1840   			}
;;;1841   			else
;;;1842   			{
;;;1843   				mtCOVERAGE_TEST_MARKER();
;;;1844   			}
;;;1845   		}
;;;1846   		else
;;;1847   		{
;;;1848   			mtCOVERAGE_TEST_MARKER();
;;;1849   		}
;;;1850   	}
;;;1851   
;;;1852   	++( pxQueue->uxMessagesWaiting );
000074  6ba0              LDR      r0,[r4,#0x38]
000076  1c40              ADDS     r0,r0,#1
000078  63a0              STR      r0,[r4,#0x38]
;;;1853   
;;;1854   	return xReturn;
00007a  4638              MOV      r0,r7
;;;1855   }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;1856   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=1

                  prvIsQueueEmpty PROC
;;;1990   
;;;1991   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1992   {
000002  4605              MOV      r5,r0
;;;1993   BaseType_t xReturn;
;;;1994   
;;;1995   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1996   	{
;;;1997   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  b908              CBNZ     r0,|L3.16|
;;;1998   		{
;;;1999   			xReturn = pdTRUE;
00000c  2401              MOVS     r4,#1
00000e  e000              B        |L3.18|
                  |L3.16|
;;;2000   		}
;;;2001   		else
;;;2002   		{
;;;2003   			xReturn = pdFALSE;
000010  2400              MOVS     r4,#0
                  |L3.18|
;;;2004   		}
;;;2005   	}
;;;2006   	taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;2007   
;;;2008   	return xReturn;
000016  4620              MOV      r0,r4
;;;2009   }
000018  bd70              POP      {r4-r6,pc}
;;;2010   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueFull||, CODE, READONLY, ALIGN=1

                  prvIsQueueFull PROC
;;;2029   
;;;2030   static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2031   {
000002  4605              MOV      r5,r0
;;;2032   BaseType_t xReturn;
;;;2033   
;;;2034   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2035   	{
;;;2036   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  6be9              LDR      r1,[r5,#0x3c]
00000c  4288              CMP      r0,r1
00000e  d101              BNE      |L4.20|
;;;2037   		{
;;;2038   			xReturn = pdTRUE;
000010  2401              MOVS     r4,#1
000012  e000              B        |L4.22|
                  |L4.20|
;;;2039   		}
;;;2040   		else
;;;2041   		{
;;;2042   			xReturn = pdFALSE;
000014  2400              MOVS     r4,#0
                  |L4.22|
;;;2043   		}
;;;2044   	}
;;;2045   	taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;2046   
;;;2047   	return xReturn;
00001a  4620              MOV      r0,r4
;;;2048   }
00001c  bd70              POP      {r4-r6,pc}
;;;2049   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;1875   
;;;1876   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  b510              PUSH     {r4,lr}
;;;1877   {
000002  4604              MOV      r4,r0
;;;1878   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1879   
;;;1880   	/* The lock counts contains the number of extra data items placed or
;;;1881   	removed from the queue while the queue was locked.  When a queue is
;;;1882   	locked items can be added or removed, but the event lists cannot be
;;;1883   	updated. */
;;;1884   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1885   	{
;;;1886   		/* See if data was added to the queue while it was locked. */
;;;1887   		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
000008  e011              B        |L5.46|
                  |L5.10|
;;;1888   		{
;;;1889   			/* Data was posted while the queue was locked.  Are any tasks
;;;1890   			blocked waiting for data to become available? */
;;;1891   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1892   			{
;;;1893   				if( pxQueue->pxQueueSetContainer != NULL )
;;;1894   				{
;;;1895   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1896   					{
;;;1897   						/* The queue is a member of a queue set, and posting to
;;;1898   						the queue set caused a higher priority task to unblock.
;;;1899   						A context switch is required. */
;;;1900   						vTaskMissedYield();
;;;1901   					}
;;;1902   					else
;;;1903   					{
;;;1904   						mtCOVERAGE_TEST_MARKER();
;;;1905   					}
;;;1906   				}
;;;1907   				else
;;;1908   				{
;;;1909   					/* Tasks that are removed from the event list will get added to
;;;1910   					the pending ready list as the scheduler is still suspended. */
;;;1911   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1912   					{
;;;1913   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1914   						{
;;;1915   							/* The task waiting has a higher priority so record that a
;;;1916   							context	switch is required. */
;;;1917   							vTaskMissedYield();
;;;1918   						}
;;;1919   						else
;;;1920   						{
;;;1921   							mtCOVERAGE_TEST_MARKER();
;;;1922   						}
;;;1923   					}
;;;1924   					else
;;;1925   					{
;;;1926   						break;
;;;1927   					}
;;;1928   				}
;;;1929   			}
;;;1930   			#else /* configUSE_QUEUE_SETS */
;;;1931   			{
;;;1932   				/* Tasks that are removed from the event list will get added to
;;;1933   				the pending ready list as the scheduler is still suspended. */
;;;1934   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00000a  6a60              LDR      r0,[r4,#0x24]
00000c  b908              CBNZ     r0,|L5.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L5.20|
                  |L5.18|
000012  2000              MOVS     r0,#0
                  |L5.20|
000014  b938              CBNZ     r0,|L5.38|
;;;1935   				{
;;;1936   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000016  f1040024          ADD      r0,r4,#0x24
00001a  f7fffffe          BL       xTaskRemoveFromEventList
00001e  b118              CBZ      r0,|L5.40|
;;;1937   					{
;;;1938   						/* The task waiting has a higher priority so record that a
;;;1939   						context	switch is required. */
;;;1940   						vTaskMissedYield();
000020  f7fffffe          BL       vTaskMissedYield
000024  e000              B        |L5.40|
                  |L5.38|
;;;1941   					}
;;;1942   					else
;;;1943   					{
;;;1944   						mtCOVERAGE_TEST_MARKER();
;;;1945   					}
;;;1946   				}
;;;1947   				else
;;;1948   				{
;;;1949   					break;
000026  e005              B        |L5.52|
                  |L5.40|
;;;1950   				}
;;;1951   			}
;;;1952   			#endif /* configUSE_QUEUE_SETS */
;;;1953   
;;;1954   			--( pxQueue->xTxLock );
000028  6ca0              LDR      r0,[r4,#0x48]
00002a  1e40              SUBS     r0,r0,#1
00002c  64a0              STR      r0,[r4,#0x48]
                  |L5.46|
00002e  6ca0              LDR      r0,[r4,#0x48]         ;1887
000030  2800              CMP      r0,#0                 ;1887
000032  dcea              BGT      |L5.10|
                  |L5.52|
000034  bf00              NOP                            ;1949
;;;1955   		}
;;;1956   
;;;1957   		pxQueue->xTxLock = queueUNLOCKED;
000036  f04f30ff          MOV      r0,#0xffffffff
00003a  64a0              STR      r0,[r4,#0x48]
;;;1958   	}
;;;1959   	taskEXIT_CRITICAL();
00003c  f7fffffe          BL       vPortExitCritical
;;;1960   
;;;1961   	/* Do the same for the Rx lock. */
;;;1962   	taskENTER_CRITICAL();
000040  f7fffffe          BL       vPortEnterCritical
;;;1963   	{
;;;1964   		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
000044  e011              B        |L5.106|
                  |L5.70|
;;;1965   		{
;;;1966   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000046  6920              LDR      r0,[r4,#0x10]
000048  b908              CBNZ     r0,|L5.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L5.80|
                  |L5.78|
00004e  2000              MOVS     r0,#0
                  |L5.80|
000050  b950              CBNZ     r0,|L5.104|
;;;1967   			{
;;;1968   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000052  f1040010          ADD      r0,r4,#0x10
000056  f7fffffe          BL       xTaskRemoveFromEventList
00005a  b108              CBZ      r0,|L5.96|
;;;1969   				{
;;;1970   					vTaskMissedYield();
00005c  f7fffffe          BL       vTaskMissedYield
                  |L5.96|
;;;1971   				}
;;;1972   				else
;;;1973   				{
;;;1974   					mtCOVERAGE_TEST_MARKER();
;;;1975   				}
;;;1976   
;;;1977   				--( pxQueue->xRxLock );
000060  6c60              LDR      r0,[r4,#0x44]
000062  1e40              SUBS     r0,r0,#1
000064  6460              STR      r0,[r4,#0x44]
000066  e000              B        |L5.106|
                  |L5.104|
;;;1978   			}
;;;1979   			else
;;;1980   			{
;;;1981   				break;
000068  e002              B        |L5.112|
                  |L5.106|
00006a  6c60              LDR      r0,[r4,#0x44]         ;1964
00006c  2800              CMP      r0,#0                 ;1964
00006e  dcea              BGT      |L5.70|
                  |L5.112|
000070  bf00              NOP      
;;;1982   			}
;;;1983   		}
;;;1984   
;;;1985   		pxQueue->xRxLock = queueUNLOCKED;
000072  f04f30ff          MOV      r0,#0xffffffff
000076  6460              STR      r0,[r4,#0x44]
;;;1986   	}
;;;1987   	taskEXIT_CRITICAL();
000078  f7fffffe          BL       vPortExitCritical
;;;1988   }
00007c  bd10              POP      {r4,pc}
;;;1989   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.ucQueueGetQueueType||, CODE, READONLY, ALIGN=1

                  ucQueueGetQueueType PROC
;;;1775   
;;;1776   	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;1777   	{
;;;1778   		return ( ( Queue_t * ) xQueue )->ucQueueType;
000002  f8910050          LDRB     r0,[r1,#0x50]
;;;1779   	}
000006  4770              BX       lr
;;;1780   
                          ENDP


                          AREA ||i.uxQueueGetQueueNumber||, CODE, READONLY, ALIGN=1

                  uxQueueGetQueueNumber PROC
;;;1755   
;;;1756   	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;1757   	{
;;;1758   		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
000002  6cc8              LDR      r0,[r1,#0x4c]
;;;1759   	}
000004  4770              BX       lr
;;;1760   
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1691   
;;;1692   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1693   {
000002  4604              MOV      r4,r0
;;;1694   UBaseType_t uxReturn;
;;;1695   
;;;1696   	configASSERT( xQueue );
000004  b954              CBNZ     r4,|L8.28|
000006  bf00              NOP      
000008  2010              MOVS     r0,#0x10
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L8.26|
00001a  e7fe              B        |L8.26|
                  |L8.28|
;;;1697   
;;;1698   	taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;1699   	{
;;;1700   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000020  6ba5              LDR      r5,[r4,#0x38]
;;;1701   	}
;;;1702   	taskEXIT_CRITICAL();
000022  f7fffffe          BL       vPortExitCritical
;;;1703   
;;;1704   	return uxReturn;
000026  4628              MOV      r0,r5
;;;1705   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000028  bd70              POP      {r4-r6,pc}
;;;1706   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1725   
;;;1726   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;1727   {
;;;1728   UBaseType_t uxReturn;
;;;1729   
;;;1730   	configASSERT( xQueue );
000002  b951              CBNZ     r1,|L9.26|
000004  bf00              NOP      
000006  2210              MOVS     r2,#0x10
000008  f3828811          MSR      BASEPRI,r2
00000c  f3bf8f4f          DSB      
000010  f3bf8f6f          ISB      
000014  bf00              NOP      
000016  bf00              NOP      
                  |L9.24|
000018  e7fe              B        |L9.24|
                  |L9.26|
;;;1731   
;;;1732   	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
00001a  6b88              LDR      r0,[r1,#0x38]
;;;1733   
;;;1734   	return uxReturn;
;;;1735   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00001c  4770              BX       lr
;;;1736   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=1

                  uxQueueSpacesAvailable PROC
;;;1707   
;;;1708   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1709   {
000002  4604              MOV      r4,r0
;;;1710   UBaseType_t uxReturn;
;;;1711   Queue_t *pxQueue;
;;;1712   
;;;1713   	pxQueue = ( Queue_t * ) xQueue;
000004  4625              MOV      r5,r4
;;;1714   	configASSERT( pxQueue );
000006  b955              CBNZ     r5,|L10.30|
000008  bf00              NOP      
00000a  2010              MOVS     r0,#0x10
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L10.28|
00001c  e7fe              B        |L10.28|
                  |L10.30|
;;;1715   
;;;1716   	taskENTER_CRITICAL();
00001e  f7fffffe          BL       vPortEnterCritical
;;;1717   	{
;;;1718   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
000022  e9d5100e          LDRD     r1,r0,[r5,#0x38]
000026  1a46              SUBS     r6,r0,r1
;;;1719   	}
;;;1720   	taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;1721   
;;;1722   	return uxReturn;
00002c  4630              MOV      r0,r6
;;;1723   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00002e  bd70              POP      {r4-r6,pc}
;;;1724   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1737   
;;;1738   void vQueueDelete( QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1739   {
000002  4604              MOV      r4,r0
;;;1740   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000004  4625              MOV      r5,r4
;;;1741   
;;;1742   	configASSERT( pxQueue );
000006  b955              CBNZ     r5,|L11.30|
000008  bf00              NOP      
00000a  2010              MOVS     r0,#0x10
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L11.28|
00001c  e7fe              B        |L11.28|
                  |L11.30|
;;;1743   
;;;1744   	traceQUEUE_DELETE( pxQueue );
;;;1745   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1746   	{
;;;1747   		vQueueUnregisterQueue( pxQueue );
;;;1748   	}
;;;1749   	#endif
;;;1750   	vPortFree( pxQueue );
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       vPortFree
;;;1751   }
000024  bd70              POP      {r4-r6,pc}
;;;1752   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueSetQueueNumber||, CODE, READONLY, ALIGN=1

                  vQueueSetQueueNumber PROC
;;;1765   
;;;1766   	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
000000  64c1              STR      r1,[r0,#0x4c]
;;;1767   	{
;;;1768   		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
;;;1769   	}
000002  4770              BX       lr
;;;1770   
                          ENDP


                          AREA ||i.xQueueCreateMutex||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutex PROC
;;;390    
;;;391    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
000000  b570              PUSH     {r4-r6,lr}
;;;392    	{
000002  4605              MOV      r5,r0
;;;393    	Queue_t *pxNewQueue;
;;;394    
;;;395    		/* Prevent compiler warnings about unused parameters if
;;;396    		configUSE_TRACE_FACILITY does not equal 1. */
;;;397    		( void ) ucQueueType;
;;;398    
;;;399    		/* Allocate the new queue structure. */
;;;400    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
000004  2054              MOVS     r0,#0x54
000006  f7fffffe          BL       pvPortMalloc
00000a  4604              MOV      r4,r0
;;;401    		if( pxNewQueue != NULL )
00000c  b1e4              CBZ      r4,|L13.72|
;;;402    		{
;;;403    			/* Information required for priority inheritance. */
;;;404    			pxNewQueue->pxMutexHolder = NULL;
00000e  2000              MOVS     r0,#0
000010  6060              STR      r0,[r4,#4]
;;;405    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
000012  6020              STR      r0,[r4,#0]
;;;406    
;;;407    			/* Queues used as a mutex no data is actually copied into or out
;;;408    			of the queue. */
;;;409    			pxNewQueue->pcWriteTo = NULL;
000014  60a0              STR      r0,[r4,#8]
;;;410    			pxNewQueue->u.pcReadFrom = NULL;
000016  60e0              STR      r0,[r4,#0xc]
;;;411    
;;;412    			/* Each mutex has a length of 1 (like a binary semaphore) and
;;;413    			an item size of 0 as nothing is actually copied into or out
;;;414    			of the mutex. */
;;;415    			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000018  63a0              STR      r0,[r4,#0x38]
;;;416    			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
00001a  2001              MOVS     r0,#1
00001c  63e0              STR      r0,[r4,#0x3c]
;;;417    			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
00001e  2000              MOVS     r0,#0
000020  6420              STR      r0,[r4,#0x40]
;;;418    			pxNewQueue->xRxLock = queueUNLOCKED;
000022  1e40              SUBS     r0,r0,#1
000024  6460              STR      r0,[r4,#0x44]
;;;419    			pxNewQueue->xTxLock = queueUNLOCKED;
000026  64a0              STR      r0,[r4,#0x48]
;;;420    
;;;421    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;422    			{
;;;423    				pxNewQueue->ucQueueType = ucQueueType;
000028  f8845050          STRB     r5,[r4,#0x50]
;;;424    			}
;;;425    			#endif
;;;426    
;;;427    			#if ( configUSE_QUEUE_SETS == 1 )
;;;428    			{
;;;429    				pxNewQueue->pxQueueSetContainer = NULL;
;;;430    			}
;;;431    			#endif
;;;432    
;;;433    			/* Ensure the event queues start with the correct state. */
;;;434    			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
00002c  f1040010          ADD      r0,r4,#0x10
000030  f7fffffe          BL       vListInitialise
;;;435    			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
000034  f1040024          ADD      r0,r4,#0x24
000038  f7fffffe          BL       vListInitialise
;;;436    
;;;437    			traceCREATE_MUTEX( pxNewQueue );
;;;438    
;;;439    			/* Start with the semaphore in the expected state. */
;;;440    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
00003c  2300              MOVS     r3,#0
00003e  461a              MOV      r2,r3
000040  4619              MOV      r1,r3
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       xQueueGenericSend
                  |L13.72|
;;;441    		}
;;;442    		else
;;;443    		{
;;;444    			traceCREATE_MUTEX_FAILED();
;;;445    		}
;;;446    
;;;447    		return pxNewQueue;
000048  4620              MOV      r0,r4
;;;448    	}
00004a  bd70              POP      {r4-r6,pc}
;;;449    
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;312    
;;;313    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;314    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;315    Queue_t *pxNewQueue;
;;;316    size_t xQueueSizeInBytes;
;;;317    QueueHandle_t xReturn = NULL;
00000a  f04f0900          MOV      r9,#0
;;;318    
;;;319    	/* Remove compiler warnings about unused parameters should
;;;320    	configUSE_TRACE_FACILITY not be set to 1. */
;;;321    	( void ) ucQueueType;
;;;322    
;;;323    	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
00000e  b10e              CBZ      r6,|L14.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L14.22|
                  |L14.20|
000014  2000              MOVS     r0,#0
                  |L14.22|
000016  b950              CBNZ     r0,|L14.46|
000018  bf00              NOP      
00001a  2010              MOVS     r0,#0x10
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L14.44|
00002c  e7fe              B        |L14.44|
                  |L14.46|
;;;324    
;;;325    	if( uxItemSize == ( UBaseType_t ) 0 )
00002e  b90d              CBNZ     r5,|L14.52|
;;;326    	{
;;;327    		/* There is not going to be a queue storage area. */
;;;328    		xQueueSizeInBytes = ( size_t ) 0;
000030  2700              MOVS     r7,#0
000032  e002              B        |L14.58|
                  |L14.52|
;;;329    	}
;;;330    	else
;;;331    	{
;;;332    		/* The queue is one byte longer than asked for to make wrap checking
;;;333    		easier/faster. */
;;;334    		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000034  fb06f005          MUL      r0,r6,r5
000038  1c47              ADDS     r7,r0,#1
                  |L14.58|
;;;335    	}
;;;336    
;;;337    	/* Allocate the new queue structure and storage area. */
;;;338    	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
00003a  f1070054          ADD      r0,r7,#0x54
00003e  f7fffffe          BL       pvPortMalloc
000042  4604              MOV      r4,r0
;;;339    
;;;340    	if( pxNewQueue != NULL )
000044  b174              CBZ      r4,|L14.100|
;;;341    	{
;;;342    		if( uxItemSize == ( UBaseType_t ) 0 )
000046  b90d              CBNZ     r5,|L14.76|
;;;343    		{
;;;344    			/* No RAM was allocated for the queue storage area, but PC head
;;;345    			cannot be set to NULL because NULL is used as a key to say the queue
;;;346    			is used as a mutex.  Therefore just set pcHead to point to the queue
;;;347    			as a benign value that is known to be within the memory map. */
;;;348    			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
000048  6024              STR      r4,[r4,#0]
00004a  e002              B        |L14.82|
                  |L14.76|
;;;349    		}
;;;350    		else
;;;351    		{
;;;352    			/* Jump past the queue structure to find the location of the queue
;;;353    			storage area. */
;;;354    			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
00004c  f1040054          ADD      r0,r4,#0x54
000050  6020              STR      r0,[r4,#0]
                  |L14.82|
;;;355    		}
;;;356    
;;;357    		/* Initialise the queue members as described above where the queue type
;;;358    		is defined. */
;;;359    		pxNewQueue->uxLength = uxQueueLength;
000052  63e6              STR      r6,[r4,#0x3c]
;;;360    		pxNewQueue->uxItemSize = uxItemSize;
000054  6425              STR      r5,[r4,#0x40]
;;;361    		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
000056  2101              MOVS     r1,#1
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       xQueueGenericReset
;;;362    
;;;363    		#if ( configUSE_TRACE_FACILITY == 1 )
;;;364    		{
;;;365    			pxNewQueue->ucQueueType = ucQueueType;
00005e  f8848050          STRB     r8,[r4,#0x50]
;;;366    		}
;;;367    		#endif /* configUSE_TRACE_FACILITY */
;;;368    
;;;369    		#if( configUSE_QUEUE_SETS == 1 )
;;;370    		{
;;;371    			pxNewQueue->pxQueueSetContainer = NULL;
;;;372    		}
;;;373    		#endif /* configUSE_QUEUE_SETS */
;;;374    
;;;375    		traceQUEUE_CREATE( pxNewQueue );
;;;376    		xReturn = pxNewQueue;
000062  46a1              MOV      r9,r4
                  |L14.100|
;;;377    	}
;;;378    	else
;;;379    	{
;;;380    		mtCOVERAGE_TEST_MARKER();
;;;381    	}
;;;382    
;;;383    	configASSERT( xReturn );
000064  f1b90f00          CMP      r9,#0
000068  d10a              BNE      |L14.128|
00006a  bf00              NOP      
00006c  2010              MOVS     r0,#0x10
00006e  f3808811          MSR      BASEPRI,r0
000072  f3bf8f4f          DSB      
000076  f3bf8f6f          ISB      
00007a  bf00              NOP      
00007c  bf00              NOP      
                  |L14.126|
00007e  e7fe              B        |L14.126|
                  |L14.128|
;;;384    
;;;385    	return xReturn;
000080  4648              MOV      r0,r9
;;;386    }
000082  e8bd87f0          POP      {r4-r10,pc}
;;;387    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericReceive||, CODE, READONLY, ALIGN=2

                  xQueueGenericReceive PROC
;;;1363   
;;;1364   BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
000000  e92d43ff          PUSH     {r0-r9,lr}
;;;1365   {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  461f              MOV      r7,r3
;;;1366   BaseType_t xEntryTimeSet = pdFALSE;
00000c  f04f0900          MOV      r9,#0
;;;1367   TimeOut_t xTimeOut;
;;;1368   int8_t *pcOriginalReadPosition;
;;;1369   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000010  462c              MOV      r4,r5
;;;1370   
;;;1371   	configASSERT( pxQueue );
000012  b954              CBNZ     r4,|L15.42|
000014  bf00              NOP      
000016  2010              MOVS     r0,#0x10
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L15.40|
000028  e7fe              B        |L15.40|
                  |L15.42|
;;;1372   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00002a  b90e              CBNZ     r6,|L15.48|
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  b908              CBNZ     r0,|L15.52|
                  |L15.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L15.54|
                  |L15.52|
000034  2000              MOVS     r0,#0
                  |L15.54|
000036  b950              CBNZ     r0,|L15.78|
000038  bf00              NOP      
00003a  2010              MOVS     r0,#0x10
00003c  f3808811          MSR      BASEPRI,r0
000040  f3bf8f4f          DSB      
000044  f3bf8f6f          ISB      
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L15.76|
00004c  e7fe              B        |L15.76|
                  |L15.78|
;;;1373   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1374   	{
;;;1375   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1376   	}
;;;1377   	#endif
;;;1378   
;;;1379   	/* This function relaxes the coding standard somewhat to allow return
;;;1380   	statements within the function itself.  This is done in the interest
;;;1381   	of execution time efficiency. */
;;;1382   
;;;1383   	for( ;; )
00004e  bf00              NOP      
                  |L15.80|
;;;1384   	{
;;;1385   		taskENTER_CRITICAL();
000050  f7fffffe          BL       vPortEnterCritical
;;;1386   		{
;;;1387   			/* Is there data in the queue now?  To be running the calling task
;;;1388   			must be	the highest priority task wanting to access the queue. */
;;;1389   			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000054  6ba0              LDR      r0,[r4,#0x38]
000056  2800              CMP      r0,#0
000058  d03d              BEQ      |L15.214|
;;;1390   			{
;;;1391   				/* Remember the read position in case the queue is only being
;;;1392   				peeked. */
;;;1393   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
00005a  f8d4800c          LDR      r8,[r4,#0xc]
;;;1394   
;;;1395   				prvCopyDataFromQueue( pxQueue, pvBuffer );
00005e  4631              MOV      r1,r6
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       prvCopyDataFromQueue
;;;1396   
;;;1397   				if( xJustPeeking == pdFALSE )
000066  b9df              CBNZ     r7,|L15.160|
;;;1398   				{
;;;1399   					traceQUEUE_RECEIVE( pxQueue );
;;;1400   
;;;1401   					/* Actually removing data, not just peeking. */
;;;1402   					--( pxQueue->uxMessagesWaiting );
000068  6ba0              LDR      r0,[r4,#0x38]
00006a  1e40              SUBS     r0,r0,#1
00006c  63a0              STR      r0,[r4,#0x38]
;;;1403   
;;;1404   					#if ( configUSE_MUTEXES == 1 )
;;;1405   					{
;;;1406   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
00006e  6820              LDR      r0,[r4,#0]
000070  b910              CBNZ     r0,|L15.120|
;;;1407   						{
;;;1408   							/* Record the information required to implement
;;;1409   							priority inheritance should it become necessary. */
;;;1410   							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
000072  f7fffffe          BL       pvTaskIncrementMutexHeldCount
000076  6060              STR      r0,[r4,#4]
                  |L15.120|
;;;1411   						}
;;;1412   						else
;;;1413   						{
;;;1414   							mtCOVERAGE_TEST_MARKER();
;;;1415   						}
;;;1416   					}
;;;1417   					#endif /* configUSE_MUTEXES */
;;;1418   
;;;1419   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000078  6920              LDR      r0,[r4,#0x10]
00007a  b908              CBNZ     r0,|L15.128|
00007c  2001              MOVS     r0,#1
00007e  e000              B        |L15.130|
                  |L15.128|
000080  2000              MOVS     r0,#0
                  |L15.130|
000082  bb10              CBNZ     r0,|L15.202|
;;;1420   					{
;;;1421   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
000084  f1040010          ADD      r0,r4,#0x10
000088  f7fffffe          BL       xTaskRemoveFromEventList
00008c  2801              CMP      r0,#1
00008e  d11c              BNE      |L15.202|
;;;1422   						{
;;;1423   							queueYIELD_IF_USING_PREEMPTION();
000090  0700              LSLS     r0,r0,#28
000092  493a              LDR      r1,|L15.380|
000094  6008              STR      r0,[r1,#0]
000096  f3bf8f4f          DSB      
00009a  f3bf8f6f          ISB      
00009e  e014              B        |L15.202|
                  |L15.160|
;;;1424   						}
;;;1425   						else
;;;1426   						{
;;;1427   							mtCOVERAGE_TEST_MARKER();
;;;1428   						}
;;;1429   					}
;;;1430   					else
;;;1431   					{
;;;1432   						mtCOVERAGE_TEST_MARKER();
;;;1433   					}
;;;1434   				}
;;;1435   				else
;;;1436   				{
;;;1437   					traceQUEUE_PEEK( pxQueue );
;;;1438   
;;;1439   					/* The data is not being removed, so reset the read
;;;1440   					pointer. */
;;;1441   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
0000a0  f8c4800c          STR      r8,[r4,#0xc]
;;;1442   
;;;1443   					/* The data is being left in the queue, so see if there are
;;;1444   					any other tasks waiting for the data. */
;;;1445   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000a4  6a60              LDR      r0,[r4,#0x24]
0000a6  b908              CBNZ     r0,|L15.172|
0000a8  2001              MOVS     r0,#1
0000aa  e000              B        |L15.174|
                  |L15.172|
0000ac  2000              MOVS     r0,#0
                  |L15.174|
0000ae  b960              CBNZ     r0,|L15.202|
;;;1446   					{
;;;1447   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000b0  f1040024          ADD      r0,r4,#0x24
0000b4  f7fffffe          BL       xTaskRemoveFromEventList
0000b8  b138              CBZ      r0,|L15.202|
;;;1448   						{
;;;1449   							/* The task waiting has a higher priority than this task. */
;;;1450   							queueYIELD_IF_USING_PREEMPTION();
0000ba  f04f5080          MOV      r0,#0x10000000
0000be  492f              LDR      r1,|L15.380|
0000c0  6008              STR      r0,[r1,#0]
0000c2  f3bf8f4f          DSB      
0000c6  f3bf8f6f          ISB      
                  |L15.202|
;;;1451   						}
;;;1452   						else
;;;1453   						{
;;;1454   							mtCOVERAGE_TEST_MARKER();
;;;1455   						}
;;;1456   					}
;;;1457   					else
;;;1458   					{
;;;1459   						mtCOVERAGE_TEST_MARKER();
;;;1460   					}
;;;1461   				}
;;;1462   
;;;1463   				taskEXIT_CRITICAL();
0000ca  f7fffffe          BL       vPortExitCritical
;;;1464   				return pdPASS;
0000ce  2001              MOVS     r0,#1
                  |L15.208|
;;;1465   			}
;;;1466   			else
;;;1467   			{
;;;1468   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1469   				{
;;;1470   					/* The queue was empty and no block time is specified (or
;;;1471   					the block time has expired) so leave now. */
;;;1472   					taskEXIT_CRITICAL();
;;;1473   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1474   					return errQUEUE_EMPTY;
;;;1475   				}
;;;1476   				else if( xEntryTimeSet == pdFALSE )
;;;1477   				{
;;;1478   					/* The queue was empty and a block time was specified so
;;;1479   					configure the timeout structure. */
;;;1480   					vTaskSetTimeOutState( &xTimeOut );
;;;1481   					xEntryTimeSet = pdTRUE;
;;;1482   				}
;;;1483   				else
;;;1484   				{
;;;1485   					/* Entry time was already set. */
;;;1486   					mtCOVERAGE_TEST_MARKER();
;;;1487   				}
;;;1488   			}
;;;1489   		}
;;;1490   		taskEXIT_CRITICAL();
;;;1491   
;;;1492   		/* Interrupts and other tasks can send to and receive from the queue
;;;1493   		now the critical section has been exited. */
;;;1494   
;;;1495   		vTaskSuspendAll();
;;;1496   		prvLockQueue( pxQueue );
;;;1497   
;;;1498   		/* Update the timeout state to see if it has expired yet. */
;;;1499   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1500   		{
;;;1501   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1502   			{
;;;1503   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1504   
;;;1505   				#if ( configUSE_MUTEXES == 1 )
;;;1506   				{
;;;1507   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1508   					{
;;;1509   						taskENTER_CRITICAL();
;;;1510   						{
;;;1511   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1512   						}
;;;1513   						taskEXIT_CRITICAL();
;;;1514   					}
;;;1515   					else
;;;1516   					{
;;;1517   						mtCOVERAGE_TEST_MARKER();
;;;1518   					}
;;;1519   				}
;;;1520   				#endif
;;;1521   
;;;1522   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1523   				prvUnlockQueue( pxQueue );
;;;1524   				if( xTaskResumeAll() == pdFALSE )
;;;1525   				{
;;;1526   					portYIELD_WITHIN_API();
;;;1527   				}
;;;1528   				else
;;;1529   				{
;;;1530   					mtCOVERAGE_TEST_MARKER();
;;;1531   				}
;;;1532   			}
;;;1533   			else
;;;1534   			{
;;;1535   				/* Try again. */
;;;1536   				prvUnlockQueue( pxQueue );
;;;1537   				( void ) xTaskResumeAll();
;;;1538   			}
;;;1539   		}
;;;1540   		else
;;;1541   		{
;;;1542   			prvUnlockQueue( pxQueue );
;;;1543   			( void ) xTaskResumeAll();
;;;1544   			traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1545   			return errQUEUE_EMPTY;
;;;1546   		}
;;;1547   	}
;;;1548   }
0000d0  b007              ADD      sp,sp,#0x1c
0000d2  e8bd83f0          POP      {r4-r9,pc}
                  |L15.214|
0000d6  9805              LDR      r0,[sp,#0x14]         ;1468
0000d8  b918              CBNZ     r0,|L15.226|
0000da  f7fffffe          BL       vPortExitCritical
0000de  2000              MOVS     r0,#0                 ;1474
0000e0  e7f6              B        |L15.208|
                  |L15.226|
0000e2  f1b90f00          CMP      r9,#0                 ;1476
0000e6  d104              BNE      |L15.242|
0000e8  a801              ADD      r0,sp,#4              ;1480
0000ea  f7fffffe          BL       vTaskSetTimeOutState
0000ee  f04f0901          MOV      r9,#1                 ;1481
                  |L15.242|
0000f2  f7fffffe          BL       vPortExitCritical
0000f6  f7fffffe          BL       vTaskSuspendAll
0000fa  f7fffffe          BL       vPortEnterCritical
0000fe  6c60              LDR      r0,[r4,#0x44]         ;1496
000100  1c40              ADDS     r0,r0,#1              ;1496
000102  d100              BNE      |L15.262|
000104  6460              STR      r0,[r4,#0x44]         ;1496
                  |L15.262|
000106  6ca0              LDR      r0,[r4,#0x48]         ;1496
000108  1c40              ADDS     r0,r0,#1              ;1496
00010a  d100              BNE      |L15.270|
00010c  64a0              STR      r0,[r4,#0x48]         ;1496
                  |L15.270|
00010e  f7fffffe          BL       vPortExitCritical
000112  a905              ADD      r1,sp,#0x14           ;1499
000114  a801              ADD      r0,sp,#4              ;1499
000116  f7fffffe          BL       xTaskCheckForTimeOut
00011a  bb38              CBNZ     r0,|L15.364|
00011c  4620              MOV      r0,r4                 ;1501
00011e  f7fffffe          BL       prvIsQueueEmpty
000122  b1e8              CBZ      r0,|L15.352|
000124  6820              LDR      r0,[r4,#0]            ;1507
000126  b930              CBNZ     r0,|L15.310|
000128  f7fffffe          BL       vPortEnterCritical
00012c  6860              LDR      r0,[r4,#4]            ;1511
00012e  f7fffffe          BL       vTaskPriorityInherit
000132  f7fffffe          BL       vPortExitCritical
                  |L15.310|
000136  f1040024          ADD      r0,r4,#0x24           ;1522
00013a  9905              LDR      r1,[sp,#0x14]         ;1522
00013c  f7fffffe          BL       vTaskPlaceOnEventList
000140  4620              MOV      r0,r4                 ;1523
000142  f7fffffe          BL       prvUnlockQueue
000146  f7fffffe          BL       xTaskResumeAll
00014a  2800              CMP      r0,#0                 ;1524
00014c  d180              BNE      |L15.80|
00014e  f04f5080          MOV      r0,#0x10000000        ;1526
000152  490a              LDR      r1,|L15.380|
000154  6008              STR      r0,[r1,#0]            ;1526
000156  f3bf8f4f          DSB                            ;1526
00015a  f3bf8f6f          ISB                            ;1526
00015e  e777              B        |L15.80|
                  |L15.352|
000160  4620              MOV      r0,r4                 ;1536
000162  f7fffffe          BL       prvUnlockQueue
000166  f7fffffe          BL       xTaskResumeAll
00016a  e771              B        |L15.80|
                  |L15.364|
00016c  4620              MOV      r0,r4                 ;1542
00016e  f7fffffe          BL       prvUnlockQueue
000172  f7fffffe          BL       xTaskResumeAll
000176  2000              MOVS     r0,#0                 ;1545
000178  e7aa              B        |L15.208|
;;;1549   /*-----------------------------------------------------------*/
                          ENDP

00017a  0000              DCW      0x0000
                  |L15.380|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;259    
;;;260    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;261    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;262    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000006  462c              MOV      r4,r5
;;;263    
;;;264    	configASSERT( pxQueue );
000008  b954              CBNZ     r4,|L16.32|
00000a  bf00              NOP      
00000c  2010              MOVS     r0,#0x10
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L16.30|
00001e  e7fe              B        |L16.30|
                  |L16.32|
;;;265    
;;;266    	taskENTER_CRITICAL();
000020  f7fffffe          BL       vPortEnterCritical
;;;267    	{
;;;268    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
000024  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
000028  6820              LDR      r0,[r4,#0]
00002a  fb010002          MLA      r0,r1,r2,r0
00002e  6060              STR      r0,[r4,#4]
;;;269    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000030  2000              MOVS     r0,#0
000032  63a0              STR      r0,[r4,#0x38]
;;;270    		pxQueue->pcWriteTo = pxQueue->pcHead;
000034  6820              LDR      r0,[r4,#0]
000036  60a0              STR      r0,[r4,#8]
;;;271    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
000038  6be0              LDR      r0,[r4,#0x3c]
00003a  1e40              SUBS     r0,r0,#1
00003c  6c22              LDR      r2,[r4,#0x40]
00003e  6821              LDR      r1,[r4,#0]
000040  fb001002          MLA      r0,r0,r2,r1
000044  60e0              STR      r0,[r4,#0xc]
;;;272    		pxQueue->xRxLock = queueUNLOCKED;
000046  f04f30ff          MOV      r0,#0xffffffff
00004a  6460              STR      r0,[r4,#0x44]
;;;273    		pxQueue->xTxLock = queueUNLOCKED;
00004c  64a0              STR      r0,[r4,#0x48]
;;;274    
;;;275    		if( xNewQueue == pdFALSE )
00004e  b99e              CBNZ     r6,|L16.120|
;;;276    		{
;;;277    			/* If there are tasks blocked waiting to read from the queue, then
;;;278    			the tasks will remain blocked as after this function exits the queue
;;;279    			will still be empty.  If there are tasks blocked waiting to write to
;;;280    			the queue, then one should be unblocked as after this function exits
;;;281    			it will be possible to write to it. */
;;;282    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000050  6920              LDR      r0,[r4,#0x10]
000052  b908              CBNZ     r0,|L16.88|
000054  2001              MOVS     r0,#1
000056  e000              B        |L16.90|
                  |L16.88|
000058  2000              MOVS     r0,#0
                  |L16.90|
00005a  b9a8              CBNZ     r0,|L16.136|
;;;283    			{
;;;284    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
00005c  f1040010          ADD      r0,r4,#0x10
000060  f7fffffe          BL       xTaskRemoveFromEventList
000064  2801              CMP      r0,#1
000066  d10f              BNE      |L16.136|
;;;285    				{
;;;286    					queueYIELD_IF_USING_PREEMPTION();
000068  0700              LSLS     r0,r0,#28
00006a  4909              LDR      r1,|L16.144|
00006c  6008              STR      r0,[r1,#0]
00006e  f3bf8f4f          DSB      
000072  f3bf8f6f          ISB      
000076  e007              B        |L16.136|
                  |L16.120|
;;;287    				}
;;;288    				else
;;;289    				{
;;;290    					mtCOVERAGE_TEST_MARKER();
;;;291    				}
;;;292    			}
;;;293    			else
;;;294    			{
;;;295    				mtCOVERAGE_TEST_MARKER();
;;;296    			}
;;;297    		}
;;;298    		else
;;;299    		{
;;;300    			/* Ensure the event queues start in the correct state. */
;;;301    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000078  f1040010          ADD      r0,r4,#0x10
00007c  f7fffffe          BL       vListInitialise
;;;302    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000080  f1040024          ADD      r0,r4,#0x24
000084  f7fffffe          BL       vListInitialise
                  |L16.136|
;;;303    		}
;;;304    	}
;;;305    	taskEXIT_CRITICAL();
000088  f7fffffe          BL       vPortExitCritical
;;;306    
;;;307    	/* A value is returned for calling semantic consistency with previous
;;;308    	versions. */
;;;309    	return pdPASS;
00008c  2001              MOVS     r0,#1
;;;310    }
00008e  bd70              POP      {r4-r6,pc}
;;;311    /*-----------------------------------------------------------*/
                          ENDP

                  |L16.144|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=2

                  xQueueGenericSend PROC
;;;608    
;;;609    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  e92d43ff          PUSH     {r0-r9,lr}
;;;610    {
000004  b083              SUB      sp,sp,#0xc
000006  4606              MOV      r6,r0
000008  4688              MOV      r8,r1
00000a  461d              MOV      r5,r3
;;;611    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
00000c  f04f0900          MOV      r9,#0
;;;612    TimeOut_t xTimeOut;
;;;613    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000010  4634              MOV      r4,r6
;;;614    
;;;615    	configASSERT( pxQueue );
000012  b954              CBNZ     r4,|L17.42|
000014  bf00              NOP      
000016  2010              MOVS     r0,#0x10
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L17.40|
000028  e7fe              B        |L17.40|
                  |L17.42|
;;;616    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00002a  f1b80f00          CMP      r8,#0
00002e  d101              BNE      |L17.52|
000030  6c20              LDR      r0,[r4,#0x40]
000032  b908              CBNZ     r0,|L17.56|
                  |L17.52|
000034  2001              MOVS     r0,#1
000036  e000              B        |L17.58|
                  |L17.56|
000038  2000              MOVS     r0,#0
                  |L17.58|
00003a  b950              CBNZ     r0,|L17.82|
00003c  bf00              NOP      
00003e  2010              MOVS     r0,#0x10
000040  f3808811          MSR      BASEPRI,r0
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
00004c  bf00              NOP      
00004e  bf00              NOP      
                  |L17.80|
000050  e7fe              B        |L17.80|
                  |L17.82|
;;;617    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
000052  2d02              CMP      r5,#2
000054  d102              BNE      |L17.92|
000056  6be0              LDR      r0,[r4,#0x3c]
000058  2801              CMP      r0,#1
00005a  d101              BNE      |L17.96|
                  |L17.92|
00005c  2001              MOVS     r0,#1
00005e  e000              B        |L17.98|
                  |L17.96|
000060  2000              MOVS     r0,#0
                  |L17.98|
000062  b950              CBNZ     r0,|L17.122|
000064  bf00              NOP      
000066  2010              MOVS     r0,#0x10
000068  f3808811          MSR      BASEPRI,r0
00006c  f3bf8f4f          DSB      
000070  f3bf8f6f          ISB      
000074  bf00              NOP      
000076  bf00              NOP      
                  |L17.120|
000078  e7fe              B        |L17.120|
                  |L17.122|
;;;618    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;619    	{
;;;620    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;621    	}
;;;622    	#endif
;;;623    
;;;624    
;;;625    	/* This function relaxes the coding standard somewhat to allow return
;;;626    	statements within the function itself.  This is done in the interest
;;;627    	of execution time efficiency. */
;;;628    	for( ;; )
00007a  bf00              NOP      
                  |L17.124|
;;;629    	{
;;;630    		taskENTER_CRITICAL();
00007c  f7fffffe          BL       vPortEnterCritical
;;;631    		{
;;;632    			/* Is there room on the queue now?  The running task must be the
;;;633    			highest priority task wanting to access the queue.  If the head item
;;;634    			in the queue is to be overwritten then it does not matter if the
;;;635    			queue is full. */
;;;636    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000080  6ba0              LDR      r0,[r4,#0x38]
000082  6be1              LDR      r1,[r4,#0x3c]
000084  4288              CMP      r0,r1
000086  d301              BCC      |L17.140|
000088  2d02              CMP      r5,#2
00008a  d128              BNE      |L17.222|
                  |L17.140|
;;;637    			{
;;;638    				traceQUEUE_SEND( pxQueue );
;;;639    				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00008c  462a              MOV      r2,r5
00008e  4641              MOV      r1,r8
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       prvCopyDataToQueue
000096  4607              MOV      r7,r0
;;;640    
;;;641    				#if ( configUSE_QUEUE_SETS == 1 )
;;;642    				{
;;;643    					if( pxQueue->pxQueueSetContainer != NULL )
;;;644    					{
;;;645    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;646    						{
;;;647    							/* The queue is a member of a queue set, and posting
;;;648    							to the queue set caused a higher priority task to
;;;649    							unblock. A context switch is required. */
;;;650    							queueYIELD_IF_USING_PREEMPTION();
;;;651    						}
;;;652    						else
;;;653    						{
;;;654    							mtCOVERAGE_TEST_MARKER();
;;;655    						}
;;;656    					}
;;;657    					else
;;;658    					{
;;;659    						/* If there was a task waiting for data to arrive on the
;;;660    						queue then unblock it now. */
;;;661    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;662    						{
;;;663    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;664    							{
;;;665    								/* The unblocked task has a priority higher than
;;;666    								our own so yield immediately.  Yes it is ok to
;;;667    								do this from within the critical section - the
;;;668    								kernel takes care of that. */
;;;669    								queueYIELD_IF_USING_PREEMPTION();
;;;670    							}
;;;671    							else
;;;672    							{
;;;673    								mtCOVERAGE_TEST_MARKER();
;;;674    							}
;;;675    						}
;;;676    						else if( xYieldRequired != pdFALSE )
;;;677    						{
;;;678    							/* This path is a special case that will only get
;;;679    							executed if the task was holding multiple mutexes
;;;680    							and the mutexes were given back in an order that is
;;;681    							different to that in which they were taken. */
;;;682    							queueYIELD_IF_USING_PREEMPTION();
;;;683    						}
;;;684    						else
;;;685    						{
;;;686    							mtCOVERAGE_TEST_MARKER();
;;;687    						}
;;;688    					}
;;;689    				}
;;;690    				#else /* configUSE_QUEUE_SETS */
;;;691    				{
;;;692    					/* If there was a task waiting for data to arrive on the
;;;693    					queue then unblock it now. */
;;;694    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000098  6a60              LDR      r0,[r4,#0x24]
00009a  b908              CBNZ     r0,|L17.160|
00009c  2001              MOVS     r0,#1
00009e  e000              B        |L17.162|
                  |L17.160|
0000a0  2000              MOVS     r0,#0
                  |L17.162|
0000a2  b968              CBNZ     r0,|L17.192|
;;;695    					{
;;;696    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
0000a4  f1040024          ADD      r0,r4,#0x24
0000a8  f7fffffe          BL       xTaskRemoveFromEventList
0000ac  2801              CMP      r0,#1
0000ae  d110              BNE      |L17.210|
;;;697    						{
;;;698    							/* The unblocked task has a priority higher than
;;;699    							our own so yield immediately.  Yes it is ok to do
;;;700    							this from within the critical section - the kernel
;;;701    							takes care of that. */
;;;702    							queueYIELD_IF_USING_PREEMPTION();
0000b0  0700              LSLS     r0,r0,#28
0000b2  492f              LDR      r1,|L17.368|
0000b4  6008              STR      r0,[r1,#0]
0000b6  f3bf8f4f          DSB      
0000ba  f3bf8f6f          ISB      
0000be  e008              B        |L17.210|
                  |L17.192|
;;;703    						}
;;;704    						else
;;;705    						{
;;;706    							mtCOVERAGE_TEST_MARKER();
;;;707    						}
;;;708    					}
;;;709    					else if( xYieldRequired != pdFALSE )
0000c0  b13f              CBZ      r7,|L17.210|
;;;710    					{
;;;711    						/* This path is a special case that will only get
;;;712    						executed if the task was holding multiple mutexes and
;;;713    						the mutexes were given back in an order that is
;;;714    						different to that in which they were taken. */
;;;715    						queueYIELD_IF_USING_PREEMPTION();
0000c2  f04f5080          MOV      r0,#0x10000000
0000c6  492a              LDR      r1,|L17.368|
0000c8  6008              STR      r0,[r1,#0]
0000ca  f3bf8f4f          DSB      
0000ce  f3bf8f6f          ISB      
                  |L17.210|
;;;716    					}
;;;717    					else
;;;718    					{
;;;719    						mtCOVERAGE_TEST_MARKER();
;;;720    					}
;;;721    				}
;;;722    				#endif /* configUSE_QUEUE_SETS */
;;;723    
;;;724    				taskEXIT_CRITICAL();
0000d2  f7fffffe          BL       vPortExitCritical
;;;725    				return pdPASS;
0000d6  2001              MOVS     r0,#1
                  |L17.216|
;;;726    			}
;;;727    			else
;;;728    			{
;;;729    				if( xTicksToWait == ( TickType_t ) 0 )
;;;730    				{
;;;731    					/* The queue was full and no block time is specified (or
;;;732    					the block time has expired) so leave now. */
;;;733    					taskEXIT_CRITICAL();
;;;734    
;;;735    					/* Return to the original privilege level before exiting
;;;736    					the function. */
;;;737    					traceQUEUE_SEND_FAILED( pxQueue );
;;;738    					return errQUEUE_FULL;
;;;739    				}
;;;740    				else if( xEntryTimeSet == pdFALSE )
;;;741    				{
;;;742    					/* The queue was full and a block time was specified so
;;;743    					configure the timeout structure. */
;;;744    					vTaskSetTimeOutState( &xTimeOut );
;;;745    					xEntryTimeSet = pdTRUE;
;;;746    				}
;;;747    				else
;;;748    				{
;;;749    					/* Entry time was already set. */
;;;750    					mtCOVERAGE_TEST_MARKER();
;;;751    				}
;;;752    			}
;;;753    		}
;;;754    		taskEXIT_CRITICAL();
;;;755    
;;;756    		/* Interrupts and other tasks can send to and receive from the queue
;;;757    		now the critical section has been exited. */
;;;758    
;;;759    		vTaskSuspendAll();
;;;760    		prvLockQueue( pxQueue );
;;;761    
;;;762    		/* Update the timeout state to see if it has expired yet. */
;;;763    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;764    		{
;;;765    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;766    			{
;;;767    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;768    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;769    
;;;770    				/* Unlocking the queue means queue events can effect the
;;;771    				event list.  It is possible	that interrupts occurring now
;;;772    				remove this task from the event	list again - but as the
;;;773    				scheduler is suspended the task will go onto the pending
;;;774    				ready last instead of the actual ready list. */
;;;775    				prvUnlockQueue( pxQueue );
;;;776    
;;;777    				/* Resuming the scheduler will move tasks from the pending
;;;778    				ready list into the ready list - so it is feasible that this
;;;779    				task is already in a ready list before it yields - in which
;;;780    				case the yield will not cause a context switch unless there
;;;781    				is also a higher priority task in the pending ready list. */
;;;782    				if( xTaskResumeAll() == pdFALSE )
;;;783    				{
;;;784    					portYIELD_WITHIN_API();
;;;785    				}
;;;786    			}
;;;787    			else
;;;788    			{
;;;789    				/* Try again. */
;;;790    				prvUnlockQueue( pxQueue );
;;;791    				( void ) xTaskResumeAll();
;;;792    			}
;;;793    		}
;;;794    		else
;;;795    		{
;;;796    			/* The timeout has expired. */
;;;797    			prvUnlockQueue( pxQueue );
;;;798    			( void ) xTaskResumeAll();
;;;799    
;;;800    			/* Return to the original privilege level before exiting the
;;;801    			function. */
;;;802    			traceQUEUE_SEND_FAILED( pxQueue );
;;;803    			return errQUEUE_FULL;
;;;804    		}
;;;805    	}
;;;806    }
0000d8  b007              ADD      sp,sp,#0x1c
0000da  e8bd83f0          POP      {r4-r9,pc}
                  |L17.222|
0000de  9805              LDR      r0,[sp,#0x14]         ;729
0000e0  b918              CBNZ     r0,|L17.234|
0000e2  f7fffffe          BL       vPortExitCritical
0000e6  2000              MOVS     r0,#0                 ;738
0000e8  e7f6              B        |L17.216|
                  |L17.234|
0000ea  f1b90f00          CMP      r9,#0                 ;740
0000ee  d104              BNE      |L17.250|
0000f0  a801              ADD      r0,sp,#4              ;744
0000f2  f7fffffe          BL       vTaskSetTimeOutState
0000f6  f04f0901          MOV      r9,#1                 ;745
                  |L17.250|
0000fa  f7fffffe          BL       vPortExitCritical
0000fe  f7fffffe          BL       vTaskSuspendAll
000102  f7fffffe          BL       vPortEnterCritical
000106  6c60              LDR      r0,[r4,#0x44]         ;760
000108  1c40              ADDS     r0,r0,#1              ;760
00010a  d100              BNE      |L17.270|
00010c  6460              STR      r0,[r4,#0x44]         ;760
                  |L17.270|
00010e  6ca0              LDR      r0,[r4,#0x48]         ;760
000110  1c40              ADDS     r0,r0,#1              ;760
000112  d100              BNE      |L17.278|
000114  64a0              STR      r0,[r4,#0x48]         ;760
                  |L17.278|
000116  f7fffffe          BL       vPortExitCritical
00011a  a905              ADD      r1,sp,#0x14           ;763
00011c  a801              ADD      r0,sp,#4              ;763
00011e  f7fffffe          BL       xTaskCheckForTimeOut
000122  b9f0              CBNZ     r0,|L17.354|
000124  4620              MOV      r0,r4                 ;765
000126  f7fffffe          BL       prvIsQueueFull
00012a  b1a0              CBZ      r0,|L17.342|
00012c  f1040010          ADD      r0,r4,#0x10           ;768
000130  9905              LDR      r1,[sp,#0x14]         ;768
000132  f7fffffe          BL       vTaskPlaceOnEventList
000136  4620              MOV      r0,r4                 ;775
000138  f7fffffe          BL       prvUnlockQueue
00013c  f7fffffe          BL       xTaskResumeAll
000140  2800              CMP      r0,#0                 ;782
000142  d19b              BNE      |L17.124|
000144  f04f5080          MOV      r0,#0x10000000        ;784
000148  4909              LDR      r1,|L17.368|
00014a  6008              STR      r0,[r1,#0]            ;784
00014c  f3bf8f4f          DSB                            ;784
000150  f3bf8f6f          ISB                            ;784
000154  e792              B        |L17.124|
                  |L17.342|
000156  4620              MOV      r0,r4                 ;790
000158  f7fffffe          BL       prvUnlockQueue
00015c  f7fffffe          BL       xTaskResumeAll
000160  e78c              B        |L17.124|
                  |L17.354|
000162  4620              MOV      r0,r4                 ;797
000164  f7fffffe          BL       prvUnlockQueue
000168  f7fffffe          BL       xTaskResumeAll
00016c  2000              MOVS     r0,#0                 ;803
00016e  e7b3              B        |L17.216|
;;;807    /*-----------------------------------------------------------*/
                          ENDP

                  |L17.368|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;1053   
;;;1054   BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1055   {
000004  4607              MOV      r7,r0
000006  468a              MOV      r10,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;1056   BaseType_t xReturn;
;;;1057   UBaseType_t uxSavedInterruptStatus;
;;;1058   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00000c  463c              MOV      r4,r7
;;;1059   
;;;1060   	configASSERT( pxQueue );
00000e  b954              CBNZ     r4,|L18.38|
000010  bf00              NOP      
000012  2010              MOVS     r0,#0x10
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L18.36|
000024  e7fe              B        |L18.36|
                  |L18.38|
;;;1061   	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000026  f1ba0f00          CMP      r10,#0
00002a  d101              BNE      |L18.48|
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  b908              CBNZ     r0,|L18.52|
                  |L18.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L18.54|
                  |L18.52|
000034  2000              MOVS     r0,#0
                  |L18.54|
000036  b950              CBNZ     r0,|L18.78|
000038  bf00              NOP      
00003a  2010              MOVS     r0,#0x10
00003c  f3808811          MSR      BASEPRI,r0
000040  f3bf8f4f          DSB      
000044  f3bf8f6f          ISB      
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L18.76|
00004c  e7fe              B        |L18.76|
                  |L18.78|
;;;1062   	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
00004e  2e02              CMP      r6,#2
000050  d102              BNE      |L18.88|
000052  6be0              LDR      r0,[r4,#0x3c]
000054  2801              CMP      r0,#1
000056  d101              BNE      |L18.92|
                  |L18.88|
000058  2001              MOVS     r0,#1
00005a  e000              B        |L18.94|
                  |L18.92|
00005c  2000              MOVS     r0,#0
                  |L18.94|
00005e  b950              CBNZ     r0,|L18.118|
000060  bf00              NOP      
000062  2010              MOVS     r0,#0x10
000064  f3808811          MSR      BASEPRI,r0
000068  f3bf8f4f          DSB      
00006c  f3bf8f6f          ISB      
000070  bf00              NOP      
000072  bf00              NOP      
                  |L18.116|
000074  e7fe              B        |L18.116|
                  |L18.118|
;;;1063   
;;;1064   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1065   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1066   	above the maximum system call priority are kept permanently enabled, even
;;;1067   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1068   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1069   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1070   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1071   	assigned a priority above the configured maximum system call priority.
;;;1072   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1073   	that have been assigned a priority at or (logically) below the maximum
;;;1074   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1075   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1076   	More information (albeit Cortex-M specific) is provided on the following
;;;1077   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1078   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000076  f7fffffe          BL       vPortValidateInterruptPriority
;;;1079   
;;;1080   	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;1081   	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;1082   	read, instead return a flag to say whether a context switch is required or
;;;1083   	not (i.e. has a task with a higher priority than us been woken by this
;;;1084   	post). */
;;;1085   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00007a  bf00              NOP      
00007c  2110              MOVS     r1,#0x10
00007e  f3ef8011          MRS      r0,BASEPRI
000082  f3818811          MSR      BASEPRI,r1
000086  f3bf8f4f          DSB      
00008a  f3bf8f6f          ISB      
00008e  bf00              NOP      
000090  4605              MOV      r5,r0
;;;1086   	{
;;;1087   		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000092  6ba0              LDR      r0,[r4,#0x38]
000094  6be1              LDR      r1,[r4,#0x3c]
000096  4288              CMP      r0,r1
000098  d301              BCC      |L18.158|
00009a  2e02              CMP      r6,#2
00009c  d11f              BNE      |L18.222|
                  |L18.158|
;;;1088   		{
;;;1089   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1090   
;;;1091   			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;1092   			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;1093   			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;1094   			called here even though the disinherit function does not check if
;;;1095   			the scheduler is suspended before accessing the ready lists. */
;;;1096   			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00009e  4632              MOV      r2,r6
0000a0  4651              MOV      r1,r10
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       prvCopyDataToQueue
;;;1097   
;;;1098   			/* The event list is not altered if the queue is locked.  This will
;;;1099   			be done when the queue is unlocked later. */
;;;1100   			if( pxQueue->xTxLock == queueUNLOCKED )
0000a8  6ca0              LDR      r0,[r4,#0x48]
0000aa  1c40              ADDS     r0,r0,#1
0000ac  d111              BNE      |L18.210|
;;;1101   			{
;;;1102   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1103   				{
;;;1104   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1105   					{
;;;1106   						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;1107   						{
;;;1108   							/* The queue is a member of a queue set, and posting
;;;1109   							to the queue set caused a higher priority task to
;;;1110   							unblock.  A context switch is required. */
;;;1111   							if( pxHigherPriorityTaskWoken != NULL )
;;;1112   							{
;;;1113   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1114   							}
;;;1115   							else
;;;1116   							{
;;;1117   								mtCOVERAGE_TEST_MARKER();
;;;1118   							}
;;;1119   						}
;;;1120   						else
;;;1121   						{
;;;1122   							mtCOVERAGE_TEST_MARKER();
;;;1123   						}
;;;1124   					}
;;;1125   					else
;;;1126   					{
;;;1127   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1128   						{
;;;1129   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1130   							{
;;;1131   								/* The task waiting has a higher priority so
;;;1132   								record that a context switch is required. */
;;;1133   								if( pxHigherPriorityTaskWoken != NULL )
;;;1134   								{
;;;1135   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1136   								}
;;;1137   								else
;;;1138   								{
;;;1139   									mtCOVERAGE_TEST_MARKER();
;;;1140   								}
;;;1141   							}
;;;1142   							else
;;;1143   							{
;;;1144   								mtCOVERAGE_TEST_MARKER();
;;;1145   							}
;;;1146   						}
;;;1147   						else
;;;1148   						{
;;;1149   							mtCOVERAGE_TEST_MARKER();
;;;1150   						}
;;;1151   					}
;;;1152   				}
;;;1153   				#else /* configUSE_QUEUE_SETS */
;;;1154   				{
;;;1155   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000ae  6a60              LDR      r0,[r4,#0x24]
0000b0  b908              CBNZ     r0,|L18.182|
0000b2  2001              MOVS     r0,#1
0000b4  e000              B        |L18.184|
                  |L18.182|
0000b6  2000              MOVS     r0,#0
                  |L18.184|
0000b8  b970              CBNZ     r0,|L18.216|
;;;1156   					{
;;;1157   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000ba  f1040024          ADD      r0,r4,#0x24
0000be  f7fffffe          BL       xTaskRemoveFromEventList
0000c2  b148              CBZ      r0,|L18.216|
;;;1158   						{
;;;1159   							/* The task waiting has a higher priority so record that a
;;;1160   							context	switch is required. */
;;;1161   							if( pxHigherPriorityTaskWoken != NULL )
0000c4  f1b80f00          CMP      r8,#0
0000c8  d006              BEQ      |L18.216|
;;;1162   							{
;;;1163   								*pxHigherPriorityTaskWoken = pdTRUE;
0000ca  2001              MOVS     r0,#1
0000cc  f8c80000          STR      r0,[r8,#0]
0000d0  e002              B        |L18.216|
                  |L18.210|
;;;1164   							}
;;;1165   							else
;;;1166   							{
;;;1167   								mtCOVERAGE_TEST_MARKER();
;;;1168   							}
;;;1169   						}
;;;1170   						else
;;;1171   						{
;;;1172   							mtCOVERAGE_TEST_MARKER();
;;;1173   						}
;;;1174   					}
;;;1175   					else
;;;1176   					{
;;;1177   						mtCOVERAGE_TEST_MARKER();
;;;1178   					}
;;;1179   				}
;;;1180   				#endif /* configUSE_QUEUE_SETS */
;;;1181   			}
;;;1182   			else
;;;1183   			{
;;;1184   				/* Increment the lock count so the task that unlocks the queue
;;;1185   				knows that data was posted while it was locked. */
;;;1186   				++( pxQueue->xTxLock );
0000d2  6ca0              LDR      r0,[r4,#0x48]
0000d4  1c40              ADDS     r0,r0,#1
0000d6  64a0              STR      r0,[r4,#0x48]
                  |L18.216|
;;;1187   			}
;;;1188   
;;;1189   			xReturn = pdPASS;
0000d8  f04f0901          MOV      r9,#1
0000dc  e001              B        |L18.226|
                  |L18.222|
;;;1190   		}
;;;1191   		else
;;;1192   		{
;;;1193   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1194   			xReturn = errQUEUE_FULL;
0000de  f04f0900          MOV      r9,#0
                  |L18.226|
;;;1195   		}
;;;1196   	}
;;;1197   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000e2  bf00              NOP      
0000e4  f3858811          MSR      BASEPRI,r5
0000e8  bf00              NOP      
;;;1198   
;;;1199   	return xReturn;
0000ea  4648              MOV      r0,r9
;;;1200   }
0000ec  e8bd87f0          POP      {r4-r10,pc}
;;;1201   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGiveFromISR PROC
;;;1202   
;;;1203   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1204   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1205   BaseType_t xReturn;
;;;1206   UBaseType_t uxSavedInterruptStatus;
;;;1207   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000008  4634              MOV      r4,r6
;;;1208   
;;;1209   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1210   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1211   	read, instead return a flag to say whether a context switch is required or
;;;1212   	not (i.e. has a task with a higher priority than us been woken by this
;;;1213   	post). */
;;;1214   
;;;1215   	configASSERT( pxQueue );
00000a  b954              CBNZ     r4,|L19.34|
00000c  bf00              NOP      
00000e  2010              MOVS     r0,#0x10
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L19.32|
000020  e7fe              B        |L19.32|
                  |L19.34|
;;;1216   
;;;1217   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1218   	if the item size is not 0. */
;;;1219   	configASSERT( pxQueue->uxItemSize == 0 );
000022  6c20              LDR      r0,[r4,#0x40]
000024  b908              CBNZ     r0,|L19.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L19.44|
                  |L19.42|
00002a  2000              MOVS     r0,#0
                  |L19.44|
00002c  b950              CBNZ     r0,|L19.68|
00002e  bf00              NOP      
000030  2010              MOVS     r0,#0x10
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L19.66|
000042  e7fe              B        |L19.66|
                  |L19.68|
;;;1220   
;;;1221   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1222   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1223   	interrupts, only tasks. */
;;;1224   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
000044  6820              LDR      r0,[r4,#0]
000046  b908              CBNZ     r0,|L19.76|
000048  6860              LDR      r0,[r4,#4]
00004a  b908              CBNZ     r0,|L19.80|
                  |L19.76|
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L19.82|
                  |L19.80|
000050  2000              MOVS     r0,#0
                  |L19.82|
000052  b950              CBNZ     r0,|L19.106|
000054  bf00              NOP      
000056  2010              MOVS     r0,#0x10
000058  f3808811          MSR      BASEPRI,r0
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
000064  bf00              NOP      
000066  bf00              NOP      
                  |L19.104|
000068  e7fe              B        |L19.104|
                  |L19.106|
;;;1225   
;;;1226   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1227   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1228   	above the maximum system call priority are kept permanently enabled, even
;;;1229   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1230   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1231   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1232   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1233   	assigned a priority above the configured maximum system call priority.
;;;1234   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1235   	that have been assigned a priority at or (logically) below the maximum
;;;1236   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1237   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1238   	More information (albeit Cortex-M specific) is provided on the following
;;;1239   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1240   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00006a  f7fffffe          BL       vPortValidateInterruptPriority
;;;1241   
;;;1242   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00006e  bf00              NOP      
000070  2110              MOVS     r1,#0x10
000072  f3ef8011          MRS      r0,BASEPRI
000076  f3818811          MSR      BASEPRI,r1
00007a  f3bf8f4f          DSB      
00007e  f3bf8f6f          ISB      
000082  bf00              NOP      
000084  4605              MOV      r5,r0
;;;1243   	{
;;;1244   		/* When the queue is used to implement a semaphore no data is ever
;;;1245   		moved through the queue but it is still valid to see if the queue 'has
;;;1246   		space'. */
;;;1247   		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
000086  6ba0              LDR      r0,[r4,#0x38]
000088  6be1              LDR      r1,[r4,#0x3c]
00008a  4288              CMP      r0,r1
00008c  d21a              BCS      |L19.196|
;;;1248   		{
;;;1249   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1250   
;;;1251   			/* A task can only have an inherited priority if it is a mutex
;;;1252   			holder - and if there is a mutex holder then the mutex cannot be
;;;1253   			given from an ISR.  As this is the ISR version of the function it
;;;1254   			can be assumed there is no mutex holder and no need to determine if
;;;1255   			priority disinheritance is needed.  Simply increase the count of
;;;1256   			messages (semaphores) available. */
;;;1257   			++( pxQueue->uxMessagesWaiting );
00008e  6ba0              LDR      r0,[r4,#0x38]
000090  1c40              ADDS     r0,r0,#1
000092  63a0              STR      r0,[r4,#0x38]
;;;1258   
;;;1259   			/* The event list is not altered if the queue is locked.  This will
;;;1260   			be done when the queue is unlocked later. */
;;;1261   			if( pxQueue->xTxLock == queueUNLOCKED )
000094  6ca0              LDR      r0,[r4,#0x48]
000096  1c40              ADDS     r0,r0,#1
000098  d10e              BNE      |L19.184|
;;;1262   			{
;;;1263   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1264   				{
;;;1265   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1266   					{
;;;1267   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1268   						{
;;;1269   							/* The semaphore is a member of a queue set, and
;;;1270   							posting	to the queue set caused a higher priority
;;;1271   							task to	unblock.  A context switch is required. */
;;;1272   							if( pxHigherPriorityTaskWoken != NULL )
;;;1273   							{
;;;1274   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1275   							}
;;;1276   							else
;;;1277   							{
;;;1278   								mtCOVERAGE_TEST_MARKER();
;;;1279   							}
;;;1280   						}
;;;1281   						else
;;;1282   						{
;;;1283   							mtCOVERAGE_TEST_MARKER();
;;;1284   						}
;;;1285   					}
;;;1286   					else
;;;1287   					{
;;;1288   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1289   						{
;;;1290   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1291   							{
;;;1292   								/* The task waiting has a higher priority so
;;;1293   								record that a context switch is required. */
;;;1294   								if( pxHigherPriorityTaskWoken != NULL )
;;;1295   								{
;;;1296   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1297   								}
;;;1298   								else
;;;1299   								{
;;;1300   									mtCOVERAGE_TEST_MARKER();
;;;1301   								}
;;;1302   							}
;;;1303   							else
;;;1304   							{
;;;1305   								mtCOVERAGE_TEST_MARKER();
;;;1306   							}
;;;1307   						}
;;;1308   						else
;;;1309   						{
;;;1310   							mtCOVERAGE_TEST_MARKER();
;;;1311   						}
;;;1312   					}
;;;1313   				}
;;;1314   				#else /* configUSE_QUEUE_SETS */
;;;1315   				{
;;;1316   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00009a  6a60              LDR      r0,[r4,#0x24]
00009c  b908              CBNZ     r0,|L19.162|
00009e  2001              MOVS     r0,#1
0000a0  e000              B        |L19.164|
                  |L19.162|
0000a2  2000              MOVS     r0,#0
                  |L19.164|
0000a4  b958              CBNZ     r0,|L19.190|
;;;1317   					{
;;;1318   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000a6  f1040024          ADD      r0,r4,#0x24
0000aa  f7fffffe          BL       xTaskRemoveFromEventList
0000ae  b130              CBZ      r0,|L19.190|
;;;1319   						{
;;;1320   							/* The task waiting has a higher priority so record that a
;;;1321   							context	switch is required. */
;;;1322   							if( pxHigherPriorityTaskWoken != NULL )
0000b0  b12f              CBZ      r7,|L19.190|
;;;1323   							{
;;;1324   								*pxHigherPriorityTaskWoken = pdTRUE;
0000b2  2001              MOVS     r0,#1
0000b4  6038              STR      r0,[r7,#0]
0000b6  e002              B        |L19.190|
                  |L19.184|
;;;1325   							}
;;;1326   							else
;;;1327   							{
;;;1328   								mtCOVERAGE_TEST_MARKER();
;;;1329   							}
;;;1330   						}
;;;1331   						else
;;;1332   						{
;;;1333   							mtCOVERAGE_TEST_MARKER();
;;;1334   						}
;;;1335   					}
;;;1336   					else
;;;1337   					{
;;;1338   						mtCOVERAGE_TEST_MARKER();
;;;1339   					}
;;;1340   				}
;;;1341   				#endif /* configUSE_QUEUE_SETS */
;;;1342   			}
;;;1343   			else
;;;1344   			{
;;;1345   				/* Increment the lock count so the task that unlocks the queue
;;;1346   				knows that data was posted while it was locked. */
;;;1347   				++( pxQueue->xTxLock );
0000b8  6ca0              LDR      r0,[r4,#0x48]
0000ba  1c40              ADDS     r0,r0,#1
0000bc  64a0              STR      r0,[r4,#0x48]
                  |L19.190|
;;;1348   			}
;;;1349   
;;;1350   			xReturn = pdPASS;
0000be  f04f0801          MOV      r8,#1
0000c2  e001              B        |L19.200|
                  |L19.196|
;;;1351   		}
;;;1352   		else
;;;1353   		{
;;;1354   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1355   			xReturn = errQUEUE_FULL;
0000c4  f04f0800          MOV      r8,#0
                  |L19.200|
;;;1356   		}
;;;1357   	}
;;;1358   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000c8  bf00              NOP      
0000ca  f3858811          MSR      BASEPRI,r5
0000ce  bf00              NOP      
;;;1359   
;;;1360   	return xReturn;
0000d0  4640              MOV      r0,r8
;;;1361   }
0000d2  e8bd81f0          POP      {r4-r8,pc}
;;;1362   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;2011   
;;;2012   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2013   {
;;;2014   BaseType_t xReturn;
;;;2015   
;;;2016   	configASSERT( xQueue );
000002  b951              CBNZ     r1,|L20.26|
000004  bf00              NOP      
000006  2210              MOVS     r2,#0x10
000008  f3828811          MSR      BASEPRI,r2
00000c  f3bf8f4f          DSB      
000010  f3bf8f6f          ISB      
000014  bf00              NOP      
000016  bf00              NOP      
                  |L20.24|
000018  e7fe              B        |L20.24|
                  |L20.26|
;;;2017   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
00001a  6b8a              LDR      r2,[r1,#0x38]
00001c  b90a              CBNZ     r2,|L20.34|
;;;2018   	{
;;;2019   		xReturn = pdTRUE;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L20.36|
                  |L20.34|
;;;2020   	}
;;;2021   	else
;;;2022   	{
;;;2023   		xReturn = pdFALSE;
000022  2000              MOVS     r0,#0
                  |L20.36|
;;;2024   	}
;;;2025   
;;;2026   	return xReturn;
;;;2027   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000024  4770              BX       lr
;;;2028   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;2050   
;;;2051   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2052   {
;;;2053   BaseType_t xReturn;
;;;2054   
;;;2055   	configASSERT( xQueue );
000002  b951              CBNZ     r1,|L21.26|
000004  bf00              NOP      
000006  2210              MOVS     r2,#0x10
000008  f3828811          MSR      BASEPRI,r2
00000c  f3bf8f4f          DSB      
000010  f3bf8f6f          ISB      
000014  bf00              NOP      
000016  bf00              NOP      
                  |L21.24|
000018  e7fe              B        |L21.24|
                  |L21.26|
;;;2056   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
00001a  6b8a              LDR      r2,[r1,#0x38]
00001c  6bcb              LDR      r3,[r1,#0x3c]
00001e  429a              CMP      r2,r3
000020  d101              BNE      |L21.38|
;;;2057   	{
;;;2058   		xReturn = pdTRUE;
000022  2001              MOVS     r0,#1
000024  e000              B        |L21.40|
                  |L21.38|
;;;2059   	}
;;;2060   	else
;;;2061   	{
;;;2062   		xReturn = pdFALSE;
000026  2000              MOVS     r0,#0
                  |L21.40|
;;;2063   	}
;;;2064   
;;;2065   	return xReturn;
;;;2066   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000028  4770              BX       lr
;;;2067   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=1

                  xQueuePeekFromISR PROC
;;;1637   
;;;1638   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1639   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;1640   BaseType_t xReturn;
;;;1641   UBaseType_t uxSavedInterruptStatus;
;;;1642   int8_t *pcOriginalReadPosition;
;;;1643   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000008  4634              MOV      r4,r6
;;;1644   
;;;1645   	configASSERT( pxQueue );
00000a  b954              CBNZ     r4,|L22.34|
00000c  bf00              NOP      
00000e  2010              MOVS     r0,#0x10
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L22.32|
000020  e7fe              B        |L22.32|
                  |L22.34|
;;;1646   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000022  f1b80f00          CMP      r8,#0
000026  d101              BNE      |L22.44|
000028  6c20              LDR      r0,[r4,#0x40]
00002a  b908              CBNZ     r0,|L22.48|
                  |L22.44|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L22.50|
                  |L22.48|
000030  2000              MOVS     r0,#0
                  |L22.50|
000032  b950              CBNZ     r0,|L22.74|
000034  bf00              NOP      
000036  2010              MOVS     r0,#0x10
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  bf00              NOP      
000046  bf00              NOP      
                  |L22.72|
000048  e7fe              B        |L22.72|
                  |L22.74|
;;;1647   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
00004a  6c20              LDR      r0,[r4,#0x40]
00004c  b108              CBZ      r0,|L22.82|
00004e  2001              MOVS     r0,#1
000050  e000              B        |L22.84|
                  |L22.82|
000052  2000              MOVS     r0,#0
                  |L22.84|
000054  b950              CBNZ     r0,|L22.108|
000056  bf00              NOP      
000058  2010              MOVS     r0,#0x10
00005a  f3808811          MSR      BASEPRI,r0
00005e  f3bf8f4f          DSB      
000062  f3bf8f6f          ISB      
000066  bf00              NOP      
000068  bf00              NOP      
                  |L22.106|
00006a  e7fe              B        |L22.106|
                  |L22.108|
;;;1648   
;;;1649   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1650   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1651   	above the maximum system call priority are kept permanently enabled, even
;;;1652   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1653   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1654   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1655   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1656   	assigned a priority above the configured maximum system call priority.
;;;1657   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1658   	that have been assigned a priority at or (logically) below the maximum
;;;1659   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1660   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1661   	More information (albeit Cortex-M specific) is provided on the following
;;;1662   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1663   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00006c  f7fffffe          BL       vPortValidateInterruptPriority
;;;1664   
;;;1665   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000070  bf00              NOP      
000072  2110              MOVS     r1,#0x10
000074  f3ef8011          MRS      r0,BASEPRI
000078  f3818811          MSR      BASEPRI,r1
00007c  f3bf8f4f          DSB      
000080  f3bf8f6f          ISB      
000084  bf00              NOP      
000086  4605              MOV      r5,r0
;;;1666   	{
;;;1667   		/* Cannot block in an ISR, so check there is data available. */
;;;1668   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000088  6ba0              LDR      r0,[r4,#0x38]
00008a  b148              CBZ      r0,|L22.160|
;;;1669   		{
;;;1670   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1671   
;;;1672   			/* Remember the read position so it can be reset as nothing is
;;;1673   			actually being removed from the queue. */
;;;1674   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
00008c  f8d4900c          LDR      r9,[r4,#0xc]
;;;1675   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000090  4641              MOV      r1,r8
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       prvCopyDataFromQueue
;;;1676   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
000098  f8c4900c          STR      r9,[r4,#0xc]
;;;1677   
;;;1678   			xReturn = pdPASS;
00009c  2701              MOVS     r7,#1
00009e  e000              B        |L22.162|
                  |L22.160|
;;;1679   		}
;;;1680   		else
;;;1681   		{
;;;1682   			xReturn = pdFAIL;
0000a0  2700              MOVS     r7,#0
                  |L22.162|
;;;1683   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1684   		}
;;;1685   	}
;;;1686   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000a2  bf00              NOP      
0000a4  f3858811          MSR      BASEPRI,r5
0000a8  bf00              NOP      
;;;1687   
;;;1688   	return xReturn;
0000aa  4638              MOV      r0,r7
;;;1689   }
0000ac  e8bd87f0          POP      {r4-r10,pc}
;;;1690   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1550   
;;;1551   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1552   {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;1553   BaseType_t xReturn;
;;;1554   UBaseType_t uxSavedInterruptStatus;
;;;1555   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00000a  4634              MOV      r4,r6
;;;1556   
;;;1557   	configASSERT( pxQueue );
00000c  b954              CBNZ     r4,|L23.36|
00000e  bf00              NOP      
000010  2010              MOVS     r0,#0x10
000012  f3808811          MSR      BASEPRI,r0
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L23.34|
000022  e7fe              B        |L23.34|
                  |L23.36|
;;;1558   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000024  f1b90f00          CMP      r9,#0
000028  d101              BNE      |L23.46|
00002a  6c20              LDR      r0,[r4,#0x40]
00002c  b908              CBNZ     r0,|L23.50|
                  |L23.46|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L23.52|
                  |L23.50|
000032  2000              MOVS     r0,#0
                  |L23.52|
000034  b950              CBNZ     r0,|L23.76|
000036  bf00              NOP      
000038  2010              MOVS     r0,#0x10
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L23.74|
00004a  e7fe              B        |L23.74|
                  |L23.76|
;;;1559   
;;;1560   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1561   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1562   	above the maximum system call priority are kept permanently enabled, even
;;;1563   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1564   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1565   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1566   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1567   	assigned a priority above the configured maximum system call priority.
;;;1568   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1569   	that have been assigned a priority at or (logically) below the maximum
;;;1570   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1571   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1572   	More information (albeit Cortex-M specific) is provided on the following
;;;1573   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1574   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00004c  f7fffffe          BL       vPortValidateInterruptPriority
;;;1575   
;;;1576   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000050  bf00              NOP      
000052  2110              MOVS     r1,#0x10
000054  f3ef8011          MRS      r0,BASEPRI
000058  f3818811          MSR      BASEPRI,r1
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
000064  bf00              NOP      
000066  4605              MOV      r5,r0
;;;1577   	{
;;;1578   		/* Cannot block in an ISR, so check there is data available. */
;;;1579   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000068  6ba0              LDR      r0,[r4,#0x38]
00006a  b1f0              CBZ      r0,|L23.170|
;;;1580   		{
;;;1581   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1582   
;;;1583   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00006c  4649              MOV      r1,r9
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       prvCopyDataFromQueue
;;;1584   			--( pxQueue->uxMessagesWaiting );
000074  6ba0              LDR      r0,[r4,#0x38]
000076  1e40              SUBS     r0,r0,#1
000078  63a0              STR      r0,[r4,#0x38]
;;;1585   
;;;1586   			/* If the queue is locked the event list will not be modified.
;;;1587   			Instead update the lock count so the task that unlocks the queue
;;;1588   			will know that an ISR has removed data while the queue was
;;;1589   			locked. */
;;;1590   			if( pxQueue->xRxLock == queueUNLOCKED )
00007a  6c60              LDR      r0,[r4,#0x44]
00007c  1c40              ADDS     r0,r0,#1
00007e  d10e              BNE      |L23.158|
;;;1591   			{
;;;1592   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000080  6920              LDR      r0,[r4,#0x10]
000082  b908              CBNZ     r0,|L23.136|
000084  2001              MOVS     r0,#1
000086  e000              B        |L23.138|
                  |L23.136|
000088  2000              MOVS     r0,#0
                  |L23.138|
00008a  b958              CBNZ     r0,|L23.164|
;;;1593   				{
;;;1594   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00008c  f1040010          ADD      r0,r4,#0x10
000090  f7fffffe          BL       xTaskRemoveFromEventList
000094  b130              CBZ      r0,|L23.164|
;;;1595   					{
;;;1596   						/* The task waiting has a higher priority than us so
;;;1597   						force a context switch. */
;;;1598   						if( pxHigherPriorityTaskWoken != NULL )
000096  b12f              CBZ      r7,|L23.164|
;;;1599   						{
;;;1600   							*pxHigherPriorityTaskWoken = pdTRUE;
000098  2001              MOVS     r0,#1
00009a  6038              STR      r0,[r7,#0]
00009c  e002              B        |L23.164|
                  |L23.158|
;;;1601   						}
;;;1602   						else
;;;1603   						{
;;;1604   							mtCOVERAGE_TEST_MARKER();
;;;1605   						}
;;;1606   					}
;;;1607   					else
;;;1608   					{
;;;1609   						mtCOVERAGE_TEST_MARKER();
;;;1610   					}
;;;1611   				}
;;;1612   				else
;;;1613   				{
;;;1614   					mtCOVERAGE_TEST_MARKER();
;;;1615   				}
;;;1616   			}
;;;1617   			else
;;;1618   			{
;;;1619   				/* Increment the lock count so the task that unlocks the queue
;;;1620   				knows that data was removed while it was locked. */
;;;1621   				++( pxQueue->xRxLock );
00009e  6c60              LDR      r0,[r4,#0x44]
0000a0  1c40              ADDS     r0,r0,#1
0000a2  6460              STR      r0,[r4,#0x44]
                  |L23.164|
;;;1622   			}
;;;1623   
;;;1624   			xReturn = pdPASS;
0000a4  f04f0801          MOV      r8,#1
0000a8  e001              B        |L23.174|
                  |L23.170|
;;;1625   		}
;;;1626   		else
;;;1627   		{
;;;1628   			xReturn = pdFAIL;
0000aa  f04f0800          MOV      r8,#0
                  |L23.174|
;;;1629   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1630   		}
;;;1631   	}
;;;1632   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000ae  bf00              NOP      
0000b0  f3858811          MSR      BASEPRI,r5
0000b4  bf00              NOP      
;;;1633   
;;;1634   	return xReturn;
0000b6  4640              MOV      r0,r8
;;;1635   }
0000b8  e8bd87f0          POP      {r4-r10,pc}
;;;1636   /*-----------------------------------------------------------*/
                          ENDP

